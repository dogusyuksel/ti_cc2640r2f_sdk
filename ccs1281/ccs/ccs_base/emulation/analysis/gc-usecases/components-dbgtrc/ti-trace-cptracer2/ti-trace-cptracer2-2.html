<!DOCTYPE html>
<!--
    Copyright (c) 2019, Texas Instruments Incorporated
    All rights reserved.

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:

    *   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.
    notice, this list of conditions and the following disclaimer in the
    documentation and/or other materials provided with the distribution.
    *   Neither the name of Texas Instruments Incorporated nor the names of
    its contributors may be used to endorse or promote products derived
    from this software without specific prior written permission.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
    AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
    THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
    CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
    EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
    OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
    WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
    OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
    EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<link rel="import" href="../../components/polymer/polymer.html">
<link rel="import" href="../../components/web-animations-js/web-animations.min.js">
<link rel="import" href="../../components/neon-animation/web-animations.html">
<link rel="import" href="../../components/ti-core-stylesheets/ti-core-stylesheets.html">
<link rel="import" href="../../components/paper-dialog/paper-dialog.html">
<link rel="import" href="../../components/paper-icon-button/paper-icon-button.html">
<link rel="import" href="../../components/iron-icons/av-icons.html">

<link rel="import" href="../../components/ti-widget-common/ti-widget-tab.html">
<link rel="import" href="../../components/ti-widget-common/ti-widget-tabcontainer.html">

<link rel="import" href="../ti-trace-common/ti-trace-progress.html">
<link rel="import" href="../ti-trace-model/ti-trace-model.html">
<link rel="import" href="../ti-trace-stm/ti-trace-menubar.html">
<link rel="import" href="../ti-trace-cptracer2/ti-trace-cpt2-config.html">
<link rel="import" href="../ti-trace-cptracer2/ti-trace-cptracer2-common-config.html">
<link rel="import" href="../ti-trace-cptracer2/ti-trace-cptracer2-graph.html">
<link rel="import" href="../ti-trace-tables/ti-trace-table.html">

<dom-module id="ti-trace-cptracer2">
    <template>
        <style>
            * {
                font-size: 12px;
                font-family: Roboto, sans-serif;
            }
            html {
                margin: 0px;
                padding: 0px;
            }
            body {
                padding: 0;
                margin: 0;
                border: 0;
            }
            .page {
                height: 100%;
                flex: 1;
                display: flex;
                align-items: stretch;
                flex-direction: column;
                overflow: auto;
                -webkit-overflow-scrolling: touch;
                font-family: "Roboto Mono";
                -ms-text-size-adjust: 100%;
                -webkit-text-size-adjust: 100%;
                font-weight: 400;
                font-size: 14px;
            }
            paper-icon-button#redo {
                color: white;
                padding: 0px;
                height: 24px;
                width: 24px;
            }
            #menuBar {
                display: flex;
                width: 100%;
                height: 40px;
            }
            #traceDataContainer {
                position:absolute;
                width: 100%;
                height: 100%;
            }
            button {
              display: block;
              line-height: 40px;
              background-color: transparent;
              border: none;
              font-size: 14px;
              margin: 20px;
            }
        </style>
        <ti-trace-model id="tm" trace-agent="{{ta}}" device-info="{{liveDeviceInfo}}"></ti-trace-model>
        <ti-trace-progress id="progress" status="[[_traceStatus]]"></ti-trace-progress>
        <ti-trace-cpt2-config id="traceConfig" ta="[[ta]]" out-file="[[activeOutFileName]]"
            device-info="[[liveDeviceInfo]]" core="[[currentAggregator]]" 
            trace-routes="[[traceRoutes]]" trace-route="{{traceRoute}}"
            header-text="Traffic Profiling" aet-property-tree="{{currentAetPropertyTree}}"
            receiver-property-tree="{{receiverPropertyTree}}"
            selected-domain-changed=[[selectedDomainChanged]] domain-array=[[domainArray]]
            probe-array=[[currentProbeArray]]
            sync-cores=[[syncCores]]
            sync-core-halt={{syncCoreHalt}}
            device-id=[[deviceId]]
            current-use-case={{currentUseCase}} no-cancel>
        </ti-trace-cpt2-config>
        <ti-trace-menubar id="menuBar" open-settings=[[toggleSettings]] reset=[[reset]] status-msg=[[_traceStatus]] num-records=[[_rowCountText]] num-gaps=[[numGaps]]  start-callback="{{propertyTreesChanged}}" stop-callback="{{haltTrace}}" save-callback="{{save_as_tdf}}"></ti-trace-menubar>
        
        <ti-widget-tabcontainer id="traceDataContainer" selected-index="0" selected-label="Setup" layout on-selected_tab_changed="tabClickCallback">
            <ti-widget-tab id="cpt2GraphView" name="[[graphDataTabName]]" icon="timeline" tooltip="Trace graph view" active>
                <ti-trace-cptracer2-graph id='cptracer2Graph' trace-data=[[graphTraceData]] current-use-case=[[currentUseCase]]></ti-trace-cptracer2-graph>
            </ti-widget-tab>
            <ti-widget-tab id="cpt2DataView" class="tracedataview" name="[[rawDataTabName]]" icon="icons:view-column" tooltip="click to view the raw data">
                <ti-trace-table id="traceTable" table-size="[[rowCount]]" column-labels="[[columnNames]]" data-provider="[[_traceDataProvider]]" active-item="{{activeItem}}"></ti-trace-table>
            </ti-widget-tab>
        </ti-widget-tabcontainer>

        <paper-dialog id="errorDlg" modal on-opened-changed="_errorDialogChanged">
            <h2>Trace Configuration Error</h2>
            <p>[[_traceConfigurationErrorMessage]]</p>
            <div class="buttons">
                <paper-button dialog-dismiss>Close</paper-button>
            </div>
        </paper-dialog>
        <paper-dialog id="filerror" modal>
            <h2>Error</h2>
            Error occurred while saving file
            <paper-button dialog-confirm autofocus>Dismiss</paper-button>
        </paper-dialog>
        <paper-dialog id="resetDlg" modal on-opened-changed="_resetDialogChanged">
            <h2>Reset Traffic Profiling Settings</h2>
            <p>All Traffic Profiling settings will be reset to default values.</p>
            <p>Okay to proceed?</p>
            <div class="buttons">
                <paper-button dialog-dismiss>No</paper-button>
                <paper-button dialog-confirm autofocus>Yes</paper-button>
            </div>
        </paper-dialog>
    </template>
    <script>
        /* eslint "no-console" : "off" */
        /* global Q:false */
        Polymer({
            is: 'ti-trace-cptracer2',
            properties: {
                deviceId: {
                    notify: true,
                    type: Number,
                    value: undefined  
                },
                aggregators: {
                    type: Array,
                    value: function() {
                        return [];
                    },
                    notify: true
                },
                currentAggregator: {
                    notify: true,
                    type: String,
                    reflectToAttribute: true,
                    value: undefined
                },
                activeItem: {
                    observer: "activeItemChanged"
                },
                liveDeviceInfo : {
                    notify: true,
                    type: Object,
                    reflectToAttribute: true,
                    value: undefined,
                    observer: "_liveDeviceInfoChanged",
                },
                deviceInfo : {
                    notify: true,
                    type: Object,
                    reflectToAttribute: true,
                    value: undefined,
                    observer: "_deviceInfoChanged",
                },
                traceOp : {
                    notify: true,
                    type: Number,
                    reflectToAttribute: true,
                    value: undefined
                },
                columnNames : {
                    notify: true,
                    type: Array,
                    reflectToAttribute: true,
                    value : function() {
                        return [];
                    }
                },
                activeOutFileName : {
                    type: String,
                    value: undefined,
                    reflectToAttribute: true,
                },
                aetPropertyTrees : {
                    type: Array,
                    value: undefined
                },
                currentAetPropertyTree: {
                    type: Object,
                    value: undefined,
                    reflectToAttribute: true,
                    notify: true
                },
                ta : {
                    notify: true,
                    type: Object,
                    reflectToAttribute: true,
                    observer: "_taChanged"
                },
                receiverPropertyTree : {
                    type: Object,
                    value: undefined,
                },
                stmProperties : {
                    notify: true,
                    reflectToAttribute: true,
                    type: Array
                },
                rowCount : {
                    notify: true,
                    reflectToAttribute: true,
                    type: Number,
                    value : 0
                },
                _rowCountText : {
                    notify: true,
                    reflectToAttribute: true,
                    type: String,
                    value: "0"
                },
                _tableVisible: {
                    notify: true,
                    reflectToAttribute: true,
                    value: false,
                },
                _traceDataProvider: {
                    type: Function,
                    value: function () {
                        return this._nullDataProviderFunction;
                    }
                    //value: undefined
                },
                _traceStatus : {
                    notify: true,
                    reflectToAttribute: true,
                    type: String,
                    value: ""
                },
                numGaps : {
                    notify: true,
                    reflectToAttribute: true,
                    type: String,
                    value: "0"
                },
                graphTraceData: {
                    notify: true,
                    reflectToAttribute: true,
                    type: Array,
                    value: []
                },
                graphBufferSize: {
                    type: Number,
                    reflectToAttribute: true,
                    notify: true,
                    // Should be enough space for a full ETB buffer.
                    value: 1500
                },
                updateGraph: {
                    type: Boolean,
                    notify: true,
                    value: false
                },
                traceRoute : {
                    type: Object,
                    value: undefined
                },
                traceRoutes : {
                    notify: true,
                    reflectToAttribute: true,
                    type: Array,
                    value: function () {
                        return [];
                    }
                },
                _errorMessage : {
                    type: String,
                    value: undefined,
                },
                _isActive : {
                    type: Boolean,
                    value: false,
                    observer: "_isActiveChanged",
                },
                _traceConfigurationErrorMessage : {
                    type: String,
                    value: "",
                },
                _options : {
                    type: Array,
                    value: undefined,
                },
                domainArray: {
                    type: Array,
                    value: [],
                    notify: true
                },
                currentProbeArray: {
                    type: Array,
                    value: [],
                    notify: true     
                },
                currentUseCase: {
                    notify: true,
                    reflectToAttribute: true,
                    type: String
                },
                rawDataTabName: {
                    notify: true,
                    reflectToAttribute: true,
                    type: String,
                    value: "Raw Data",
                },
                graphDataTabName: {
                    notify: true,
                    reflectToAttribute: true,
                    type: String,
                    value: "Graph View",
                },
                traceConfigured: {
                    notify: true,
                    type: Boolean,
                    value: false
                },
                bufferFull: {
                    notify: true,
                    type: Boolean,
                    value: false
                },
                syncCores: {
                    type: Array,
                    value: function() {
                        return [];
                    },
                    notify: true
                },
                syncCoreHalt: {
                    type: String,
                    value: "",
                    notify: true,
                    reflectToAttribute: true
                }
            },
            traceTableColumns : [
                {
                    name : "Master ID",
                    index : 0,
                    format : "hex",
                },
                {   
                    name : "Master Name",
                    index : 1,
                    format : "default",
                },
                {  
                    name : "Data Message",
                    index : 4,
                    format : "default",
                },
                {    
                    name : "Global Timestamp",
                    index : 12,
                    format : "hex",
                },
                {   
                    name : "Trace Status",
                    index : 13,
                    format : "default",
                },
            ],
            traceTableColumnsThroughput : [
                {    
                    name : "Byte Transactions",
                    index : 15,
                    format : "hex",
                },
                {    
                    name : "Matched",
                    index : 16,
                    format : "hex",
                },
                {    
                    name : "Avg. Length",
                    index : 17,
                    format : "hex",
                },
            ],
            traceTableColumnsLatency : [
                {    
                    name : "Tracked",
                    index : 18,
                    format : "hex",
                },
                {    
                    name : "Matched Transactions",
                    index : 19,
                    format : "hex",
                },
                {    
                    name : "Max Wait",
                    index : 20,
                    format : "hex",
                },
                {    
                    name : "Total Wait",
                    index : 21,
                    format : "hex",
                },
                {    
                    name : "Credit Wait",
                    index : 22,
                    format : "hex",
                },
            ],
            traceTableColumnsTransaction : [
                {   
                    name : "Address",
                    index : 11,
                    format : "hex",
                },
                {    
                    name : "Mode",
                    index : 23,
                    format : "default",
                },
                {    
                    name : "Route ID",
                    index : 24,
                    format : "hex",
                },
                {    
                    name : "DIR",
                    index : 25,
                    format : "default",
                },
                {    
                    name : "EXCL",
                    index : 26,
                    format : "default",
                },
                {    
                    name : "Byte Count",
                    index : 27,
                    format : "hex",
                },
                {    
                    name : "Priority",
                    index : 28,
                    format : "hex",
                },
                {    
                    name : "LSIZE",
                    index : 29,
                    format : "default",
                },
                {    
                    name : "PRIV",
                    index : 30,
                    format : "default",
                },
                {    
                    name : "PRIVID",
                    index : 31,
                    format : "hex",
                },
                {    
                    name : "DTYPE",
                    index : 32,
                    format : "default",
                },
                {    
                    name : "RSEL",
                    index : 33,
                    format : "hex",
                },
                {    
                    name : "Interest",
                    index : 34,
                    format : "default",
                },
                {    
                    name : "EMUDBG",
                    index : 35,
                    format : "default",
                },
                {    
                    name : "INNER",
                    index : 36,
                    format : "default",
                },
                {    
                    name : "OUTER",
                    index : 37,
                    format : "default",
                },
                {    
                    name : "SDOMAIN",
                    index : 38,
                    format : "default",
                },
                {    
                    name : "QOS",
                    index : 39,
                    format : "hex",
                },
                {    
                    name : "SECURE",
                    index : 40,
                    format : "default",
                },
                {    
                    name : "MEMTYPE",
                    index : 41,
                    format : "default",
                },
                {    
                    name : "OPCODE",
                    index : 42,
                    format : "default",
                },
                {    
                    name : "CSBAND",
                    index : 43,
                    format : "hex",
                },
                {    
                    name : "FLUSH",
                    index : 44,
                    format : "default",
                },
                {    
                    name : "EPRIORITY",
                    index : 45,
                    format : "hex",
                },
                {    
                    name : "Order ID",
                    index : 46,
                    format : "hex",
                },
                {    
                    name : "MSBAND",
                    index : 47,
                    format : "hex",
                },
                {    
                    name : "FWPASS",
                    index : 48,
                    format : "default",
                },
                {    
                    name : "PABLE",
                    index : 49,
                    format : "default",
                },
                {    
                    name : "Virtual ID",
                    index : 50,
                    format : "hex",
                },
                {    
                    name : "ASEL",
                    index : 51,
                    format : "hex",
                },
                {    
                    name : "ATYPE",
                    index : 52,
                    format : "default",
                },
                {    
                    name : "Channel ID",
                    index : 53,
                    format : "hex",
                },
            ],
            traceTableColumnsRaw : [
                {    
                    name : "Raw CPT2 MSG",
                    index : 54,
                    format : "default",
                }   
            ],
            ready: function() {
                this._errorMessage = "Waiting to connect to debug session";
                var params = location.search.substr(1).split("&").map(p => {
                    var tmp = p.split("=");
                    return {name : tmp[0], value: tmp[1]};
                });

                var coreNameParam = params.find(x => x.name === "coreName");

                this.coreName = (coreNameParam !== undefined) ? coreNameParam.value : undefined;

                var coreTypeParam = params.find(x => x.name === "coreType");

                this.coreType = (coreTypeParam !== undefined) ? coreTypeParam.value : undefined;

                var tdfFileParam = params.find(x => x.name === "tdf");

                this.tdfFile = (tdfFileParam !== undefined) ? decodeURIComponent(tdfFileParam.value) : undefined;

                this.isLive = this.tdfFile === undefined;

                this.rowCountUpdated = false;

                // Bind callback functions
                this.evtCallback = this._evtCallback.bind(this);
                this.traceTableSizeCallback = this._traceTableSizeCallback.bind(this);
                this.tabClickCallback = this._tabClickCallback.bind(this);
                this.toggleSettings = this._toggleSettings.bind(this);
                this.reset = this._reset.bind(this);
                this.configureTrace = this._configureTrace.bind(this);
                this.save_as_tdf = this._save_as_tdf.bind(this);
                this.propertyTreesChanged = this._propertyTreesChanged.bind(this);
                this.haltTrace = this._haltTrace.bind(this);
                this.selectedDomainChanged = this._selectedDomainChanged.bind(this);

                var _self = this;
                window.addEventListener("beforeunload", function (ev) {
                    _self._releaseOperations();
                    _self._destroyTrace();
                    _self._isActive = false;
                });
            },
            _systemEvent: function (sysEvt)
            {
                if (sysEvt.eventName === "DebugSessionStopping") {
                    console.log("closing");
                    window.close();
                }
                console.log("Received event: '" + sysEvt.eventName + "'");;
            },
            _taChanged: function (val) {
                if (val !== undefined) {
                    this.ta.cloudTrace.addListener("systemEvent", this._systemEvent.bind(this));
                    if (!this.isLive) {
                        var _self = this;
                        var devInfo = {tdf: this.tdfFile};
                        this.ta.cloudTrace.getDevices(devInfo).then(function (ret) {
                            _self.deviceInfo = ret.devices[0].device_info;
                        }).catch(function (err) {
                            console.log(err.message);
                        });
                    }
                }
            },
            _errorDialogChanged : function () {
                if (!this.$.errorDlg.opened) {
                    this._restart();
                }
            },
            _restart: function ()
            {
                var _self = this;
                this._tableVisible = false;
                this._preconfigureTrace().finally(function () {
                    _self._traceDataProvider = _self._nullDataProviderFunction;
                    _self.rowCount = 0;
                    _self._rowCountText = "0";
                    var grid = _self.$$("#traceTable");
                    if ((grid !== undefined) && (grid !== null)) {
                        grid.$.traceTable.clearCache();
                        grid.$.traceTable.notifyResize();
                    }
                });
            },
            save_as_tdf: undefined,
            _save_as_tdf: function()
            {
                var _self = this;
                var params = {};
                params.title = "Save Trace";
                params.names = ["Trace Data File (.tdf)", "Comma Separated File (.csv)"]
                params.extensions = ["*.tdf", "*.csv"];
                params.style = "save";
                this.ta.cloudTrace.fileDialog(params).then(function (ret) {
                    var filename = ret.filename;
                    if (filename !== "") {
                        if (ret.extensionIndex === 0)
                        {
                            if (filename.slice(-4) !== ".tdf") {
                                filename += ".tdf";
                            }
                            var info = {};
                            info.deviceId = _self.deviceId;
                            info.coreType = _self.currentUseCase;
                            var coreNameSplit = _self.currentAggregator.split('/');
                            if (coreNameSplit.length == 2) {
                                info.coreName = coreNameSplit[1];
                            }
                            else {
                                info.coreName = _self.currentAggregator;
                            }

                            info.useCases = ["cpt2_trace"];
                            _self._traceStatus = "Saving Trace Data as tdf...";
                            _self.$.progress.open();
                            return _self.ta.cloudTrace.saveAs(_self.traceOp, "tdf", filename, info).then(function (ret) {
                                _self._traceStatus = filename + " saved.";
                                _self.$.progress.close();
                            });
                        } else if (ret.extensionIndex === 1) {
                            if (filename.slice(-4) !== ".csv") {
                                filename += ".csv";
                            }
                            var info = {};
                            _self._traceStatus = "Saving Trace Data as csv...";
                            _self.$.progress.open();
                            return _self.ta.cloudTrace.saveAs(_self.traceOp, "csv", filename, info).then (function (ret) {
                                _self._traceStatus = filename + " saved.";
                                _self.$.progress.close();
                            });
                        }
                    }
                }).catch(function (err){
                    _self.$.progress.close();
                    _self.$.filerror.open();
                });
            },
            // This function is called when a row in the trace table is clicked on (selected).
            // It calls into CloudTrace to request the editor and disassembly windows to be updated
            // to highlight corresponding source and assembly text to be highlighted.
            activeItemChanged: function()
            {
                if ((this.activeItem !== undefined) && (this.activeItem !== null))
                {
                    var lineNo = parseInt(this.activeItem[this.lineNoColumn]);
                    var file = this.activeItem[this.fileColumn];
                    var dir = this.activeItem[this.directoryColumn];
                    var addr = this.activeItem[this.pcColumn];
                    if (lineNo !== undefined && ! isNaN(lineNo) && dir !== "" && file !== "")
                    {
                        this.ta.cloudTrace.setEditorViewLocation(dir+"/"+file,lineNo).then(function (ret) {
                            console.log(JSON.stringify(ret));
                        });
                    }
                    if (addr !== undefined)
                    {
                        this.ta.cloudTrace.setDisassemblyViewAddress(addr).then(function (ret) {
                            console.log(JSON.stringify(ret));
                        });
                    }
                }
            },
            /*
            * Data provider function that returns the empty array - used when trace data is not available
            */
            _nullDataProviderFunction: function (opts, callback)
            {
                console.log("_nullDataProviderFunction called");
                callback([], 0);
            },
            /*
            * Data provider function that calls into CloudTrace to get trace data - used when trace data is available.
            */
            _traceDataProviderFunction: function (params, cb) 
            {
                var _self = this;

                console.log("_traceDataProviderFunction called, page: " + params.page+" page size (" + params.pageSize +")");
                if (typeof this.traceOp !== 'undefined') {
                    this.ta.cloudTrace.readTraceDataPage(this.traceOp, params.page, params.pageSize).then(function (retObj) {
                        if (_self.rowCountUpdated) {
                            _self.rowCountUpdated = false;
                            _self.$$("#traceTable").$.traceTable.notifyResize();
                        }
                        cb(retObj.traceData, _self.rowCount);
                    }).then(function () {
                        if (_self.updateGraph) {
                            return _self.ta.cloudTrace.getReducedGraphData(_self.traceOp, _self.graphBufferSize);
                        }
                    }).then(function (ret) {
                        if (ret !== undefined) {
                            _self.updateGraph = false;
                            _self._updateGraphTraceData(ret.table);
                        }
                        return _self.ta.cloudTrace.getNumberOfGaps(_self.traceOp);
                    }).then(function (ret) {
                        _self.numGaps = ret.numRead;
                        _self._traceStatus = "Trace Data Available"
                        _self.$.progress.close();
                    }).fail(function (err) {
                        console.log("data provider command failed: "+JSON.stringify(err));
                        cb([], 0);
                    });
                } else {
                    console.log("unknown trace op");
                    cb([],0);
                }
            },
            _activeCoreChanged: function(val)
            {
                if (val === undefined) {
                    this.splice('traceRoutes',0,this.traceRoutes.length);
                    this.$.traceConfig.close();
                } else {
                    var probe = this.deviceInfo.name;
                    var source = probe + "/" + val;
                    var traceRoutes = this.deviceInfo.trace_routes.filter(
                        route => (route.source === source) && 
                                    ((route.receiver !== "Pro Trace") || probe.includes("XDSPRO"))
                    );
                    this.splice('traceRoutes',0,this.traceRoutes.length, ...traceRoutes);
                    if (this.isLive) {
                        // Configure trace collection on live system
                        this.$.traceConfig.open();
                    } else {
                        
                        // Using TDF, so can just create decoder and go
                        var _self = this;
                        _self.updateGraph = true;
                        this.ta.cloudTrace.addListener("traceTableSizeEvent", _self.traceTableSizeCallback);
                        this.ta.cloudTrace.createOperation(this.tdfFile,"TDF").then(function (ret) {
                            _self.traceOp = ret.handle;
                            return _self.ta.cloudTrace.createTrace(_self.traceOp);
                        }).then(function (ret) {
                            return _self.ta.cloudTrace.enableTraceTableSizeEvent(_self.traceOp);
                        }).then(function (ret) {
                            return _self.ta.cloudTrace.readObjectFile(_self.traceOp, true, false);
                        }).then(function (ret) {
                            return _self.ta.cloudTrace.readTraceColumnNames(_self.traceOp);
                        }).then(function () {

                            var cols = [];

                            
                            if (_self.tdfCoreType.toLowerCase().indexOf("latency") !== -1) {
                                _self.currentUseCase = "Latency Statistics";
                            }
                            else if (_self.tdfCoreType.toLowerCase().indexOf("throughput") !== -1) {
                                _self.currentUseCase = "Throughput Statistics";
                            }
                            else if (_self.tdfCoreType.toLowerCase().indexOf("transaction") !== -1) {
                                _self.currentUseCase = "Transaction Logging";
                            }

                            _self.traceTableColumns.forEach(function (el) {
                                cols.push(el);
                            });
                        
                            if (_self.currentUseCase == "Throughput Statistics") {
                                _self.traceTableColumnsThroughput.forEach(function (el) {
                                    cols.push(el);
                                }); 
                            }
                        
                            if (_self.currentUseCase == "Latency Statistics") {
                                _self.traceTableColumnsLatency.forEach(function (el) {
                                    cols.push(el);
                                }); 
                            }
                        
                            if (_self.currentUseCase == "Transaction Logging") {
                                _self.traceTableColumnsTransaction.forEach(function (el) {
                                    cols.push(el);
                                }); 
                            }

                            return _self.ta.cloudTrace.setupColumnProcessing(_self.traceOp, cols);
                        }).then(function () {
                            return _self.ta.cloudTrace.readTraceColumnNames(_self.traceOp);
                        }).then(function (ret) {
                            _self.columnNames = ret.columns;
                            _self._tableVisible = true;
                            return _self.ta.cloudTrace.fetchTraceData(_self.traceOp);
                        }).then(function () {
                        return _self.ta.cloudTrace.getReducedGraphData(_self.traceOp, _self.graphBufferSize);
                    }).then(function (ret) {
                        if (ret !== undefined) {
                            _self.updateGraph = false;
                            _self._updateGraphTraceData(ret.table);
                        }
                        return _self.ta.cloudTrace.getNumberOfGaps(_self.traceOp);
                    }).then(function (ret) {
                        _self.numGaps = ret.numRead;
                        _self._traceStatus = "Trace Data Available"
                        _self.$.progress.close();
                        }).then(function (ret) {
                            console.log("dbg");
                        }).catch(function (err) {
                            _self._traceStatus = "Error Reading Trace Data";
                            _self._tableVisible = false;
                            var traceCpu = this.deviceInfo.name + "/" + this.activeCore;
                            _self.ta.cloudTrace.disableTraceTableSizeEvent(_self.traceOp);
                            _self.ta.cloudTrace.removeListener("traceTableSizeEvent", _self.traceTableSizeCallback);
                            _self._releaseOperations();
                            _self._destroyTrace();
                            _self.$.progress.close();
                            console.log("Failure: "+JSON.stringify(err));
                        });
                    }
                }
            },
            propertyTreesChanged: undefined,
            _propertyTreesChanged: function ()
            {
                if ((this.aetPropertyTrees !== undefined) && (this.aetPropertyTrees.length > 0)) {
                    this.rowCount = 0;
                    this._traceDataProvider = this._nullDataProviderFunction;
                    this._configureTrace(this.traceRoute, this.aetPropertyTrees, this.receiverPropertyTree);
                }
            },
            _isActiveChanged: function(val) {
                if (!val) {
                    this.$.traceConfig.close();
                    this._errorMessage = "Waiting to connect to debug session";
                    var _self = this;
                    this.rowCount = 0;
                    this._traceDataProvider = this._nullDataProviderFunction;
                    var traceTable = this.$$("#traceTable");
                    if (traceTable !== null) {
                        traceTable.$.traceTable.size = 0;
                        traceTable.$.traceTable.notifyResize();
                    }
                    this._releaseOperations().then(function () {
                        return _self._destroyTrace();
                    });
                }
            },
            traceTableSizeCallback: undefined,                
            _traceTableSizeCallback: function(info)
            {
                console.log("Trace Table Size Event received: " + JSON.stringify(info));
                if (info.handle === this.traceOp) {
                    console.log("Number of rows: " + info.size);
                    if (this.rowCount == 0) {
                        this.$.progress.close();
                        this._traceDataProvider = this._traceDataProviderFunction.bind(this);
                        this.rowCount = info.size;
                        this.rowCountUpdated = true;
                        this._rowCountText = info.size.toString().replace(/\B(?=(\d{3})+(?!\d))/g,",");
                    } else {
                        this._rowCountText = info.size.toString().replace(/\B(?=(\d{3})+(?!\d))/g,",");
                        this.debounce('updateRowCount', function () {
                            this.rowCount = info.size;
                            this.rowCountUpdated = true;
                        }, 1000);
                    }
                }
            },
            _updateGraphTraceData: function(dataObj) {
                var _self = this;

                _self.graphTraceData = dataObj;
            },
            _processTrace: function () {
                this._releaseOperations();
            },
            haltTrace: undefined,
            _haltTrace: function ()
            {
                var _self = this;
                _self._traceStatus = "Reading Trace Data...";
                _self.$.progress.open();
                _self.$.menuBar.setStartIcon();

                _self.ta.cloudTrace.stopTraceCapture(_self.traceOp).then(function() {
                    return _self.ta.cloudTrace.readTraceColumnNames(_self.traceOp);
                }).then(function () {
                    
                    var cols = [];
                    _self.traceTableColumns.forEach(function (el) {
                        cols.push(el);
                    });

                    if (_self.currentUseCase == "Throughput Statistics") {
                        _self.traceTableColumnsThroughput.forEach(function (el) {
                            cols.push(el);
                        }); 
                    }

                    if (_self.currentUseCase == "Latency Statistics") {
                        _self.traceTableColumnsLatency.forEach(function (el) {
                            cols.push(el);
                        }); 
                    }

                    if (_self.currentUseCase == "Transaction Logging") {
                        _self.traceTableColumnsTransaction.forEach(function (el) {
                            cols.push(el);
                        }); 
                    }

                    return _self.ta.cloudTrace.setupColumnProcessing(_self.traceOp, cols);
                }).then(function () {
                    return _self.ta.cloudTrace.readTraceColumnNames(_self.traceOp);
                }).then(function (ret) {
                    _self.columnNames = ret.columns;
                    _self._tableVisible = true;
                    return _self.ta.cloudTrace.fetchTraceData(_self.traceOp);
                }).then(function (ret) {
                    _self._traceStatus = "Trace Data Loading";
                }).catch(function (err) {
                    _self._traceStatus = "Error Reading Trace Data";
                    _self._tableVisible = false;
                    _self.ta.cloudTrace.removeListener("targetEvent",_self.evtCallback);
                    _self.ta.cloudTrace.disableTraceTableSizeEvent(_self.traceOp);
                    _self.ta.cloudTrace.removeListener("traceTableSizeEvent", _self.traceTableSizeCallback);
                    _self._releaseOperations();
                    _self._destroyTrace();
                    _self.$.progress.close();
                    console.log("Failure: "+JSON.stringify(err));
                }).finally(function () {
                    _self.ta.cloudTrace.removeListener("targetEvent",_self.evtCallback);
                });
            },
            _evtCallback: function(info)
            {
                console.log("Event received: " + JSON.stringify(info));
                if (info.eventName === "Halt") {
                    this.haltTrace();
                } else if (info.eventName == "PreRun") {
                    console.log("Target PreRun");
                } else if (info.eventName == "traceChannelStoppedFull") {
                    this.bufferFull = true;
                    if (this.traceConfigured) {
                        this.haltTrace();
                    }
                } else if ((info.eventName == "traceChannelStoppedTraceTrigger") ||
                            (info.eventName == "traceChannelStoppedTrigger")) {
                    if (this.traceConfigured) {
                        this.haltTrace();
                    }
                } else if (info.eventName == "TraceDataRead") {
                    console.log("Trace Data Read Completed");
                    this.ta.cloudTrace.removeListener("targetEvent",this.evtCallback);
                    this.ta.cloudTrace.disableTraceTableSizeEvent(this.traceOp);
                    this.ta.cloudTrace.removeListener("traceTableSizeEvent", this.traceTableSizeCallback);
                    this.ta.cloudTrace.setEnableOperation(this.traceOp, false);
                    this._processTrace();
                }
            },
            _tabClickCallback: function(evt) {
                var tabIndex = evt.detail["selectedIndex"];
                    var childTab = this.$.traceDataContainer.getChildTab(tabIndex);
                    switch(childTab.innerText)
                    {
                        case this.graphDataTabName:
                            this.$.cptracer2Graph.resize();
                            break;
                        case this.rawDataTabName:
                            break;
                        default:
                        break;
                    }
            },
            _toggleSettings : function(){
                var _self = this;    
                _self.$.traceConfig.open();
            },
            _resetDialogChanged : function () {
                if (!this.$.resetDlg.opened) {
                    if (this.$.resetDlg.closingReason != undefined) {
                        if (this.$.resetDlg.closingReason.confirmed) {
                            window.location.reload(1);
                        }
                    }
                }
            },
            _reset : function(){
                var _self = this;
                _self.$.resetDlg.open();
            },
            attached: function() {
                this.$.cptracer2Graph.resize();
            },
            _connectToCores: function (cores)
            {
                if (cores.length === 0) {
                    var p = Q.defer();
                    p.resolve(null);
                    return p.promise;
                } else {
                    var core = cores.shift();
                    var _self = this;
                    return this.$.tm.connectToCore(core.name).then (function () {
                        return _self._connectToCores(cores);
                    }).catch(function (e) {
                        console.log("Failed to connect to core: "+JSON.stringify(e));
                    });
                }
            },
            _liveDeviceInfoChanged: function (val)
            {
                if (this.isLive)
                {
                    if ((this.deviceInfo !== undefined) && (val !== undefined)) {
                        if (this.deviceInfo.id !== val.id) {
                            this.deviceInfo = val;
                        }
                    }
                    else {
                        this.deviceInfo = val;
                    }
                }
            },
            _deviceInfoChanged: function (val)
            {
                var _self = this;

                _self.tdfCoreType = _self.coreType;

                var cores = [];
                var tbrs = [];
                var aggrs = [];
                var stms = [];

                this._traceStatus = "Capturing property tree.";
                this._traceConfigurationErrorMessage = "";
                this.$.progress.open();

                for (let cluster of _self.deviceInfo.children) {
                    for (let node of cluster.children) {
                        if (node.type == "Trace Aggregator") {
                            var nodeObj = {
                                name: node.name,
                                local_name: node.local_name,
                                type: node.type
                            }
                            aggrs.push(nodeObj);

                            // TDF needs these.
                            this.deviceId = val.id;
                            this.coreName = node.local_name;
                            this.coreType = node.type;
                        }
                        else if (node.type == "Trace Buffer") {
                            var nodeObj = {
                                name: node.name,
                                local_name: node.local_name,
                                type: node.type
                            }
                            tbrs.push(nodeObj);
                        }
                        else if (node.type == "STM") {
                            var nodeObj = {
                                name: node.name,
                                local_name: node.local_name,
                                type: node.type
                            }
                            stms.push(nodeObj);
                        }
                    }
                }

                _self.aggregators = aggrs;
                if (aggrs.length > 0) {
                    // Just pick the first one for getting property tree information.
                    _self.currentAggregator = aggrs[0].name;
                }

                var syncCores = ["none"];
                for (let route of this.deviceInfo.trace_routes) {
                    
                    // Make sure not to include aggregator or STM routes as sync sources.
                    var skip = false;

                    for (let aggr of _self.aggregators) {
                        if (route.source == aggr.name) {
                            skip = true;
                            break;
                        }
                    }
                    if (!skip) {
                        for (let stm of stms) {
                            if (route.source == stm.name) {
                                skip = true;
                                break;
                            }
                        }
                    }
                    if (skip) {
                        continue;
                    }

                    // Only add route source if it is unique.
                    if (!syncCores.includes(route.source)) {
                        syncCores.push(route.source);
                    }
                }

                _self.syncCores = syncCores;

                if (!_self.isLive) {
                    this.$.progress.close();
                    var split = _self.currentAggregator.split("/");
                    _self._activeCoreChanged(split[1]);
                    return;
                }

                this._traceCreated = false;

                console.log("Capturing Software Messaging configuration...");
                this._preconfigureTrace().then(function () {
                    return;
                }).then(function () {
                    var p = Q(true);
                    p = p.then(_self.$.tm.connectToCore(_self.currentAggregator));
                    return p;
                }).then(function () {
                    return _self._connectToCores(tbrs);
                }).then(function () {
                    // create AET operation and set the STM Trace Type to STM to retrieve the property tree.
                    var promises = [];
                    promises.push(_self.ta.cloudTrace.createOperation(_self.currentAggregator,"AET"));
                    promises.push(_self.ta.cloudTrace.createOperation(_self.currentAggregator,"Trace"));
                    return Q.all(promises);
                }).then(function (ret) {
                    _self._traceStatus = "Configuring Trace Operation";
                    // Get the operation handles
                    _self.traceOp = ret.pop().handle;
                    _self.aetOp = ret.pop().handle;
                }).then(function () {
                    // Read back the property trees
                    var promises = [];
                    promises.push(_self.ta.cloudTrace.getProperties(_self.aetOp));
                    promises.push(_self.ta.cloudTrace.getProperties(_self.traceOp));
                    return Q.all(promises);
                }).then(function (ret) {
                    
                    var aetProps = ret[0].cfg;
                    var traceProps = ret[1].cfg;
                    console.log("AET properties received: " + JSON.stringify(aetProps, null, 2));
                    console.log("Receiver properties received: " + JSON.stringify(traceProps, null, 2));
                    
                    // We need to convert the default STM AET tree into
                    // a CPT2 operation and expand all of the options for each
                    // probe.  We do this so that we can destroy the operation and clean
                    // each time trace is started and stopped. Also we will save off the
                    // property tree for each domain so that values persist after 
                    // changing the domain.
                    aetProps[0].sub_properties[0].value = "CP Tracer 2";

                    var promises = [];
                    promises.push(_self.ta.cloudTrace.setProperties(_self.aetOp,aetProps));
                    return Q.all(promises);
                }).then(function () {
                    return _self.ta.cloudTrace.getProperties(_self.aetOp);
                }).then(function (ret) {

                    var aetProps = ret.cfg;
                    var promises = [];

                    // Save off every tree for each domain
                    aetProps[0].sub_properties[0].sub_properties[0].allowed_values.forEach(function(domain) {
                        var tempAetProps = aetProps;
                        tempAetProps[0].sub_properties[0].sub_properties[0].value = domain;
                        promises.push(_self.ta.cloudTrace.setProperties(_self.aetOp, tempAetProps));
                        promises.push(_self.ta.cloudTrace.getProperties(_self.aetOp));
                    });
                    return Q.all(promises);

                }).then(function (ret) {

                    var aetPropTrees = [];

                    for (var i = 1; i < ret.length; i += 2) {

                        var tree = ret[i].cfg;

                        for (j = 0; j < tree[0].sub_properties[0].sub_properties[0].sub_properties[0].sub_properties.length; j++) {

                            // TODO - platforms is setting debug bits true here so explicitly initialize to false for now.
                            tree[0].sub_properties[0].sub_properties[0].sub_properties[0].sub_properties[j].sub_properties[3].sub_properties[3].sub_properties[0].value = false;
                            tree[0].sub_properties[0].sub_properties[0].sub_properties[0].sub_properties[j].sub_properties[3].sub_properties[3].sub_properties[1].value = false;
                            tree[0].sub_properties[0].sub_properties[0].sub_properties[0].sub_properties[j].sub_properties[3].sub_properties[3].sub_properties[2].value = false;
                            tree[0].sub_properties[0].sub_properties[0].sub_properties[0].sub_properties[j].sub_properties[3].sub_properties[3].sub_properties[3].value = false;

                            // Set required masks according to probe type.
                            var desc = tree[0].sub_properties[0].sub_properties[0].sub_properties[0].sub_properties[j].desc;

                            if (desc.indexOf("- VBUSM.C") !== -1) {
                                // Clear DIR filter and mask.
                                tree[0].sub_properties[0].sub_properties[0].sub_properties[0].sub_properties[j].sub_properties[3].sub_properties[1].sub_properties[2].value = false;
                                tree[0].sub_properties[0].sub_properties[0].sub_properties[0].sub_properties[j].sub_properties[3].sub_properties[1].sub_properties[3].value = false;
                            }
                            else if ((desc.indexOf("- VBUSM") !== -1) || (desc.indexOf("- VBUSP") !== -1)) {
                                // Clear OPCODE filter and mask.
                                tree[0].sub_properties[0].sub_properties[0].sub_properties[0].sub_properties[j].sub_properties[3].sub_properties[1].sub_properties[10].value = 0;
                                tree[0].sub_properties[0].sub_properties[0].sub_properties[0].sub_properties[j].sub_properties[3].sub_properties[1].sub_properties[11].value = 0;
                            }
                        }

                        aetPropTrees.push(tree);
                    }

                    _self.aetPropertyTrees = aetPropTrees;

                    // Default to first domain.
                    _self.domainArray = _self.aetPropertyTrees[0][0].sub_properties[0].sub_properties[0].allowed_values;
                    _self.currentProbeArray = _self.aetPropertyTrees[0][0].sub_properties[0].sub_properties[0].sub_properties[0].sub_properties;
                    _self.currentAetPropertyTree = _self.aetPropertyTrees[0][0];

                }).then(function () {
                        
                    if (!_self._isActive) {
                        _self._isActive = true;
                    }

                    var probe = _self.deviceInfo.name;
                    var traceRoutes = [];

                    for (var i = 0; i < _self.deviceInfo.trace_routes.length; i++) {
                        
                        route = _self.deviceInfo.trace_routes[i];

                        for (var j = 0; j < _self.aggregators.length; j++) {

                            aggr = _self.aggregators[j];

                            if (route.source == aggr.name) {
                                if ((route.receiver !== "Pro Trace") || probe.includes("XDSPRO")) {
                                    traceRoutes.push(route);
                                    break;
                                }
                            }
                        }
                    }

                    _self.splice('traceRoutes',0,_self.traceRoutes.length, ...traceRoutes);
                }).then(function () {
                    var promises = [];
                    promises.push(_self._releaseOperations());
                    promises.push(_self._destroyTrace());
                    Q.all(promises).finally(function () {
                        _self.$.traceConfig.open();
                        _self.$.progress.close();
                    });
                }).catch(function (err){
                    console.log("Operation failed" + JSON.stringify(err));

                    if (err.message !== undefined) {
                        _self._traceConfigurationErrorMessage = JSON.stringify(err.message);
                    } else {
                        _self._traceConfigurationErrorMessage = JSON.stringify(err);
                    }
                    _self._traceStatus = "Trace Generation Error - Operation Cancelled";

                    var promises = [];
                    promises.push(_self._releaseOperations());
                    promises.push(_self._destroyTrace());
                    Q.all(promises).finally(function () {
                        _self.$.progress.close();
                        _self.$.errorDlg.open();
                    });
                });
            },
            _releaseOperations: function ()
            {
                var p = Q.defer();
                var _self = this;
                var promises = [];

                if (this.traceOp !== undefined) {
                    promises.push(this.ta.cloudTrace.releaseOperation(this.traceOp));
                    if (!this._traceCreated) {
                        this.traceOp = undefined;
                    }
                }
                if ((this.aetOps !== undefined) && (this.aetOps.length > 0)) {
                    this.aetOps.forEach(op => promises.push(_self.ta.cloudTrace.releaseOperation(op)));
                    this.aetOps = [];
                }
                if (promises.length > 0) {
                    Q.all(promises).then(function () {
                        p.resolve();
                    }).catch(function (e) {
                        p.reject(e);
                    });
                } else {
                    p.resolve();
                }
                return p.promise;
            },
            _destroyTrace: function ()
            {
                var p = Q.defer();
                if (this._traceCreated) {
                    var _self = this;
                    this._traceCreated = false;
                    var traceHandle = this.traceOp;
                    this.ta.cloudTrace.destroyTrace(traceHandle).then(function () {
                        p.resolve();
                    }).catch(function (e) {
                        p.reject(e);
                    });
                } else {
                    p.resolve();
                }
                this.traceOp = undefined;
                return p.promise;
            },
            _preconfigureTrace: function()
            {
                var _self = this;
                var p = Q.defer();
                if (this.traceOp !== undefined) {
                    this.ta.cloudTrace.disableTraceTableSizeEvent(this.traceOp).then(function () {
                        return _self.ta.cloudTrace.removeListener("targetEvent", this.evtCallback);
                    }).then(function () {
                        return _self._releaseOperations();
                    }).then(function () {
                        return _self._destroyTrace();
                    }).then(function () {
                        p.resolve();
                    }).catch(function (e) {
                        p.reject(e);
                    });
                } else {
                    p.resolve();
                }
                return p.promise;
            },

            selectedDomainChanged: undefined,

            _selectedDomainChanged: function(newVal) {

                var _self = this;
                var domainIndex = _self.$.traceConfig.$.configDlg.dataHost.$.cpt2ConfigCommon.$.domainSelectDrop.$.selectorList.selectedIndex;

                _self.selectedDomain = newVal;

                if (_self.aetPropertyTrees[domainIndex] != undefined) {
                    _self.currentAggregator = _self.deviceInfo.name + '/' + _self.aetPropertyTrees[domainIndex][0].sub_properties[0].sub_properties[0].sub_properties[0].name;
                    _self.currentProbeArray = _self.aetPropertyTrees[domainIndex][0].sub_properties[0].sub_properties[0].sub_properties[0].sub_properties;
                    _self.currentAetPropertyTree = _self.aetPropertyTrees[domainIndex][0];
                    var probe = _self.deviceInfo.name;
                    var traceRoutes = _self.deviceInfo.trace_routes.filter(
                        route => (route.source === _self.currentAggregator) &&
                                    ((route.receiver !== "Pro Trace") || probe.includes("XDSPRO"))
                    );

                    _self.splice('traceRoutes',0,_self.traceRoutes.length, ...traceRoutes);
                }
            },

            configureTrace: undefined,
            _configureTrace: function()
            {
                var _self = this;
                this._traceStatus = "Starting trace configuration";
                this._traceConfigurationErrorMessage = "";
                this.$.progress.open();

                var tbr = undefined;
                if (this.traceRoute.hasOwnProperty('sink')) {
                    tbr = this.traceRoute.sink;
                }
                this._traceCreated = false;
                var traceCpu = this.currentAggregator;

                var receiverPropertyTree = this.receiverPropertyTree;
                var traceRoute = this.traceRoute;

                var domainIndex = _self.$.traceConfig.$.configDlg.dataHost.$.cpt2ConfigCommon.$.domainSelectDrop.$.selectorList.selectedIndex;

                if ((_self.syncCoreHalt.length > 0) &&
                    (_self.syncCoreHalt != "none")) {
                        _self.aetPropertyTrees[domainIndex][0].sub_properties[0].sub_properties[0].sub_properties[1].sub_properties[2].value = _self.syncCoreHalt;
                }
                else {
                    _self.aetPropertyTrees[domainIndex][0].sub_properties[0].sub_properties[0].sub_properties[1].sub_properties[2].value = "none";
                }

                _self.updateGraph = true;
                _self.traceConfigured = false;
                _self.bufferFull = false;

                this._preconfigureTrace().then(function () {
                    _self.ta.cloudTrace.addListener("traceTableSizeEvent", _self.traceTableSizeCallback);
                    return  _self.ta.cloudTrace.addListener("targetEvent", _self.evtCallback);
                }).then(function () {
                    var p = Q(true);
                    p = p.then(_self.$.tm.connectToCore(traceCpu));
                    if (tbr !== undefined) {
                        p = p.then(_self.$.tm.connectToCore.bind(_self.$.tm, tbr));
                    }
                    return p;
                }).then(function() {
                    var promises = [];
                    promises.push(_self.ta.cloudTrace.setPreRunTimeout(60000));
                    promises.push(_self.ta.cloudTrace.enableTargetEvents(traceCpu));
                    //promises.push(_self.ta.cloudTrace.enableTargetPreRunEvent(traceCpu));
                    return Q.all(promises);
                }).then(function () {
                    // create AET operations and Trace operation
                    var promises = [];
                    _self.aetPropertyTrees[domainIndex].forEach(() => promises.push(_self.ta.cloudTrace.createOperation(traceCpu,"AET")));
                    promises.push(_self.ta.cloudTrace.createOperation(traceCpu,"Trace"));
                    return Q.all(promises);
                }).then(function (ret) {
                    _self._traceStatus = "Configuring Trace Operation";
                    // Get the operation handles
                    _self.traceOp = ret.pop().handle;
                    _self.aetOps = ret.map(r => r.handle);
                    // Assign the property trees to the operations
                    var promises = [];
                    for (var i in _self.aetOps) {
                        console.log("AET properties sent: " + JSON.stringify(_self.currentAetPropertyTree, null, 2));
                        promises.push(_self.ta.cloudTrace.setProperties(_self.aetOps[i], [_self.currentAetPropertyTree]));
                    }
                    promises.push(_self.ta.cloudTrace.setProperties(_self.traceOp, [receiverPropertyTree]));
                    console.log("Receiver properties sent: " + JSON.stringify(receiverPropertyTree, null, 2));
                    return Q.all(promises);
                }).then(function () {
                    // Read back the property trees
                    var promises = [];
                    _self.aetOps.forEach(op => promises.push(_self.ta.cloudTrace.getProperties(op)));
                    promises.push(_self.ta.cloudTrace.getProperties(_self.traceOp));
                    return Q.all(promises);
                }).then(function (ret) {
                    console.log("AET properties received: ");
                    for (var i = 0; i < ret.length - 1; i++) {
                        console.log(JSON.stringify(ret[i], null, 2));
                    }
                    console.log("Receiver properties received: " + JSON.stringify(ret[ret.length-1], null, 2));
                    return _self.ta.cloudTrace.enableTraceTableSizeEvent(_self.traceOp);
                }).then(function () {
                    // Enable the trace and AET operations (cause them to execute)
                    var promises = [];
                    _self._traceStatus = "Enabling Trace Operation";
                    console.log(_self._traceStatus);
                    // AET must be enabled first so that the correct aggregator can be set in the trace route.
                    _self.aetOps.forEach(op => promises.push(_self.ta.cloudTrace.setEnableOperation(op, true)));
                    promises.push(_self.ta.cloudTrace.setEnableOperation(_self.traceOp, true));
                    return Q.all(promises);
                }).then(function () {
                    _self._traceStatus = "Creating Trace Decoder";
                    console.log(_self._traceStatus);
                    return _self.ta.cloudTrace.createTrace(_self.traceOp);
                }).then(function () {
                    _self._traceCreated = true;
                    _self._traceStatus = "Enabling trace capture...";
                    console.log(_self._traceStatus);
                    _self.ta.cloudTrace.readObjectFile(_self.traceOp, true, false);
                    return _self.ta.cloudTrace.startTraceCapture(_self.traceOp);
                //}).then(function () {
                    //return _self.ta.cloudTrace.disableTargetPreRunEvent(traceCpu);
                }).then(function () {
                    _self._traceStatus = "Trace capture enabled";
                    return _self.ta.cloudTrace.preRunComplete();
                }).then(function () {
                    _self.$.progress.close();
                    _self.traceConfigured = true;
                    if (_self.bufferFull) {
                        _self.haltTrace();
                    }
                }).catch(function (err){
                    console.log("Operation failed" + JSON.stringify(err));
                    _self.ta.cloudTrace.preRunComplete();
                    if (err.message !== undefined) {
                        _self._traceConfigurationErrorMessage = JSON.stringify(err.message);
                    } else {
                        _self._traceConfigurationErrorMessage = JSON.stringify(err);
                    }
                    _self._traceStatus = "Trace Generation Error - Operation Cancelled";
                    var promises = [];
                    /*
                    promises.push(_self.ta.cloudTrace.disableTargetEvents(traceCpu));
                    if (_self.traceOp !== undefined) {
                        promises.push(_self.ta.cloudTrace.disableTraceTableSizeEvent(_self.traceOp));
                    }*/
                    promises.push(_self.ta.cloudTrace.removeListener("traceTableSizeEvent", _self.traceTableSizeCallback));
                    promises.push(_self.ta.cloudTrace.removeListener("targetEvent", _self.evtCallback));
                    promises.push(_self._releaseOperations());
                    promises.push(_self._destroyTrace());
                    Q.all(promises).finally(function () {
                        _self.$.progress.close();
                        _self.$.errorDlg.open();
                    });
                });
            },
        });
    </script>
</dom-module>
