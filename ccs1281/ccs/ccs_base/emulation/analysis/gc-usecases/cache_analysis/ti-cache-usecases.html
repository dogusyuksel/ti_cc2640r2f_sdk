<!doctype html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <link rel="icon" type="image/png" href="images/ti_gui_icon.png">
    <script src="../components/ti-core-assets/scripts/gcDesktop.js"></script>
    <link rel="import" href="../components/ti-core-databind/ti-core-databind.html">
    <link rel="stylesheet" href="overriden.css">
    <link rel="import" href="../components/ti-widget-common/ti-widget-container.html">
    <link rel="import" href="../components/ti-widget-common/ti-widget-tabcontainer.html">
    <link rel="import" href="../components/ti-widget-common/ti-widget-tab.html">
    <link rel="import" href="../components/ti-widget-common/ti-widget-button.html">
    <link rel="import" href="../components/ti-widget-common/ti-widget-label.html">
    <link rel="import" href="../components/ti-widget-common/ti-widget-input.html">
    <link rel="import" href="../components/ti-widget-helpbutton/ti-widget-helpbutton.html">
    <link rel="import" href="../components/ti-widget-common/ti-widget-radio-group.html">
    <link rel="import" href="../components/ti-widget-common/ti-widget-radio-button.html">
    <link rel="import" href="../components-dbgtrc/ti-trace-model/ti-trace-model.html">
    <link rel="import" href="../components/polymer/polymer.html">
    }

</head>

<body class="lightgray-theme">
<dom-module name='ti-cache-usecases'>
    <template>
        <style>
            #ti_widget_container1 {
                text-align: left;
                text-decoration: none;
                font-weight: normal;
                font-style: normal;
                font-size: 12px;
                height: 100%;
                width: 100%;
                display: flex;
                overflow: auto;

            }

            .tab_container {
                text-align: left;
                text-decoration: none;
                font-weight: normal;
                font-style: normal;
                font-size: inherit;
                overflow: initial;
                margin: 20px;
                display: flex;
                height: 35px;
            }

            #ti_widget_tabcontainer {
                flex-grow: 1;
                width: 75%;
            }

            #ti_widget_tabcontainer_c7 {
                flex-grow: 1;
                width: 75%;
            }


            #top-container {
                height: 100%;
                width: 100%;
                display: flex;
                font-size: 12px;
                flex-direction: column;
                overflow: auto;
                min-width: 500px;
                min-height: 600px;
            }

            #toolbar {
                background-color: white;
                display: flex;
            }

            #rstOnStart_button, #syncRun_button {
                padding-left: 0px;
                padding-right: 0px;
                padding-bottom: 3px;
                padding-top: 3px;
                min-width: 40px;
            }

            #ti_widget_helpbutton {
                width: 40px;
                height: 21px;
                margin: 7px;
                position: relative;
                display: flex;
            }

            ti-widget-button {
                font-size: 12px;
                font-weight: bold;
                margin: 0px;
            }

            table {
                font-size: 12px;
            }

            .radio-group {
                height: 21px;
                margin: 11px;
                position: relative;
                display: flex;
            }

            #th, #th1, #td, #td1 {
                padding: 15px;
                width: 50%;
                border-bottom: 1px solid #eeeeee;
            }


            #helpicon {
                fill: black;
            }

            .filldiv {
                flex-grow: 1;
            }

            #container {
                height: 100%;
                width: 100%;
                display: flex;
                flex-direction: row;
                overflow: auto;
            }

            #leftThing {
                background-color: red;
            }

            #content {
                display: block;
            }

            :root {
                --paper-tab-content: {
                    white-space: normal;
                };
                --primary-color: #115566;
            }
        </style>

        <ti-core-stylesheets id="ti_core_stylesheets" class="_TI_"></ti-core-stylesheets>
        <ti-trace-model id="tm" device-id="{{devId_raw}}" trace-agent="{{ta}}" active-core="{{activeCore}}"
                        device-info="{{deviceInfo}}"></ti-trace-model>
        <ti-widget-container id="top-container">
            <paper-toolbar class="_TI_" id="toolbar" horizontal="" layout="">
                <div class="filldiv"></div>
                <paper-button id="rstOnStart_button" toggles="" on-click="_rstOnStartHdlr" title="{{rstbtn_title}}">
                    <iron-icon icon="restore"></iron-icon>
                </paper-button>
                <paper-button id="syncRun_button" toggles="" on-click="_syncRunHdlr" title="{{syncrun_title}}">
                    <iron-icon icon="link"></iron-icon>
                </paper-button>
            </paper-toolbar>
            <ti-widget-label id="uc_warning" label="{{uc_warning}}" text-align="left" font-size="large"
                             font-style="bold" font-weight="normal" text-decoration="none" wrap="" visible=""
                             class="_TI_"></ti-widget-label>
            <ti-widget-container visible="" id="ti_widget_container1" class="_TI_" horizontal="" layout="">
                <ti-widget-tabcontainer selected-index="{{uc_index}}" selected-label="{{uc_val}}"
                                        id="ti_widget_tabcontainer" layout="" class="_TI_" one="" flex="">
                    <ti-widget-tab name="{{uc1}}" icon-style="width:25px;padding-right:5px;" font-size="inherit"
                                   font-style="normal" font-weight="normal" text-align="left" text-decoration="none"
                                   visible="" id="tab1" class="_TI_ iron-selected" title="">
                        <ti-widget-container font-size="inherit" font-style="normal" font-weight="normal"
                                             text-align="left" text-decoration="none" visible="" class="tab_container"
                                             title="" horizontal="" layout="">
                            <div class="filldiv" one="" flex=""></div>
                            <ti-widget-helpbutton id="ti_widget_helpbutton" title-text="{{uc_val}}" icon-color="#115566"
                                                  icon-active-color="darkgray" icon-size-in-px="23"
                                                  tile-position="below_left" tile-width-in-px="300"
                                                  tile-height-in-px="300"
                                                  markdown-text="{{md_txt}}"></ti-widget-helpbutton>
                            <ti-widget-button label="Start" button-type="default" raised="" on-click="_onStart_uc1_hdlr"
                                              visible="" bindable-trigger="7" id="start_button_uc1" animated="" title=""
                                              elevation="1" class="x-scope ti-widget-button-0 _TI_"></ti-widget-button>
                        </ti-widget-container>
                        <table class="_TI_" id="cacheTable1">
                            <colgroup class="_TI_" width="400"></colgroup>
                            <tbody class="_TI_">
                            <tr class="_TI_">
                                <th class="_TI_" id="th">
                                    <ti-widget-label id="uc1_head0" label="{{uc1_th0}}" text-align="left"
                                                     font-weight="bold" font-style="normal" text-decoration="none"
                                                     wrap="" visible=""></ti-widget-label>
                                </th>
                                <th class="_TI_" , id="th1">
                                    <ti-widget-label id="uc1_head1" label="{{uc1_th1}}" text-align="left"
                                                     font-weight="bold" font-style="normal" text-decoration="none"
                                                     wrap="" visible=""></ti-widget-label>
                                </th>
                            </tr>
                            <template is="dom-repeat" items="{{uc1_tableItems}}" as="item1">
                                <tr>
                                    <td class="_TI_" id="td">
                                        <ti-widget-label label="{{item1.col1}}" text-align="left" font-size="inherit"
                                                         font-style="normal" font-weight="normal" text-decoration="none"
                                                         wrap="" visible class="_TI_"></ti-widget-label>
                                    </td>
                                    <td class="_TI_" id="td1">
                                        <ti-widget-label label="{{item1.col2}}" text-align="left" font-size="inherit"
                                                         font-style="normal" font-weight="normal" text-decoration="none"
                                                         wrap="" visible="" class="_TI_"></ti-widget-label>
                                    </td>
                                </tr>
                            </template>

                            </tbody>
                        </table>
                    </ti-widget-tab>
                    <ti-widget-tab name="{{uc2}}" icon-style="width:25px;padding-right:5px;" font-size="inherit"
                                   font-style="normal" font-weight="normal" text-align="left" text-decoration="none"
                                   id="tab2" class="_TI_ " title="">
                        <ti-widget-container font-size="inherit" font-style="normal" font-weight="normal"
                                             text-align="left" text-decoration="none" class="tab_container" title=""
                                             horizontal="" layout="">
                            <div class="filldiv" one="" flex=""></div>
                            <ti-widget-helpbutton id="ti_widget_helpbutton" title-text="{{uc_val}}" icon-color="#115566"
                                                  icon-active-color="darkgray" icon-size-in-px="23"
                                                  tile-position="below_left" tile-width-in-px="300"
                                                  tile-height-in-px="300"
                                                  markdown-text="{{md_txt}}"></ti-widget-helpbutton>
                            <ti-widget-button label="Start" button-type="default" raised="" on-click="_onStart_uc2_hdlr"
                                              visible="" bindable-trigger="7" id="start_button_uc2" animated="" title=""
                                              elevation="1" class="x-scope ti-widget-button-0 _TI_"></ti-widget-button>
                        </ti-widget-container>
                        <table class="_TI_" id="cacheTable2">
                            <colgroup class="_TI_" width="400"></colgroup>
                            <tbody class="_TI_">
                            <tr class="_TI_">
                                <th class="_TI_" id="th">
                                    <ti-widget-label id="uc2_head0" label="{{uc2_th0}}" text-align="left"
                                                     font-weight="bold" font-style="normal" text-decoration="none"
                                                     wrap="" visible=""></ti-widget-label>
                                </th>
                                <th class="_TI_" id="th1">
                                    <ti-widget-label id="uc2_head0" label="{{uc2_th1}}" text-align="left"
                                                     font-weight="bold" font-style="normal" text-decoration="none"
                                                     wrap="" visible=""></ti-widget-label>
                                </th>
                            </tr>
                            <template is="dom-repeat" items="{{uc2_tableItems}}" as="item2">
                                <tr>
                                    <td class="_TI_" id="td">
                                        <ti-widget-label label="{{item2.col1}}" text-align="left" font-size="inherit"
                                                         font-style="normal" font-weight="normal" text-decoration="none"
                                                         wrap="" visible="" class="_TI_"></ti-widget-label>
                                    </td>
                                    <td class="_TI_" id="td1">
                                        <ti-widget-label label="{{item2.col2}}" text-align="left" font-size="inherit"
                                                         font-style="normal" font-weight="normal" text-decoration="none"
                                                         wrap="" visible="" class="_TI_"></ti-widget-label>
                                    </td>
                                </tr>
                            </template>

                            </tbody>
                        </table>
                    </ti-widget-tab>

                    <ti-widget-tab name="{{uc3}}" icon-style="width:25px;padding-right:5px;" font-size="inherit"
                                   font-style="normal" font-weight="normal" text-align="left" text-decoration="none"
                                   id="tab3" class="_TI_ " title="">
                        <ti-widget-container font-size="inherit" font-style="normal" font-weight="normal"
                                             text-align="left" text-decoration="none" class="tab_container" title=""
                                             horizontal="" layout="">
                            <div class="filldiv" one="" flex=""></div>
                            <ti-widget-helpbutton id="ti_widget_helpbutton" title-text="{{uc_val}}" icon-color="#115566"
                                                  icon-active-color="darkgray" icon-size-in-px="23"
                                                  tile-position="below_left" tile-width-in-px="300"
                                                  tile-height-in-px="300"
                                                  markdown-text="{{md_txt}}"></ti-widget-helpbutton>
                            <ti-widget-button label="Start" button-type="default" raised="" on-click="_onStart_uc3_hdlr"
                                              visible="" bindable-trigger="7" id="start_button_uc3" animated="" title=""
                                              elevation="1" class="x-scope ti-widget-button-0 _TI_"></ti-widget-button>
                        </ti-widget-container>
                        <table class="_TI_" id="cacheTable3">
                            <colgroup class="_TI_" width="400"></colgroup>
                            <tbody class="_TI_">
                            <tr class="_TI_">
                                <th class="_TI_" id="th">
                                    <ti-widget-label id="uc3_head0" label="{{uc3_th0}}" text-align="left"
                                                     font-weight="bold" font-style="normal" text-decoration="none"
                                                     wrap="" visible=""></ti-widget-label>
                                </th>
                                <th class="_TI_" id="th1">
                                    <ti-widget-label id="uc3_head0" label="{{uc3_th1}}" text-align="left"
                                                     font-weight="bold" font-style="normal" text-decoration="none"
                                                     wrap="" visible=""></ti-widget-label>
                                </th>
                            </tr>
                            <template is="dom-repeat" items="{{uc3_tableItems}}" as="item3">
                                <tr>
                                    <td class="_TI_" id="td">
                                        <ti-widget-label label="{{item3.col1}}" text-align="left" font-size="inherit"
                                                         font-style="normal" font-weight="normal" text-decoration="none"
                                                         wrap="" visible="" class="_TI_"></ti-widget-label>
                                    </td>
                                    <td class="_TI_" id="td1">
                                        <ti-widget-label label="{{item3.col2}}" text-align="left" font-size="inherit"
                                                         font-style="normal" font-weight="normal" text-decoration="none"
                                                         wrap="" visible="" class="_TI_"></ti-widget-label>
                                    </td>
                                </tr>
                            </template>

                            </tbody>
                        </table>
                    </ti-widget-tab>
                    <ti-widget-tab name="{{uc4}}" icon-style="width:25px;padding-right:5px;" font-size="inherit"
                                   font-style="normal" font-weight="normal" text-align="left" text-decoration="none"
                                   id="tab4" class="_TI_ " title="">
                        <ti-widget-container font-size="inherit" font-style="normal" font-weight="normal"
                                             text-align="left" text-decoration="none" class="tab_container" title=""
                                             horizontal="" layout="">
                            <div class="filldiv" one="" flex=""></div>
                            <ti-widget-helpbutton id="ti_widget_helpbutton" title-text="{{uc_val}}" icon-color="#115566"
                                                  icon-active-color="darkgray" icon-size-in-px="23"
                                                  tile-position="below_left" tile-width-in-px="300"
                                                  tile-height-in-px="300"
                                                  markdown-text="{{md_txt}}"></ti-widget-helpbutton>
                            <ti-widget-button label="Start" button-type="default" raised="" on-click="_onStart_uc4_hdlr"
                                              visible="" bindable-trigger="7" id="start_button_uc4" animated="" title=""
                                              elevation="1" class="x-scope ti-widget-button-0 _TI_"></ti-widget-button>
                        </ti-widget-container>
                        <table class="_TI_" id="cacheTable4">
                            <colgroup class="_TI_" width="400"></colgroup>
                            <tbody class="_TI_">
                            <tr class="_TI_">
                                <th class="_TI_" id="th">
                                    <ti-widget-label id="uc4_head0" label="{{uc4_th0}}" text-align="left"
                                                     font-weight="bold" font-style="normal" text-decoration="none"
                                                     wrap="" visible=""></ti-widget-label>
                                </th>
                                <th class="_TI_" id="th1">
                                    <ti-widget-label id="uc4_head0" label="{{uc4_th1}}" text-align="left"
                                                     font-weight="bold" font-style="normal" text-decoration="none"
                                                     wrap="" visible=""></ti-widget-label>
                                </th>
                            </tr>
                            <template is="dom-repeat" items="{{uc4_tableItems}}" as="item4">
                                <tr>
                                    <td class="_TI_" id="td">
                                        <ti-widget-label label="{{item4.col1}}" text-align="left" font-size="inherit"
                                                         font-style="normal" font-weight="normal" text-decoration="none"
                                                         wrap="" visible="" class="_TI_"></ti-widget-label>
                                    </td>
                                    <td class="_TI_" id="td1">
                                        <ti-widget-label label="{{item4.col2}}" text-align="left" font-size="inherit"
                                                         font-style="normal" font-weight="normal" text-decoration="none"
                                                         wrap="" visible="" class="_TI_"></ti-widget-label>
                                    </td>
                                </tr>
                            </template>
                            </tbody>
                        </table>
                    </ti-widget-tab>
                </ti-widget-tabcontainer>
                <ti-widget-tabcontainer selected-index="{{uc_index_c7}}" selected-label="{{uc_val_c7}}"
                                        id="ti_widget_tabcontainer_c7" layout="" class="_TI_" one="" flex="">
                    <ti-widget-tab name="{{uc1}}" icon-style="width:25px;padding-right:5px;" font-size="inherit"
                                   font-style="normal" font-weight="normal" text-align="left" text-decoration="none"
                                   visible="" id="tab1_c7" class="_TI_ iron-selected" title="">
                        <ti-widget-container font-size="inherit" font-style="normal" font-weight="normal"
                                             text-align="left" text-decoration="none" visible="" class="tab_container"
                                             title="" horizontal="" layout="">
                            <ti-widget-radio-group id="c7x_l1" class="radio-group" selected-text="{{c7x_l1sel_flag}}"
                                                   allow-empty-selection="false">
                                <ti-widget-radio-button id="c7x_l1p" label="L1P" value="L1P">
                                </ti-widget-radio-button>
                                <ti-widget-radio-button id="c7x_l1d" label="L1D" value="L1D">
                                </ti-widget-radio-button>
                            </ti-widget-radio-group>
                            <div class="filldiv" one="" flex=""></div>
                            <ti-widget-helpbutton id="ti_widget_helpbutton" title-text="{{uc_val_c7}}"
                                                  icon-color="#115566" icon-active-color="darkgray" icon-size-in-px="23"
                                                  tile-position="below_left" tile-width-in-px="300"
                                                  tile-height-in-px="300"
                                                  markdown-text="{{md_txt_c7}}"></ti-widget-helpbutton>
                            <ti-widget-button label="Start" button-type="default" raised=""
                                              on-click="_onStart_uc1_hdlr_c7" visible="" bindable-trigger="7"
                                              id="start_button_uc1_c7" animated="" title="" elevation="1"
                                              class="x-scope ti-widget-button-0 _TI_"></ti-widget-button>
                        </ti-widget-container>
                        <table class="_TI_" id="cacheTable1_c7">
                            <colgroup class="_TI_" width="400"></colgroup>
                            <tbody class="_TI_">
                            <tr class="_TI_">
                                <th class="_TI_" id="th">
                                    <ti-widget-label id="uc1_head0_c7" label="{{uc1_th0}}" text-align="left"
                                                     font-weight="bold" font-style="normal" text-decoration="none"
                                                     wrap="" visible=""></ti-widget-label>
                                </th>
                                <th class="_TI_" , id="th1">
                                    <ti-widget-label id="uc1_head1_c7" label="{{uc1_th1}}" text-align="left"
                                                     font-weight="bold" font-style="normal" text-decoration="none"
                                                     wrap="" visible="" class="_TI_"></ti-widget-label>
                                </th>
                            </tr>
                            <template is="dom-repeat" items="{{uc1_tableItems}}" as="item1">
                                <tr>
                                    <td class="_TI_" id="td">
                                        <ti-widget-label label="{{item1.col1}}" text-align="left" font-size="inherit"
                                                         font-style="normal" font-weight="normal" text-decoration="none"
                                                         wrap="" visible class="_TI_"></ti-widget-label>
                                    </td>
                                    <td class="_TI_" id="td1">
                                        <ti-widget-label label="{{item1.col2}}" text-align="left" font-size="inherit"
                                                         font-style="normal" font-weight="normal" text-decoration="none"
                                                         wrap="" visible="" class="_TI_"></ti-widget-label>
                                    </td>
                                </tr>
                            </template>

                            </tbody>
                        </table>
                    </ti-widget-tab>
                    <ti-widget-tab name="{{uc3}}" icon-style="width:25px;padding-right:5px;" font-size="inherit"
                                   font-style="normal" font-weight="normal" text-align="left" text-decoration="none"
                                   id="tab3_c7" class="_TI_ " title="">
                        <ti-widget-container font-size="inherit" font-style="normal" font-weight="normal"
                                             text-align="left" text-decoration="none" class="tab_container" title=""
                                             horizontal="" layout="">
                            <div class="filldiv" one="" flex=""></div>
                            <ti-widget-helpbutton id="ti_widget_helpbutton" title-text="{{uc_val_c7}}"
                                                  icon-color="#115566" icon-active-color="darkgray" icon-size-in-px="23"
                                                  tile-position="below_left" tile-width-in-px="300"
                                                  tile-height-in-px="300"
                                                  markdown-text="{{md_txt_c7}}"></ti-widget-helpbutton>
                            <ti-widget-button label="Start" button-type="default" raised=""
                                              on-click="_onStart_uc3_hdlr_c7" visible="" bindable-trigger="7"
                                              id="start_button_uc3_c7" animated="" title="" elevation="1"
                                              class="x-scope ti-widget-button-0 _TI_"></ti-widget-button>
                        </ti-widget-container>
                        <table class="_TI_" id="cacheTable3_c7">
                            <colgroup class="_TI_" width="400"></colgroup>
                            <tbody class="_TI_">
                            <tr class="_TI_">
                                <th class="_TI_" id="th">
                                    <ti-widget-label id="uc3_head0_c7" label="{{uc3_th0_c7}}" text-align="left"
                                                     font-weight="bold" font-style="normal" text-decoration="none"
                                                     wrap="" visible=""></ti-widget-label>
                                </th>
                                <th class="_TI_" id="th1">
                                    <ti-widget-label id="uc3_head0_c7" label="{{uc3_th1_c7}}" text-align="left"
                                                     font-weight="bold" font-style="normal" text-decoration="none"
                                                     wrap="" visible="" class="_TI_"></ti-widget-label>
                                </th>
                            </tr>
                            <template is="dom-repeat" items="{{uc3_tableItems}}" as="item3">
                                <tr>
                                    <td class="_TI_" id="td">
                                        <ti-widget-label label="{{item3.col1}}" text-align="left" font-size="inherit"
                                                         font-style="normal" font-weight="normal" text-decoration="none"
                                                         wrap="" visible="" class="_TI_"></ti-widget-label>
                                    </td>
                                    <td class="_TI_" id="td1">
                                        <ti-widget-label label="{{item3.col2}}" text-align="left" font-size="inherit"
                                                         font-style="normal" font-weight="normal" text-decoration="none"
                                                         wrap="" visible="" class="_TI_"></ti-widget-label>
                                    </td>
                                </tr>
                            </template>

                            </tbody>
                        </table>
                    </ti-widget-tab>
                </ti-widget-tabcontainer>
            </ti-widget-container>
        </ti-widget-container>
    </template>

    <script>
        /* global Promise:false */
        Polymer({
            is: 'ti-cache-usecases',
            properties: {

                ctset2_prop_default: {
                    type: Array,
                    value: (function () {
                        return [
                            {
                                name: "Type",
                                sub_properties: [
                                    {name: "SRAM Bank", type: "String", value: "SRAM Bank 0"},
                                    {name: "Event to Count", type: "String", value: "SRAM External Access"},
                                    {name: "Event Detection Type", type: "String", value: "Edge"},
                                    {name: "Counter Size", type: "String", value: "32 Bit"},
                                    {name: "Current Count", type: "Number", value: 0},
                                    {name: "Overflow", type: "String", value: "no overflow"},
                                ]
                            }
                        ];
                    }),
                    notify: true,
                    reflectToAttribute: true,
                },

                ta: {
                    notify: true,
                    type: Object,
                    reflectToAttribute: true
                },
                devId_raw: {
                    notify: true,
                    type: Number,
                    reflectToAttribute: true,
                    value: undefined,
                    observer: '_devIdChanged'
                },
                activeCore: {
                    notify: true,
                    type: String,
                    reflectToAttribute: true,
                    value: undefined,
                    observer: '_activeCoreChanged'
                },
                corepacSelected: {
                    notify: true,
                    type: Number,
                    reflectToAttribute: true,
                    value: undefined,
                    observer: '_corepacSelChanged'
                },
                deviceInfo: {
                    notify: true,
                    type: String,
                    reflectToAttribute: true,
                    value: undefined,
                    observer: '_devInfoChanged'
                },

                md_txt: {
                    type: String,
                    value: ""
                },

                md_txt_c7: {
                    type: String,
                    value: ""
                },

                rstbtn_title: {
                    type: String,
                    value: ""
                },

                syncrun_title: {
                    type: String,
                    value: ""
                },

                uc_index: {
                    type: Number,
                    value: 0,
                    observer: '_ucIndexChanged'
                },

                uc_index_c7: {
                    type: Number,
                    value: 0,
                    observer: '_ucIndexChanged_c7'
                },

                uc_val: {
                    type: String,
                    value: "Cache Hit Percentage"
                },

                uc_val_c7: {
                    type: String,
                    value: "Cache Hit Percentage"
                },

                uc_txt: {
                    type: String,
                    value: ""
                },

                uc_tab: {
                    type: String,
                    value: ""
                },

                uc1: {
                    type: String,
                    value: ""
                },

                uc1_th0: {
                    type: String,
                    value: ""
                },

                uc1_th1: {
                    type: String,
                    value: ""
                },

                uc1_tableItems: {
                    type: Array,
                    value: []
                },

                uc2: {
                    type: String,
                    value: ""
                },

                uc2_th0: {
                    type: String,
                    value: ""
                },

                uc2_th1: {
                    type: String,
                    value: ""
                },

                uc2_tableItems: {
                    type: Array,
                    value: []
                },

                uc3: {
                    type: String,
                    value: ""
                },

                uc3_th0: {
                    type: String,
                    value: ""
                },

                uc3_th1: {
                    type: String,
                    value: ""
                },

                uc3_th0_c7: {
                    type: String,
                    value: ""
                },

                uc3_th1_c7: {
                    type: String,
                    value: ""
                },

                uc3_tableItems: {
                    type: Array,
                    value: []
                },

                uc4: {
                    type: String,
                    value: ""
                },

                uc4_th0: {
                    type: String,
                    value: ""
                },

                uc4_th1: {
                    type: String,
                    value: ""
                },

                uc4_tableItems: {
                    type: Array,
                    value: []
                },

                uc_warning: {
                    type: String,
                    value: ""
                },

                c7x_l1sel_flag: {
                    type: String,
                    value: "L1P",
                    notify: true,
                    reflectToAttribute: true,
                    observer: '_c7xl1selChanged'
                },

            },

            c7x_l1sel: "L1P",
            uc1data_c7l1p: ["", "", ""],
            uc1data_c7l1d: ["", "", ""],
            tm: null,
            rstOnStart: [],
            syncRun: [],
            uc_helpInfo: [],
            uc_helpInfo_c7: [],
            corepacInfo: [],
            mycpuNames: [],
            cpuFullNames: [],
            mycpuNames_uc1: [],
            cpuFullNames_uc1: [],
            core_connected: [],
            msmc_ctset2_connected: false,
            c7x_ctset2_connected: false,
            start_alert: [],

            armPmuAetHndl: [],
            ctset2AetHndl: [],
            ctset2AetHndl_c7: [],
            armPmu_alert: "",
            ctset2_alert: "",
            ctset2Cnt: [],
            ctset2Ovfl: [],
            ctset2_alert_c7: "",
            ctset2Cnt_c7: [],
            ctset2Ovfl_c7: [],
            armPmuCnt: [],
            num_ctset2_cnt: 8,
            num_ctset2_cnt_c7: 8,
            jobInProg: [],
            uc1InProg: [],
            uc2InProg: [],
            uc3InProg: [],
            uc4InProg: [],
            msmc_ctset2_inuse: false,
            msmc_ctset2_present: true,

            /* GUI component status */
            uc1_startStatus: [], // usecase1 START button disable status: true -- disabled, false -- enabled
            uc2_startStatus: [], // usecase2 START button disable status: true -- disabled, false -- enabled
            uc3_startStatus: [], // usecase3 START button disable status: true -- disabled, false -- enabled
            uc4_startStatus: [], // usecase4 START button disable status: true -- disabled, false -- enabled
            uc1_tdata: [], //usecase1 table data
            uc2_tdata: [], //usecase2 table data
            uc3_tdata: [], //usecase3 table data
            uc4_tdata: [], //usecase4 table data

            cpuExeStatus: [],
            emulator: "",
            trace: undefined,
            devId: 0x0,
            //Below are constants
            deviceID1: 0x0bb5a02f,
            deviceID2: 0xffffffff,
            deviceID3: 0x0bb6402f,
            deviceID4: 0x0bb6d02f,
            deviceID5: 0x0bb3802f,  // AM64x
            deviceID6: 0x0bb7e02f,  // AM62x
            deviceID7: 0x0bb7502f,  // J7AEP
            deviceID_mask: 0x0fffffff,
            _rstbtn_title_enable: "Click to enable Reset on Start. Counter values will automatically reset when job is started.",
            _rstbtn_title_disable: "Click to disable Reset On Start. Counter values will continue from the last run when job is started.",
            _syncRun_title_enable: "Click to enable the automatic start of job on target run and automatic stop of job on target halt.",
            _syncRun_title_disable: "Click to disable the automatic start of job on target run and automatic stop of job on target halt.",
            tgtEvtCallback: undefined,

            _devIdChanged: function () {
                var _self = this;

                // Apply device ID mask to comprehend the device ID changes due to multiple PGs for the same device (Maxwell etc.)
                _self.devId = _self.devId_raw & _self.deviceID_mask;

                _self.init_devinfo();
                //_self.init();
                _self.init_var(); //this is only called when device ID has changed

                _self.check_corepac_sel();

            },

            _activeCoreChanged: function () {
                var _self = this;
                //_self.init();
                _self.check_corepac_sel();

            },

            check_corepac_sel: function () {
                var _self = this;
                //_self.init();

                /* Initialize the corepacSelected value based on highlighted core */
                if ((_self.devId == _self.deviceID1) || (_self.devId == _self.deviceID2)) {
                    if (_self.activeCore === "CortexA53_0_0" || _self.activeCore === "CortexA53_0_1") {
                        _self.corepacSelected = 0;
                    } else if (_self.activeCore === "CortexA53_1_0" || _self.activeCore === "CortexA53_1_1") {
                        _self.corepacSelected = 1;
                    } else {
                        _self.corepacSelected = 9999; //this number represented unsupported cores
                    }
                } else if ((_self.devId == _self.deviceID3) // J7ES
                    || (_self.devId == _self.deviceID4) // J7VCL
                    || (_self.devId == _self.deviceID7)) { // J7AEP
                    if (_self.activeCore === "CortexA72_0_0" || _self.activeCore === "CortexA72_0_1") {
                        _self.corepacSelected = 0;
                    } else if (_self.activeCore === "C71X_0" || _self.activeCore === "C71X_1") {
                        _self.corepacSelected = 1;
                    } else {
                        _self.corepacSelected = 9999; //this number represented unsupported cores
                    }
                } else if (_self.devId == _self.deviceID5 || _self.devId == _self.deviceID6) { // AM64, AM62
                    if (_self.activeCore === "CortexA53_0" || _self.activeCore === "CortexA53_1" || _self.activeCore === "CortexA53_2" || _self.activeCore === "CortexA53_3") {
                        _self.corepacSelected = 0;
                    } else {
                        _self.corepacSelected = 9999; //this number represented unsupported cores
                    }
                }
            },

            _c7xl1selChanged: function () {
                var _self = this;

                // c7x_l1sel_flag reflect the user selection via radio button
                // c7x_l1sel is used by the use case job processing
                // We will ony update c7x_l1sel with user selection value when Usecase 1 is NOT in progress
                if (!_self.uc1InProg[_self.corepacSelected]) {
                    _self.c7x_l1sel = _self.c7x_l1sel_flag;

                    // Initialize the table display
                    if (_self.c7x_l1sel === "L1P")
                        _self.table_init_uc1(_self.uc1data_c7l1p);
                    else
                        _self.table_init_uc1(_self.uc1data_c7l1d);

                }
            },

            _corepacSelChanged: function () {
                var _self = this;

                // Initialize the usecase list
                _self.init_uclist();
                // Initialize each use case
                _self.init_uc();

                if (_self.corepacSelected != 9999) {
                    // GUI updates based on selected core context
                    // START/STOP button update
                    _self.update_start_stop_btn('#start_button_uc1', _self.uc1_startStatus[_self.corepacSelected]);
                    _self.update_start_stop_btn('#start_button_uc2', _self.uc2_startStatus[_self.corepacSelected]);
                    _self.update_start_stop_btn('#start_button_uc3', _self.uc3_startStatus[_self.corepacSelected]);
                    _self.update_start_stop_btn('#start_button_uc4', _self.uc4_startStatus[_self.corepacSelected]);

                    // Data table update
                    _self.table_init_uc1(_self.uc1_tdata[_self.corepacSelected]);
                    _self.table_init_uc2(_self.uc2_tdata[_self.corepacSelected]);
                    _self.table_init_uc3(_self.uc3_tdata[_self.corepacSelected]);
                    _self.table_init_uc4(_self.uc4_tdata[_self.corepacSelected]);

                    // Sync Run button update
                    _self.syncRunBtn_update();

                    // rstOnStart button update
                    _self.rstBtn_update();


                }

            },


            _ucIndexChanged: function () {

                var _self = this;

                _self.md_txt = _self.uc_helpInfo[_self.uc_index];

            },

            _ucIndexChanged_c7: function () {

                var _self = this;

                _self.md_txt_c7 = _self.uc_helpInfo_c7[_self.uc_index_c7];

            },

            _devInfoChanged: function () {
                var _self = this;
                _self.emulator = _self.deviceInfo.name;
                var i, j;

                _self.cpuFullNames_uc1 = JSON.parse(JSON.stringify(_self.mycpuNames_uc1));
                _self.cpuFullNames = JSON.parse(JSON.stringify(_self.mycpuNames));

                /* Initialize trace model element */
                _self.tm = document.querySelector('#tm');
                if (_self.tm == null) {
                    console.log("Trace model init failed!");
                } else {

                    for (i = 0; i < _self.corepacInfo.length; i++) {
                        /* Construct the full cpu names for uc1 */
                        for (j = 0; j < _self.mycpuNames_uc1[i].length; j++) {
                            _self.cpuFullNames_uc1[i][j] = _self.emulator + "/" + _self.mycpuNames_uc1[i][j];
                        }
                        /* Construct the full cpu names for uc2,3,4 */
                        for (j = 0; j < _self.mycpuNames[i].length; j++) {
                            _self.cpuFullNames[i][j] = _self.emulator + "/" + _self.mycpuNames[i][j];
                        }
                    }

                }
                //_self.init();
            },

            ready: function () {
                var _self = this;

                _self.md_txt = "Please select a usecase first!";
                _self.md_txt_c7 = "Please select a usecase first!";
                _self.rstbtn_title = _self._rstbtn_title_disable;
                _self.syncrun_title = _self._syncRun_title_enable;

                this.tgtEvtCallback = this._tgtEvtCallback.bind(this);

            },


            /////////////////////////////////////////////////////////
            // update the START/STOP button
            // When start_val = false, show button as "Start"
            // When start_val = true, show button as "Stop"
            /////////////////////////////////////////////////////////
            update_start_stop_btn: function (startBtn_id, start_val) {
                var startbtn = document.querySelector(startBtn_id);

                if (startbtn != null) {
                    if (start_val) {
                        startbtn.label = "Stop";
                        startbtn.style = "background: #115566; color: white";
                    } else {
                        startbtn.label = "Start";
                        startbtn.style = "background: white; color: #115566";
                    }
                }
            },

            /////////////////////////////////////////////////////////
            // initialize the internal variables
            /////////////////////////////////////////////////////////
            init_var: function () {
                var _self = this;
                var i = 0;

                _self.jobInProg = [];
                _self.uc1InProg = [];
                _self.uc2InProg = [];
                _self.uc3InProg = [];
                _self.uc4InProg = [];


                for (i = 0; i < _self.corepacInfo.length; i++) {
                    _self.jobInProg[i] = false;
                    _self.uc1InProg[i] = false;
                    _self.uc2InProg[i] = false;
                    _self.uc3InProg[i] = false;
                    _self.uc4InProg[i] = false;
                    _self.syncRun[i] = false;
                    _self.rstOnStart[i] = true;
                    _self.start_alert[i] = "";

                    _self.uc1_tdata[i] = ["", "", "", "", "", ""];
                    _self.uc2_tdata[i] = ["", ""];
                    _self.uc3_tdata[i] = ["", "", "", ""];
                    _self.uc4_tdata[i] = ["", ""];

                    if ((_self.corepacSelected != 9999) && (_self.corepacSelected != undefined) && (_self.corepacInfo[_self.corepacSelected].type == "c7x"))
                        _self.uc3_tdata[i] = ["", "", "", "", ""];

                    _self.uc1_startStatus[i] = false; // START button by default is enabled
                    _self.uc2_startStatus[i] = false; // START button by default is enabled
                    _self.uc3_startStatus[i] = false; // START button by default is enabled
                    _self.uc4_startStatus[i] = false; // START button by default is enabled

                    _self.core_connected[i] = [];
                    _self.cpuExeStatus[i] = [];
                    // Assume all cores are not connected at start and set initial exe state to halted
                    for (var j = 0; j < _self.corepacInfo[i].num_cores; j++) {
                        _self.core_connected[i][j] = false;
                        _self.cpuExeStatus[i][j] = "halted";
                    }

                }


                //GUI update for START/STOP button
                _self.update_start_stop_btn('#start_button_uc1', false);
                _self.update_start_stop_btn('#start_button_uc2', false);
                _self.update_start_stop_btn('#start_button_uc3', false);
                _self.update_start_stop_btn('#start_button_uc4', false);


            },


            /////////////////////////////////////////////////////////
            // initialize the device info
            /////////////////////////////////////////////////////////
            init_devinfo: function () {
                var _self = this;

                _self.msmc_ctset2_present = true;

                /* Initialize the corepac info */
                if (_self.devId == _self.deviceID1) {

                    console.log("corepacInfo is being initialized for the device");

                    /* TODO, need to revisit if we can get this from ctools K3 database */
                    _self.corepacInfo =
                        [   /* corepac type, number of cores */
                            {"type": "armv8", "num_cores": "2"}, //Corepac-0
                            {"type": "armv8", "num_cores": "2"}  //Corepac-1
                        ];
                    _self.mycpuNames_uc1 =
                        [
                            ["CortexA53_0_0", "CortexA53_0_1", "CTSET2_0"], //cores related to Corepac-0 for uc1
                            ["CortexA53_1_0", "CortexA53_1_1", "CTSET2_0"]  //cores related to Corepac-1 for uc1
                        ];
                    _self.mycpuNames =
                        [
                            ["CortexA53_0_0", "CortexA53_0_1"], //cores related to Corepac-0 for uc2,3,4
                            ["CortexA53_1_0", "CortexA53_1_1"]  //cores related to Corepac-1 for uc2,3,4
                        ];
                } else if (_self.devId == _self.deviceID2) {
                    _self.corepacInfo =
                        [   /* corepac type, number of cores */
                            {"type": "armv8", "num_cores": "2"} //Corepac-0
                        ];
                    _self.mycpuNames_uc1 =
                        [
                            ["CortexA53_0_0", "CortexA53_0_1", "CTSET2_0"], //cores related to Corepac-0 for uc1
                        ];
                    _self.mycpuNames =
                        [
                            ["CortexA53_0_0", "CortexA53_0_1"], //cores related to Corepac-0 for uc2,3,4
                        ];

                } else if (_self.devId == _self.deviceID3) {
                    console.log("corepacInfo is being initialized for the device");

                    /* TODO, need to revisit if we can get this from ctools K3 database */
                    _self.corepacInfo =
                        [   /* corepac type, number of cores */
                            {"type": "armv8", "num_cores": "2"}, //Corepac-0
                            {"type": "c7x", "num_cores": "1"}    //Corepac-1
                        ];
                    _self.mycpuNames_uc1 =
                        [
                            ["CortexA72_0_0", "CortexA72_0_1", "CTSET2_0"],  //cores related to Corepac-0 for uc1
                            ["C71X_0", "CTSET2_0"]  //cores related to Corepac-1 for uc1
                        ];
                    _self.mycpuNames =
                        [
                            ["CortexA72_0_0", "CortexA72_0_1"],  //cores related to Corepac-0 for uc3
                            ["C71X_0"]  //cores related to Corepac-1 for uc3
                        ];

                } else if (_self.devId == _self.deviceID4) {
                    console.log("corepacInfo is being initialized for the device");

                    /* TODO, need to revisit if we can get this from ctools K3 database */
                    _self.corepacInfo =
                        [   /* corepac type, number of cores */
                            {"type": "armv8", "num_cores": "2"} //Corepac-0
                        ];
                    _self.mycpuNames_uc1 =
                        [
                            ["CortexA72_0_0", "CortexA72_0_1", "CTSET2_0"]  //cores related to Corepac-0 for uc1
                        ];
                    _self.mycpuNames =
                        [
                            ["CortexA72_0_0", "CortexA72_0_1"]  //cores related to Corepac-0 for uc3
                        ];
                } else if (_self.devId == _self.deviceID5) {
                    console.log("corepacInfo is being initialized for the device");

                    /* TODO, need to revisit if we can get this from ctools K3 database */
                    _self.msmc_ctset2_present = false;

                    _self.corepacInfo =
                        [   /* corepac type, number of cores */
                            {"type": "armv8", "num_cores": "2"} //Corepac-0
                        ];
                    _self.mycpuNames_uc1 =
                        [
                            ["CortexA53_0", "CortexA53_1"], //cores related to Corepac-0 for uc1
                        ];
                    _self.mycpuNames =
                        [
                            ["CortexA53_0", "CortexA53_1"], //cores related to Corepac-0 for uc2,3,4
                        ];
                } else if (_self.devId == _self.deviceID6) { // AM62x
                    console.log("corepacInfo is being initialized for the device");

                    /* TODO, need to revisit if we can get this from ctools K3 database */
                    _self.msmc_ctset2_present = false;
                    _self.corepacInfo =
                        [   /* corepac type, number of cores */
                            {"type": "armv8", "num_cores": "4"} //Corepac-0
                        ];
                    _self.mycpuNames_uc1 =
                        [
                            ["CortexA53_0", "CortexA53_1", "CortexA53_2", "CortexA53_3"]  //cores related to Corepac-0 for uc1
                        ];
                    _self.mycpuNames =
                        [
                            ["CortexA53_0", "CortexA53_1", "CortexA53_2", "CortexA53_3",]  //cores related to Corepac-0 for uc2,3,4
                        ];
                } else if (_self.devId == _self.deviceID7) { // J7AEP
                    console.log("corepacInfo is being initialized for the device");

                    /* TODO, need to revisit if we can get this from ctools K3 database */
                    _self.corepacInfo =
                        [   /* corepac type, number of cores */
                            {"type": "armv8", "num_cores": "2"}, //Corepac-0
                            {"type": "c7x", "num_cores": "2"}    //Corepac-1
                        ];
                    _self.mycpuNames_uc1 =
                        [
                            ["CortexA72_0_0", "CortexA72_0_1", "CTSET2_0"], //cores and msmc ctset related to Corepac-0 for uc1
                            ["C71X_0", "C71X_1", "CTSET2_0"]  //cores and msmc ctset related to Corepac-1 for uc1
                        ];
                    _self.mycpuNames =
                        [
                            ["CortexA72_0_0", "CortexA72_0_1"],  //cores related to Corepac-0 for uc3
                            ["C71X_0", "C71X_0",]  //cores related to Corepac-1 for uc3
                        ];
                } else {
                    //placeholder for other device
                }
            },


            init_helpInfo: function () {

                var _self = this;
                var des_h = "**Description**<br><br>";
                var tips_h = "**Tips**<br><br>";

                if (_self.devId == _self.deviceID5 || _self.devId == _self.deviceID6) { //For devices without MSMC
                    var tip1_uc1_l3 = "";
                    var uc1_helptext = "L1/L2";
                } else { //For devices with MSMC
                    var tip1_uc1_l3 = "CTSET2 counters in MSMC will be used for L3 cache data in this use case. Please make sure those counters are not used in " +
                        "the application code while running this use case.<br><br>";
                    var uc1_helptext = "L1/L2/L3";
                }

                var tip1_uc1 = "1. ARM PMU counters will be used for L1/L2 cache data for this use case. Please make sure those counters are not used in " +
                    "the application code while running this use case.<br><br>" + tip1_uc1_l3;
                var tip1_uc1_c7 = "1. CTSET2 counters in C7x CorePac will be used for L1/L2 cache data for this use case. You will need to select either " +
                    " L1P or L1D for this use case. Please make sure those counters are not used in " +
                    "the application code while running this use case.<br><br>" + tip1_uc1_l3;
                var tip1_uc2_3_4 = "1. ARM PMU counters will be used for this use case. Please make sure those counters are not used in " +
                    "the application code while running this use case.<br><br>";
                var tip1_uc3_c7 = "1. CTSET2 counters in C7x CorePac will be used for this use case. Please make sure those counters are not used in " +
                    "the application code while running this use case.<br><br>";
                var tip2 = "2. Use hardware breakpoints instead of software breakpoints to debug your code when running this use case. " +
                    "Usage of software breakpoints may interfere with instruction cache behavior causing inaccurate result for this use case.<br>";


                _self.uc_helpInfo = [
                    des_h + "This use case presents the cache hit percentage data at " + uc1_helptext + " cache levels for each CorePac CPU.<br><br>" + tips_h + tip1_uc1 + tip2,
                    des_h + "This use case presents the cachable data percentage for all the data accesses for each CorePac CPU.<br><br>" + tips_h + tip1_uc2_3_4,
                    des_h + "This use case presents the MMU TLB hit percentage data for each CorePac CPU.<br><br>" + tips_h + tip1_uc2_3_4 + tip2,
                    des_h + "This use case presents the CPU performance benchmarking data in the unit of Instruction Per Cycle for each CorePac CPU.<br><br>" + tips_h + tip1_uc2_3_4
                ];
                _self.uc_helpInfo_c7 = [
                    des_h + "This use case presents the cache hit percentage data at L1/L2/L3 cache levels for C7x CPU.<br><br>" + tips_h + tip1_uc1_c7 + tip2,
                    des_h + "This use case presents the MMU TLB miss data for C7x CPU.<br><br>" + tips_h + tip1_uc3_c7 + tip2
                ];
            },


            /////////////////////////////////////////////////////////
            // initialize the usecase list here
            /////////////////////////////////////////////////////////
            init_uclist: function () {
                var _self = this;
                var tabs = document.querySelector('#ti_widget_tabcontainer');
                var tabs_c7 = document.querySelector('#ti_widget_tabcontainer_c7');


                if ((_self.devId == _self.deviceID1) || (_self.devId == _self.deviceID3) || (_self.devId == _self.deviceID4) || (_self.devId == _self.deviceID5) || (_self.devId == _self.deviceID6) || (_self.devId == _self.deviceID7)) {
                    if ((_self.corepacSelected != 9999) && (_self.corepacSelected != undefined)) {
                        if (_self.corepacInfo[_self.corepacSelected].type === "armv8") { //ARMv8 cores
                            _self.uc1 = "Cache Hit Percentage";
                            _self.uc2 = "Cacheable Data Percentage";
                            _self.uc3 = "MMU TLB Hit Percentage";
                            _self.uc4 = "CPU Performance Benchmark";

                            _self.init_helpInfo();
                            _self.md_txt = _self.uc_helpInfo[_self.uc_index];

                            // show the use cases tabs
                            if (tabs != null)
                                tabs.style = "visibility:visible;width:75%;flex-grow:1";
                            if (tabs_c7 != null)
                                tabs_c7.style = "visibility:hidden;width:0;flex-grow:0";

                            _self.uc_warning = "";

                        } else if (_self.corepacInfo[_self.corepacSelected].type === "c7x") { //C7x cores
                            _self.uc1 = "Cache Hit Percentage";
                            _self.uc2 = "";
                            _self.uc3 = "MMU TLB Miss";
                            _self.uc4 = "";

                            _self.init_helpInfo();
                            _self.md_txt_c7 = _self.uc_helpInfo_c7[_self.uc_index_c7];

                            // show the use cases tabs
                            if (tabs != null)
                                tabs.style = "visibility:hidden;width:0;flex-grow:0";
                            if (tabs_c7 != null)
                                tabs_c7.style = "visibility:visible;width:75%;flex-grow:1";

                            _self.uc_warning = "";

                        }
                    } else {
                        _self.uc1 = "No Use Case found for the selected core";
                        _self.uc2 = "";
                        _self.uc3 = "";
                        _self.uc4 = "";

                        // For invalid cases, hide the use cases tabs
                        if (tabs != null)
                            tabs.style = "visibility:hidden";
                        if (tabs_c7 != null)
                            tabs_c7.style = "visibility:hidden";

                        _self.uc_warning = "Warning:  no valid use case found for this core!";
                    }
                } else {

                    _self.uc1 = "No Use Case found for the device. Check if the device is connected first, then close this window and retry.";
                    _self.uc2 = "";
                    _self.uc3 = "";
                    _self.uc4 = "";

                    // For invalid cases, hide the use cases tabs
                    if (tabs != null)
                        tabs.style = "visibility:hidden";
                    if (tabs_c7 != null)
                        tabs_c7.style = "visibility:hidden";

                    _self.uc_warning = "Warning:  No Use Case found for the device. Check if the device is connected first, then close this window and retry.";
                }

            },

            /////////////////////////////////////////////////////////
            // initialize the usecase
            /////////////////////////////////////////////////////////
            init_uc: function () {
                var _self = this;

                if ((_self.corepacSelected != 9999) && (_self.corepacSelected != undefined) && (_self.corepacInfo.length > 0)) {
                    _self.init_uc1();
                    _self.init_uc2(); //this is irrelevant for c7x corepac
                    _self.init_uc3();
                    _self.init_uc4(); //this is irrelevant for c7x corepac
                }
            },


            /////////////////////////////////////////////////////////
            // Enable Target events for SyncRun
            /////////////////////////////////////////////////////////
            syncRun_init: function () {
                var _self = this;
                var p = [];
                var j;


                if ((_self.corepacInfo.length > 0) && (_self.corepacSelected != 9999) || (_self.corepacSelected != undefined)) {

                    if (_self.syncRun[_self.corepacSelected]) {
                        console.log("Add target event listener");
                        _self.ta.cloudTrace.addListener("targetEvent", _self.tgtEvtCallback);


                        //Enable the CCS event notification for all the relevant cores in the selected CorePac.
                        for (j = 0; j < _self.corepacInfo[_self.corepacSelected].num_cores; j++) {
                            p[j] = _self.ta.cloudTrace.enableTargetEvents(_self.cpuFullNames[_self.corepacSelected][j]);
                        }

                        // Set the timeout so that we have enough time to finish all the tasks before preRunComplete() call in _tgtPreRun() function.
                        p[j] = _self.ta.cloudTrace.setPreRunTimeout(10000);

                        Promise.all(p).then(function () {
                            console.log("Event notification enable passed");
                            return _self.preRun_init();
                        }).then(function () {
                            console.log("Sync Run is now enabled");
                            _self.syncRunBtn_update(); //update the SyncRun button
                        }).catch(function (err) {
                            console.log("Event notification enable FAILED: " + err.toString());
                            console.log("Sync Run is still disabled");
                            //re-disable SyncRun
                            _self.syncRun[_self.corepacSelected] = false;
                            _self.syncRunBtn_update(); //update the SyncRun button
                            //Generate a warning to user
                            alert("Sync Run operation cannot be enabled! Please make sure all the cores in the selected CorePac are connected in CCS and then retry!");
                        });

                    } else {
                        console.log("Remove target event listener");
                        _self.ta.cloudTrace.removeListener("targetEvent", _self.tgtEvtCallback);

                        //Disable the CCS event notification for all the relevant cores in the selected CorePac.
                        for (j = 0; j < _self.corepacInfo[_self.corepacSelected].num_cores; j++) {
                            p[j] = _self.ta.cloudTrace.disableTargetEvents(_self.cpuFullNames[_self.corepacSelected][j]);
                        }

                        Promise.all(p).then(function () {
                            console.log("Event notification disable passed");
                            return _self.preRun_init();
                        }).then(function () {
                            console.log("Sync Run is now disabled");
                            _self.syncRunBtn_update(); //update the SyncRun button
                        }).catch(function (err) {
                            console.log("Event notification disable FAILED: " + err.toString());
                            console.log("Sync Run is still enabled");
                            //re-enable SyncRun
                            _self.syncRun[_self.corepacSelected] = true;
                            _self.syncRunBtn_update(); //update the SyncRun button
                            //Generate a warning to user
                            alert("Sync Run operation cannot be disabled! Please make sure all the cores in the selected CorePac are connected in CCS and then retry!");
                        });
                    }
                }
            },


            /////////////////////////////////////////////////////////
            // _profile_arm_pmu_start()
            // Configure and enable ARM PMU counter
            /////////////////////////////////////////////////////////
            _profile_arm_pmu_start: function (cpu_name, cnt_id, evt_to_count) {
                var _self = this;
                var aetopHandle;
                var armpmu_prop_setval;
                var armpmu_prop_getval;
                var i;

                /* Initialize the ARM PMU counter overflow alert text */
                _self.armPmu_alert = "";

                return new Promise(function (resolve, reject) {
                    /* Create the AET operation server for ARM PMU counter */
                    _self.ta.cloudTrace.createOperation(cpu_name, "AET").then(function (retObj) {
                        /* save the AET operation handle for later use */
                        aetopHandle = retObj.handle;
                        console.log(cpu_name + ": ARM PMU Counter " + cnt_id + " operation created: id = " + aetopHandle);
                        return retObj;
                    }).then(function () {
                        // Get the property tree for ARM PMU counter
                        return _self.ta.cloudTrace.getProperties(aetopHandle);
                    }).then(function (retObj) {
                        armpmu_prop_setval = retObj.cfg;
                        var armpmu_prop = armpmu_prop_setval[0];

                        // Modify the properties for ARM PMU counter
                        for (i = 0; i < armpmu_prop.sub_properties.length; i++) {
                            if (armpmu_prop.sub_properties[i].name === "Event to Count") {
                                armpmu_prop.sub_properties[i].value = evt_to_count;
                            }
                        }
                        // Set the ARM PMU counter properties
                        return _self.ta.cloudTrace.setProperties(aetopHandle, armpmu_prop_setval);
                    }).then(function () {
                        // Get the ARM PMU counter properties again
                        return _self.ta.cloudTrace.getProperties(aetopHandle);
                    }).then(function (retObj) {
                        // Confirm the new ARM PMU counter properties have been set correctly
                        armpmu_prop_getval = retObj.cfg;
                        if (JSON.stringify(armpmu_prop_getval) === JSON.stringify(armpmu_prop_setval)) {
                            console.log("setProperties() passed");
                            /* Enable the AET operation for ARM PMU counter */
                            return _self.ta.cloudTrace.setEnableOperation(aetopHandle, true);
                        } else {
                            var err = "setProperties() failed";
                            console.log(err);
                            return reject(err);
                        }
                    }).then(function (retObj) {
                        console.log(cpu_name + ": ARM PMU Counter " + cnt_id + " operation enabled");
                        return retObj;
                    }).then(function (retObj) {
                        _self._saveArmAetHndl(cpu_name, cnt_id, aetopHandle);
                        console.log("_profile_arm_pmu_start() passed: " + cpu_name + ", cnt_id = " + cnt_id);
                        return resolve(retObj);
                    }).catch(function (err) {
                        return reject("_profile_arm_pmu_start() failed: " + cpu_name + ", cnt_id = " + cnt_id + " " + err.toString());
                    });
                });

            },


            /////////////////////////////////////////////////////////
            // _profile_arm_pmu_stop()
            // Disable ARM PMU counter
            /////////////////////////////////////////////////////////
            _profile_arm_pmu_stop: function (cpu_name, cnt_id) {
                var _self = this;
                var aetopHandle;
                var cntval;
                var ovfl;
                var hdl_index;

                return new Promise(function (resolve, reject) {
                    /* Get the AET operation handle based on the cpu_name and cnt_id */
                    for (var i = 0; i < _self.armPmuAetHndl.length; i++) {
                        if ((_self.armPmuAetHndl[i].core == cpu_name) && (_self.armPmuAetHndl[i].cntid == cnt_id)) {
                            aetopHandle = _self.armPmuAetHndl[i].aetop;
                            hdl_index = i;
                            break;
                        }
                    }

                    if (aetopHandle == null)
                        return reject("AET Operation Handle is NULL");

                    _self.ta.cloudTrace.getProperties(aetopHandle).then(function (retObj) {
                        /* Get the current count value and overflow value */
                        var armpmu_prop = retObj.cfg[0];

                        // Modify the properties for ARM PMU counter
                        for (var i = 0; i < armpmu_prop.sub_properties.length; i++) {
                            if (armpmu_prop.sub_properties[i].name === "Current Count") {
                                cntval = armpmu_prop.sub_properties[i].value;
                            } else if (armpmu_prop.sub_properties[i].name === "Overflow") {
                                ovfl = armpmu_prop.sub_properties[i].value;
                            }
                        }
                        /* Save the counter value and overflow status */
                        _self._save_arm_counter(cpu_name, cnt_id, cntval, ovfl, _self.rstOnStart[_self.corepacSelected]);
                        //console.log(cpu_name + ": ARM PMU Counter " + cnt_id + " Count Value: " + cntval + ", Overflow: " + ovfl);
                        /* Disable the counter */
                        return _self.ta.cloudTrace.setEnableOperation(aetopHandle, false);
                    }).then(function () {
                        console.log(cpu_name + ": ARM PMU Counter " + cnt_id + " operation disabled");
                        /* Release the AET operation */
                        return _self.ta.cloudTrace.releaseOperation(aetopHandle);
                    }).then(function (retObj) {
                        console.log(cpu_name + ": ARM PMU Counter " + cnt_id + " operation released");
                        _self.armPmuAetHndl[hdl_index].aetop = null; //Reset the corresponding AET Operation handle to null
                        console.log("_profile_arm_pmu_stop() passed: " + cpu_name + ", cnt_id = " + cnt_id);
                        return resolve(retObj);
                    }).catch(function (err) {
                        return reject("_profile_arm_pmu_stop() failed: " + cpu_name + ", cnt_id = " + cnt_id + err.toString());
                    });
                });
            },

            /////////////////////////////////////////////////////////
            // _save_arm_counter()
            // Save the ARM PMU counter value and overflow status
            // resetCnt -- when false, new counter value will be added to the old value; when true, new counter value will replace the old value
            /////////////////////////////////////////////////////////
            _save_arm_counter: function (cpu_name, cnt_id, cntval, ovfl, resetCnt) {
                var _self = this;

                var found = false;

                for (var i = 0; i < _self.armPmuCnt.length; i++) {
                    //If the entry for the existing cpu and cnt_id already exists, then just update the counter value
                    if ((_self.armPmuCnt[i].core == cpu_name) && (_self.armPmuCnt[i].cntid == cnt_id)) {
                        if (resetCnt)
                            _self.armPmuCnt[i].cntval = cntval;
                        else
                            _self.armPmuCnt[i].cntval += cntval;

                        _self.armPmuCnt[i].ovfl = ovfl;
                        found = true;
                        console.log(cpu_name + ": ARM PMU Counter " + cnt_id + " Count Value: " + _self.armPmuCnt[i].cntval + ", Overflow: " + ovfl);
                        break;
                    }
                }

                // If we didn't find any entry in _self.armPmuCnt for the cpu_name and cnt_id spedified, then we will create a new entry for it
                if (!found) {
                    var obj = {"core": cpu_name, "cntid": cnt_id, "cntval": cntval, "ovfl": ovfl};
                    console.log(cpu_name + ": ARM PMU Counter " + cnt_id + " Count Value: " + cntval + ", Overflow: " + ovfl);
                    _self.armPmuCnt.push(obj);
                }

            },

            /////////////////////////////////////////////////////////
            // _get_arm_counter()
            // Fetch the ARM PMU counter value and overflow status
            /////////////////////////////////////////////////////////
            _get_arm_counter: function (cpu_name, cnt_id) {
                var _self = this;

                var obj = {"found": false, "cntval": 0, "ovfl": false};

                for (var i = 0; i < _self.armPmuCnt.length; i++) {
                    //If the entry for the existing cpu and cnt_id already exists, then just update the counter value
                    if ((_self.armPmuCnt[i].core == cpu_name) && (_self.armPmuCnt[i].cntid == cnt_id)) {
                        obj.found = true;
                        obj.cntval = _self.armPmuCnt[i].cntval;
                        obj.ovfl = _self.armPmuCnt[i].ovfl;
                        break;
                    }
                }

                return obj;
            },


            /////////////////////////////////////////////////////////
            // _saveArmAetHndl()
            /////////////////////////////////////////////////////////
            _saveArmAetHndl: function (cpu_name, cnt_id, aetopHandle) {
                var _self = this;

                var found = false;


                for (var i = 0; i < _self.armPmuAetHndl.length; i++) {
                    if ((_self.armPmuAetHndl[i].core == cpu_name) && (_self.armPmuAetHndl[i].cntid == cnt_id)) {
                        _self.armPmuAetHndl[i].aetop = aetopHandle;
                        found = true;
                        break;
                    }
                }

                if (!found) {
                    var obj = {"core": "", "cntid": "", "aetop": 0};
                    obj.core = cpu_name;
                    obj.cntid = cnt_id;
                    obj.aetop = aetopHandle;

                    _self.armPmuAetHndl.push(obj);
                }
            },

            /////////////////////////////////////////////////////////
            // _profile_msmc_ctset2_stop()
            // Get the CTSET2 counter values and then disable the counters
            /////////////////////////////////////////////////////////
            _profile_msmc_ctset2_stop: function (cnt_id) {

                var _self = this;

                var aetopHandle = _self.ctset2AetHndl[cnt_id];

                return new Promise(function (resolve, reject) {

                    _self.ta.cloudTrace.getProperties(aetopHandle).then(function (retObj) {
                        /* Get the current count value and overflow value */
                        var ctset2_prop = retObj.cfg[0];

                        for (var i = 0; i < ctset2_prop.sub_properties.length; i++) {
                            if (ctset2_prop.sub_properties[i].name === "Current Count") {
                                if (_self.rstOnStart[_self.corepacSelected])
                                    _self.ctset2Cnt[cnt_id] = ctset2_prop.sub_properties[i].value;
                                else
                                    _self.ctset2Cnt[cnt_id] += ctset2_prop.sub_properties[i].value;
                            } else if (ctset2_prop.sub_properties[i].name === "Overflow") {
                                _self.ctset2Ovfl[cnt_id] = ctset2_prop.sub_properties[i].value;
                            }
                        }
                        console.log("MSMC CTSET2 Counter " + cnt_id + " Count Value: " + _self.ctset2Cnt[cnt_id] + ", Overflow: " + _self.ctset2Ovfl[cnt_id]);
                        /* Disable the counter */
                        return _self.ta.cloudTrace.setEnableOperation(aetopHandle, false);
                    }).then(function () {
                        console.log("MSMC CTSET2 Counter " + cnt_id + " operation disabled");
                        /* Release the AET operation */
                        return _self.ta.cloudTrace.releaseOperation(aetopHandle);
                    }).then(function (retObj) {
                        console.log("MSMC CTSET2 Counter " + cnt_id + " operation released");
                        _self.ctset2AetHndl[cnt_id] = null;
                        console.log("_profile_msmc_ctset2_stop() passed: cnt_id = " + cnt_id);
                        return resolve(retObj);
                    }).catch(function (err) {
                        _self.ctset2AetHndl[cnt_id] = null;
                        return reject("_profile_msmc_ctset2_stop() failed: cnt_id = " + cnt_id + err.toString());
                    });
                });
            },

            /////////////////////////////////////////////////////////
            /* Initialize counters needed for L3 cache benchmarking */
            /////////////////////////////////////////////////////////
            _l3_cnt_reset: function () {
                var _self = this;

                for (var i = 0; i < _self.num_ctset2_cnt; i++) {
                    _self.ctset2Cnt[i] = 0;
                }
            },
            /////////////////////////////////////////////////////////
            /* Initialize C7x CTSET2 counters needed for C7x L1/L2 cache benchmarking */
            /////////////////////////////////////////////////////////
            _c7_cnt_reset: function () {
                var _self = this;

                for (var i = 0; i < _self.num_ctset2_cnt_c7; i++) {
                    _self.ctset2Cnt_c7[i] = 0;
                }
            },

            _rstOnStartHdlr: function () {
                var _self = this;

                // Do nothing if there is job running
                if (_self.jobInProg[_self.corepacSelected]) {
                    alert("Cannot change this while there is job running!");
                } else {
                    //toggle the rstOnStart status
                    _self.rstOnStart[_self.corepacSelected] = !_self.rstOnStart[_self.corepacSelected];
                    _self.rstBtn_update();
                }
            },

            _syncRunHdlr: function () {
                var _self = this;

                // Do nothing if there is job running
                if (_self.jobInProg[_self.corepacSelected]) {
                    alert("Cannot change this while there is job running!");
                } else {
                    var corepac_connected = true;
                    var unconn_cores = "";

                    // Check if all the cores in the selected corepac are connected or not before we call the enable/disable target event commands
                    _self.check_corepac_connected().then(function () {
                        for (var i = 0; i < _self.corepacInfo[_self.corepacSelected].num_cores; i++) {

                            if (!_self.core_connected[_self.corepacSelected][i]) {
                                corepac_connected = false;
                                unconn_cores += _self.cpuFullNames[_self.corepacSelected][i] + "\n";
                            }
                        }

                        //Generate a warning if not all the cores in the selected corepac are connected and then do nothing here
                        if (!corepac_connected) {
                            alert("Sync Run configuration failed! Please connect the following cores first and then retry:\n" + unconn_cores);
                        } else {
                            //toggle the sync run status
                            _self.syncRun[_self.corepacSelected] = !_self.syncRun[_self.corepacSelected];
                            _self.syncRun_init();
                        }
                    }).catch(function () {
                        console.log("check_corepac_connected() failed");
                    });
                }
            },


            syncRunBtn_update: function () {
                var _self = this;
                var mybutton = document.querySelector('#syncRun_button');
                if (_self.syncRun[_self.corepacSelected]) {
                    mybutton.style = "background: #115566; color: white";
                } else {
                    mybutton.style = "background:transparent; color: #115566";
                }

                if (_self.syncRun[_self.corepacSelected]) {
                    _self.syncrun_title = _self._syncRun_title_disable;
                } else {
                    _self.syncrun_title = _self._syncRun_title_enable;
                }
            },

            rstBtn_update: function () {
                var _self = this;
                var mybutton = document.querySelector('#rstOnStart_button');
                if (!_self.rstOnStart[_self.corepacSelected]) {
                    mybutton.style = "background: #115566; color: white";
                } else {
                    mybutton.style = "background:transparent; color: #115566";
                }

                if (!_self.rstOnStart[_self.corepacSelected]) {
                    _self.rstbtn_title = _self._rstbtn_title_enable;
                    console.log("_self.rstOnStart is disabled");
                } else {
                    _self.rstbtn_title = _self._rstbtn_title_disable;
                    console.log("_self.rstOnStart is enabled");
                }

            },

            _tgtPreRun: function (x) {
                var _self = this;

                if (_self.syncRun[_self.corepacSelected]) {

                    var onStartFunc;
                    var start_job = false;

                    console.log("target " + x.target + " is about to run");

                    if (_self.corepacInfo[_self.corepacSelected].type === "armv8") {
                        switch (_self.uc_val) {
                            case _self.uc1:
                                onStartFunc = _self._onStart_uc1.bind(this);
                                if (!_self.uc1InProg[_self.corepacSelected]) {
                                    _self.uc1InProg[_self.corepacSelected] = true;
                                    start_job = true;
                                }
                                break;
                            case _self.uc2:
                                onStartFunc = _self._onStart_uc2.bind(this);
                                if (!_self.uc2InProg[_self.corepacSelected]) {
                                    _self.uc2InProg[_self.corepacSelected] = true;
                                    start_job = true;
                                }
                                break;
                            case _self.uc3:
                                onStartFunc = _self._onStart_uc3.bind(this);
                                if (!_self.uc3InProg[_self.corepacSelected]) {
                                    _self.uc3InProg[_self.corepacSelected] = true;
                                    start_job = true;
                                }
                                break;
                            case _self.uc4:
                                onStartFunc = _self._onStart_uc4.bind(this);
                                if (!_self.uc4InProg[_self.corepacSelected]) {
                                    _self.uc4InProg[_self.corepacSelected] = true;
                                    start_job = true;
                                }
                                break;
                            default:
                                break;
                        }
                    } else if (_self.corepacInfo[_self.corepacSelected].type === "c7x") {
                        switch (_self.uc_val_c7) {
                            case _self.uc1:
                                onStartFunc = _self._onStart_uc1_c7.bind(this);
                                if (!_self.uc1InProg[_self.corepacSelected]) {
                                    _self.uc1InProg[_self.corepacSelected] = true;
                                    start_job = true;
                                }
                                break;
                            case _self.uc3:
                                onStartFunc = _self._onStart_uc3_c7.bind(this);
                                if (!_self.uc3InProg[_self.corepacSelected]) {
                                    _self.uc3InProg[_self.corepacSelected] = true;
                                    start_job = true;
                                }
                                break;
                            default:
                                break;
                        }
                    }

                    for (var i = 0; i < _self.corepacInfo[_self.corepacSelected].num_cores; i++) {
                        if (x.target == _self.cpuFullNames[_self.corepacSelected][i]) {
                            _self.cpuExeStatus[_self.corepacSelected][i] = "running";
                            break;
                        }
                    }

                    return new Promise(function (resolve, reject) {
                        if (!start_job) {
                            _self.ta.cloudTrace.preRunComplete().then(function () {
                                console.log("preRunComplete() passed!");
                                return resolve("SUCCESS");
                            }).catch(function (err) {
                                console.log("_tgtPreRun() failed here: " + err.toString());
                                return reject(err);
                            });
                        } else {
                            onStartFunc().then(function () {
                                console.log("onStartFunc() passed!");
                                return _self.ta.cloudTrace.preRunComplete();
                            }).then(function () {
                                console.log("preRunComplete() passed!");
                                if (_self.start_alert[_self.corepacSelected] != "") {
                                    alert(_self.start_alert[_self.corepacSelected]);
                                    /* reset the alert after it has been prompted */
                                    _self.start_alert[_self.corepacSelected] = "";
                                }
                                return resolve("SUCCESS");
                            }).catch(function (err) {
                                console.log("_tgtPreRun() failed here: " + err.toString());
                                return reject(err);
                            });
                        }
                    });
                }
            },

            _tgtEvtCallback: function (info) {

                console.log("Event received: " + JSON.stringify(info));
                if (info.eventName === "Halt") {
                    return this._tgtHalted(info);
                } else if (info.eventName == "PreRun") {
                    return this._tgtPreRun(info);
                }

                return;
            },

            _tgtHalted: function (x) {
                var _self = this;

                console.log("target " + x.target + " has halted");


                /* We will only respond if sync run is enabled */
                if (_self.syncRun[_self.corepacSelected]) {
                    var onStopFunc;

                    var stop_job = true;
                    var i;


                    for (i = 0; i < _self.corepacInfo[_self.corepacSelected].num_cores; i++) {
                        if (x.target == _self.cpuFullNames[_self.corepacSelected][i]) {
                            _self.cpuExeStatus[_self.corepacSelected][i] = "halted";
                            break;
                        }
                    }

                    /* Set stop_job to true only when all the cpus in the Corepac is halted */
                    for (i = 0; i < _self.corepacInfo[_self.corepacSelected].num_cores; i++) {
                        if (_self.cpuExeStatus[_self.corepacSelected][i] != "halted")
                            stop_job = false;
                    }


                    // Stop the job
                    if (stop_job) {
                        if (_self.corepacInfo[_self.corepacSelected].type === "armv8") {
                            switch (_self.uc_val) {
                                case _self.uc1:
                                    onStopFunc = _self._onStop_uc1.bind(this);
                                    _self.uc1InProg[_self.corepacSelected] = false;
                                    break;
                                case _self.uc2:
                                    onStopFunc = _self._onStop_uc2.bind(this);
                                    _self.uc2InProg[_self.corepacSelected] = false;
                                    break;
                                case _self.uc3:
                                    onStopFunc = _self._onStop_uc3.bind(this);
                                    _self.uc3InProg[_self.corepacSelected] = false;
                                    break;
                                case _self.uc4:
                                    onStopFunc = _self._onStop_uc4.bind(this);
                                    _self.uc4InProg[_self.corepacSelected] = false;
                                    break;
                                default:
                                    break;
                            }
                        } else if (_self.corepacInfo[_self.corepacSelected].type === "c7x") {

                            switch (_self.uc_val_c7) {
                                case _self.uc1:
                                    onStopFunc = _self._onStop_uc1_c7.bind(this);
                                    _self.uc1InProg[_self.corepacSelected] = false;
                                    break;
                                case _self.uc3:
                                    onStopFunc = _self._onStop_uc3_c7.bind(this);
                                    _self.uc3InProg[_self.corepacSelected] = false;
                                    break
                                default:
                                    break;
                            }
                        }

                        onStopFunc();
                    }
                }
            },

            preRun_init: function () {
                var _self = this;
                var p = [];

                /* if sync box is checked, then enable the CCS PreRun event notification for the corresponding cpus in the selected CorePac. */
                /* if sync box is unchecked, then disable the CCS PreRun event notification for the corresponding cpus in the selected CorePac. */
                if (_self.syncRun[_self.corepacSelected]) {
                    return new Promise(function (resolve, reject) {
                        for (var j = 0; j < _self.corepacInfo[_self.corepacSelected].num_cores; j++) {
                            p[j] = _self.ta.cloudTrace.enableTargetPreRunEvent(_self.cpuFullNames[_self.corepacSelected][j]);
                        }

                        Promise.all(p).then(function (retObj) {
                            console.log("Pre Run Event notification enable passed");
                            return resolve(retObj);
                        }).catch(function (err) {
                            return reject("Pre Run Event notification enable failed:" + err.toString());
                        });
                    });
                } else {

                    return new Promise(function (resolve, reject) {
                        for (var j = 0; j < _self.corepacInfo[_self.corepacSelected].num_cores; j++) {
                            p[j] = _self.ta.cloudTrace.disableTargetPreRunEvent(_self.cpuFullNames[_self.corepacSelected][j]);
                        }

                        Promise.all(p).then(function (retObj) {
                            console.log("Pre Run Event notification disable passed");
                            return resolve(retObj);
                        }).catch(function (err) {
                            return reject("Pre Run Event notification disable failed:" + err.toString());
                        });
                    });

                }
            },

            //////////////////////////////////////////////////////// JavaScript source code specific to usecase 1 /////////////////////////////////////////////////////////////


            /////////////////////////////////////////////////////////
            // initialization for usecase1
            /////////////////////////////////////////////////////////
            init_uc1: function () {
                var _self = this;
                var data = ["", "", "", "", "", ""];

                // table header
                _self.uc1_th0 = "Cache Name";
                _self.uc1_th1 = "Cache Hit Percentage";

                // Initialize L3 counter values
                if (_self.msmc_ctset2_present) {
                    _self._l3_cnt_reset();
                }

                // Initialize the table display
                _self.table_init_uc1(data);

            },

            table_init_uc1: function (data) {
                var _self = this;
                var tableItems = [];
                var i = 0;

                if ((_self.devId == _self.deviceID1) || (_self.devId == _self.deviceID3) || (_self.devId == _self.deviceID4) || (_self.devId == _self.deviceID5) || (_self.devId == _self.deviceID6) || (_self.devId == _self.deviceID7)) {
                    //var obj = { "col1": "", "col2": "" };
                    //var cache_name;
                    if (_self.corepacInfo[_self.corepacSelected].type === "armv8") {
                        for (var j = 0; j < _self.corepacInfo[_self.corepacSelected].num_cores; j++) {
                            var obj1 = {"col1": "", "col2": ""};
                            var obj2 = {"col1": "", "col2": ""};
                            obj1.col1 = _self.mycpuNames_uc1[_self.corepacSelected][j] + " L1 Instruction Cache";
                            obj1.col2 = data[i];
                            obj2.col1 = _self.mycpuNames_uc1[_self.corepacSelected][j] + " L1 Data Cache"
                            obj2.col2 = data[i + 1];
                            tableItems.push(obj1);
                            tableItems.push(obj2);
                            i = i + 2;
                        }
                        tableItems.push({"col1": "L2 Data Cache", "col2": data[i]});
                        if (_self.msmc_ctset2_present) {
                            tableItems.push({"col1": "L3 Cache", "col2": data[i + 1]});
                        }
                    } else if (_self.corepacInfo[_self.corepacSelected].type === "c7x") {
                        for (var j = 0; j < _self.corepacInfo[_self.corepacSelected].num_cores; j++) {
                            var obj1 = {"col1": "", "col2": ""};
                            var obj2 = {"col1": "", "col2": ""};
                            if (_self.c7x_l1sel === "L1P") {
                                obj1.col1 = _self.mycpuNames_uc1[_self.corepacSelected][j] + " L1P Cache";
                            } else {
                                obj1.col1 = _self.mycpuNames_uc1[_self.corepacSelected][j] + " L1D Cache";
                            }
                            obj1.col2 = data[i];
                            obj2.col1 = _self.mycpuNames_uc1[_self.corepacSelected][j] + " L2 Cache"
                            obj2.col2 = data[i + 1];
                            tableItems.push(obj1);
                            tableItems.push(obj2);
                            i = i + 2;
                        }
                        tableItems.push({"col1": "L3 Cache", "col2": data[i]});
                    }
                } else { // other device
                    //placeholder for now, TODO
                }

                // Update the table
                _self.uc1_tableItems = JSON.parse(JSON.stringify(tableItems));


            },
            /////////////////////////////////////////////////////////
            // check_core_connected -- check if core is connected. if not, connect it
            /////////////////////////////////////////////////////////
            check_core_connected: function (core_number) {
                var _self = this;

                return new Promise(function (resolve, reject) {

                    _self.ta.cloudTrace.isTargetConnected(_self.cpuFullNames[_self.corepacSelected][core_number]).then(function (retObj) {
                        _self.core_connected[_self.corepacSelected][core_number] = retObj.connected;
                        return resolve(retObj);
                    }).catch(function (err) {
                        return reject(err);
                    });
                });
            },

            /////////////////////////////////////////////////////////
            // connect_core -- check if core is connected. if not, connect it
            /////////////////////////////////////////////////////////

            connect_core: function (core_number) {
                var _self = this;


                return new Promise(function (resolve, reject) {

                    // Check if the core is already connected
                    _self.ta.cloudTrace.isTargetConnected(_self.cpuFullNames[_self.corepacSelected][core_number]).then(function (retObj) {

                        // Record the core connect status
                        _self.core_connected[_self.corepacSelected][core_number] = retObj.connected;

                        // Connect core if not connected already
                        if (retObj.connected != true) {

                            // initCore() will cause CCS connect/disconnect on the specified cpu, will leave cpu in connected state from our perspective, not visible to user though
                            _self.tm.initCore(_self.cpuFullNames[_self.corepacSelected][core_number]);

                            // Change status to connected
                            _self.core_connected[_self.corepacSelected][core_number] = true;
                        }

                        console.log("Connect core passed: " + _self.cpuFullNames[_self.corepacSelected][core_number]);
                        return resolve("success");

                    }).catch(function () {
                        var err = "Core connect failed: " + _self.cpuFullNames[_self.corepacSelected][core_number];
                        alert(err);
                        console.log(err);
                        return reject(err);
                    });

                });

            },

            /////////////////////////////////////////////////////////
            // connect_corepac_cores -- check if all relevant cores are connected. if not, connect them
            /////////////////////////////////////////////////////////
            connect_corepac_cores: function () {
                var _self = this;
                var p = [];

                for (var j = 0; j < _self.corepacInfo[_self.corepacSelected].num_cores; j++) {
                    p[j] = _self.connect_core(j);
                }

                /* Wait for all the operations to finish */
                return Promise.all(p);
            },

            /////////////////////////////////////////////////////////
            // connect_msmc_ctset2 -- connect MSMC ctset2 core for usecase 1
            /////////////////////////////////////////////////////////
            connect_msmc_ctset2: function () {
                var _self = this;
                var len = _self.cpuFullNames_uc1[_self.corepacSelected].length;
                var ctset2_name = _self.cpuFullNames_uc1[_self.corepacSelected][len - 1];

                if (_self.msmc_ctset2_connected != true) {
                    _self.tm.initCore(ctset2_name);
                    _self.msmc_ctset2_connected = true;
                }
            },

            /////////////////////////////////////////////////////////
            // connect_c7x_ctset2 -- connect C7x ctset2 core for usecase 1 and 3
            /////////////////////////////////////////////////////////
            connect_c7x_ctset2: function () {
                var _self = this;
                var len = _self.cpuFullNames_uc1[_self.corepacSelected].length;
                var ctset2_name = _self.emulator + "/" + "CTSET2_1"; //HX, to-do, hard code for now for deviceID3, need to revisit

                if (_self.c7x_ctset2_connected != true) {
                    _self.tm.initCore(ctset2_name);
                    _self.c7x_ctset2_connected = true;
                }
            },

            /////////////////////////////////////////////////////////
            // check_corepac_connected -- check if all relevant cores are connected. if not, connect them
            /////////////////////////////////////////////////////////
            check_corepac_connected: function () {
                var _self = this;
                var p = [];

                for (var j = 0; j < _self.corepacInfo[_self.corepacSelected].num_cores; j++) {
                    p[j] = _self.check_core_connected(j);
                }

                /* Wait for all the operations to finish */
                return Promise.all(p);
            },

            /////////////////////////////////////////////////////////
            // _onStart_uc1_hdlr -- called when START/STOP button is clicked
            /////////////////////////////////////////////////////////
            _onStart_uc1_hdlr: function () {
                var _self = this;

                /* if job not started yet, then start the job */
                if (!_self.uc1_startStatus[_self.corepacSelected]) {

                    _self._onStart_uc1().then(function () {
                        console.log("_onStart_uc1_hdlr() passed");
                        if (_self.start_alert[_self.corepacSelected] != "") {
                            alert(_self.start_alert[_self.corepacSelected]);
                            /* reset the alert after it has been prompted */
                            _self.start_alert[_self.corepacSelected] = "";
                        }
                    }).catch(function (err) {
                        console.log("_onStart_uc1_hdlr() failed:" + err.toString());
                    });
                } else { /* if job already started, then stop the job */
                    _self._onStop_uc1();
                }

            },

            /////////////////////////////////////////////////////////
            // _onStart_uc1
            /////////////////////////////////////////////////////////
            _onStart_uc1: function () {
                var _self = this;

                _self.start_alert[_self.corepacSelected] = "";

                return new Promise(function (resolve, reject) {

                    // This use case cannot be started on either of the following conditions:
                    // 1) If other use case is in progress on the same corepac cores (meaning ARM PMU counters are not available)
                    // 2) If the same use case is in progress on the other corepac cores (meaning MSMC CTSET2 is not available)
                    if (_self.jobInProg[_self.corepacSelected]) { //case #1 above
                        _self.start_alert[_self.corepacSelected] = "This use case cannot be started because the other use case is in progress on the same CorePac cores using the shared PMU counters.";
                        return resolve("success");
                    } else if (_self.msmc_ctset2_inuse) { // Case #2 above
                        _self.start_alert[_self.corepacSelected] = "This use case cannot be started because the same use case is in progress on the other CorePac cores using the shared CTSET2 resource.";
                        return resolve("success");
                    } else {

                        _self.jobInProg[_self.corepacSelected] = true;

                        if (_self.msmc_ctset2_present) { //MSMC CTSET2 is present
                            _self.msmc_ctset2_inuse = true;

                            if (_self.rstOnStart[_self.corepacSelected]) {
                                var data = ["", "", "", "", "", ""];

                                // Initialize L3 counter values
                                _self._l3_cnt_reset();

                                // Update table display
                                _self.table_init_uc1(data);
                                _self.uc1_tdata[_self.corepacSelected] = JSON.parse(JSON.stringify(data));
                            }
                            _self.connect_msmc_ctset2();
                        } else { //MSMC CTSET2 is not present
                            if (_self.rstOnStart[_self.corepacSelected]) {
                                var data = ["", "", "", "", ""];

                                // Update table display
                                _self.table_init_uc1(data);
                                _self.uc1_tdata[_self.corepacSelected] = JSON.parse(JSON.stringify(data));
                            }

                        }
                        _self.connect_corepac_cores().then(function () {
                            console.log("connect_corepac_cores() passed");
                            return _self._profile_start_uc1();

                        }).then(function () {

                            console.log("_onStart_uc1() passed");
                            // Change the button from START to STOP.
                            _self.update_start_stop_btn('#start_button_uc1', true);
                            _self.uc1_startStatus[_self.corepacSelected] = true;
                            return resolve("success");


                        }).catch(function (err) {
                            // Set the flag to indicate job failed
                            _self.jobInProg[_self.corepacSelected] = false;
                            _self.msmc_ctset2_inuse = false;

                            console.log(err.toString());
                            return reject(err);

                        });
                    }
                });
            },

            /////////////////////////////////////////////////////////
            // _profile_start_uc1
            /////////////////////////////////////////////////////////
            _profile_start_uc1: function () {
                var _self = this;

                var p = [];

                return new Promise(function (resolve, reject) {
                    p[0] = _self._profile_l1_start_uc1();
                    p[1] = _self._profile_l2_start_uc1();

                    if (_self.msmc_ctset2_present) {
                        p[2] = _self._profile_l3_start_uc1();
                    }
                    /* Wait for all the start operations to finish */
                    Promise.all(p).then(function (retObj) {
                        console.log("_profile_start_uc1() passed");
                        return resolve(retObj);
                    }).catch(function (err) {
                        return reject("_profile_start_uc1() failed:" + err.toString());
                    });
                });
            },

            /////////////////////////////////////////////////////////
            // _profile_l1_start_uc1()
            //
            // Configure and enable all counters in CorePac needed for L1 cache benchmarking */
            /////////////////////////////////////////////////////////
            _profile_l1_start_uc1: function () {
                var _self = this;

                var core_names = _self.cpuFullNames_uc1[_self.corepacSelected];
                var p = [];

                if (_self.corepacInfo[_self.corepacSelected].type == "armv8") { /* A53/A72 Corepac */
                    var num_cores = _self.corepacInfo[_self.corepacSelected].num_cores;
                    var j = 0;
                    for (var i = 0; i < num_cores; i++) {
                        /* Configure PMU counters for ARM core L1 data and instruction cache */
                        p[j] = _self._profile_arm_pmu_start(core_names[i], 0, "Level 1 instruction cache refill"); // L1 instruction cache miss count
                        p[j + 1] = _self._profile_arm_pmu_start(core_names[i], 1, "Level 1 instruction cache access"); // L1 instruction cache total count
                        p[j + 2] = _self._profile_arm_pmu_start(core_names[i], 2, "Level 1 data cache refill"); // L1 data cache miss count
                        p[j + 3] = _self._profile_arm_pmu_start(core_names[i], 3, "Level 1 data cache access"); // L1 data cache total count
                        j += 4;
                    }
                } else if (_self.corepacInfo[i].type == "c7x") { // This is for C7x CorePac
                    /* placeholder for now */
                }

                return Promise.all(p);
            },

            /////////////////////////////////////////////////////////
            // _profile_l2_start_uc1()
            //
            // Configure and enable all counters in CorePac needed for L2 cache benchmarking */
            /////////////////////////////////////////////////////////
            _profile_l2_start_uc1: function () {
                var _self = this;

                var core_names = _self.cpuFullNames_uc1[_self.corepacSelected];
                var p = [];

                if (_self.corepacInfo[_self.corepacSelected].type == "armv8") { /* A53/A72 Corepac */
                    /* Configure PMU counters for L2 data cache benchmarking */
                    /* We use ARM core 0 PMU counters for this purpose */
                    p[0] = _self._profile_arm_pmu_start(core_names[0], 4, "Level 2 data cache refill"); // L2 data cache miss count
                    p[1] = _self._profile_arm_pmu_start(core_names[0], 5, "Level 2 data cache access"); // L2 data cache total count
                } else if (_self.corepacInfo[_self.corepacSelected].type == "c7x") { // This is for C7x CorePac
                    /*  placeholder for now */
                }

                return Promise.all(p);
            },


            /////////////////////////////////////////////////////////
            // _profile_l3_start_uc1()
            //
            // Configure and enable all MSMC CTSET2 counters needed for L3 cache benchmarking
            /////////////////////////////////////////////////////////
            _profile_l3_start_uc1: function () {
                var _self = this;

                var p_ctset2 = [];


                /* Config and start all the CTSET2 counters */
                p_ctset2[0] = _self._profile_msmc_ctset2_start(0, "SRAM Bank 0", "32 Bit", "Edge", "SRAM External Access Hit to Data Cache");
                p_ctset2[1] = _self._profile_msmc_ctset2_start(1, "SRAM Bank 1", "32 Bit", "Edge", "SRAM External Access Hit to Data Cache");
                p_ctset2[2] = _self._profile_msmc_ctset2_start(2, "SRAM Bank 2", "32 Bit", "Edge", "SRAM External Access Hit to Data Cache");
                p_ctset2[3] = _self._profile_msmc_ctset2_start(3, "SRAM Bank 3", "32 Bit", "Edge", "SRAM External Access Hit to Data Cache");
                p_ctset2[4] = _self._profile_msmc_ctset2_start(4, "SRAM Bank 0", "32 Bit", "Edge", "SRAM External Access Cacheable");
                p_ctset2[5] = _self._profile_msmc_ctset2_start(5, "SRAM Bank 1", "32 Bit", "Edge", "SRAM External Access Cacheable");
                p_ctset2[6] = _self._profile_msmc_ctset2_start(6, "SRAM Bank 2", "32 Bit", "Edge", "SRAM External Access Cacheable");
                p_ctset2[7] = _self._profile_msmc_ctset2_start(7, "SRAM Bank 3", "32 Bit", "Edge", "SRAM External Access Cacheable");


                /* Wait for all the CTSET2 start operations to finish */
                return Promise.all(p_ctset2);

            },

            /////////////////////////////////////////////////////////
            // _profile_msmc_ctset2_start()
            //
            // Configure and enable CTSET2 counter
            /////////////////////////////////////////////////////////
            _profile_msmc_ctset2_start: function (cnt_id, sram_bank, cnt_size, evt_detect, evt_to_count) {
                var _self = this;

                //var data;
                //var length = 0;
                var aetopHandle;
                var i;
                var ctset2_prop_setval;
                var ctset2_prop_getval;
                var ctset2_name;

                /* Initialize the CTSET2 counter overflow alert text */
                _self.ctset2_alert = "";

                var str = _self.cpuFullNames_uc1[_self.corepacSelected];
                for (i = 0; i < _self.cpuFullNames_uc1[_self.corepacSelected].length; i++) {
                    if (str[i].indexOf("CTSET2_0") >= 0) {
                        ctset2_name = _self.cpuFullNames_uc1[_self.corepacSelected][i];
                        break;
                    }
                }

                return new Promise(function (resolve, reject) {
                    /* Create the AET operation server for CTSET2 */
                    _self.ta.cloudTrace.createOperation(ctset2_name, "AET").then(function (retObj) {
                        /* save the AET operation handle for later use */
                        aetopHandle = retObj.handle;
                        console.log("MSMC CTSET2 Counter " + cnt_id + " operation created: id = " + aetopHandle);
                        return retObj;
                    }).then(function () {
                        // Get the property tree for CTSET2 counter
                        return _self.ta.cloudTrace.getProperties(aetopHandle);
                    }).then(function (retObj) {
                        ctset2_prop_setval = retObj.cfg;
                        var ctset2_prop = ctset2_prop_setval[0];

                        // Modify the properties for CTSET2 counter
                        for (i = 0; i < ctset2_prop.sub_properties.length; i++) {
                            if (ctset2_prop.sub_properties[i].name === "SRAM Bank") {
                                ctset2_prop.sub_properties[i].value = sram_bank;
                            } else if (ctset2_prop.sub_properties[i].name === "Counter Size") {
                                ctset2_prop.sub_properties[i].value = cnt_size;
                            } else if (ctset2_prop.sub_properties[i].name === "Event Detection Type") {
                                ctset2_prop.sub_properties[i].value = evt_detect;
                            } else if (ctset2_prop.sub_properties[i].name === "Event to Count") {
                                ctset2_prop.sub_properties[i].value = evt_to_count;
                            }
                        }

                        // Set the MSMC ctset2 properties
                        return _self.ta.cloudTrace.setProperties(aetopHandle, ctset2_prop_setval);
                    }).then(function () {
                        // Get the MSMC ctset2 properties again
                        return _self.ta.cloudTrace.getProperties(aetopHandle);
                    }).then(function (retObj) {
                        // Confirm the new ctset2 counter properties have been set correctly
                        ctset2_prop_getval = retObj.cfg;
                        if (JSON.stringify(ctset2_prop_getval) === JSON.stringify(ctset2_prop_setval)) {
                            console.log("setProperties() passed");
                            // Enable the AET operation for CTSET2
                            return _self.ta.cloudTrace.setEnableOperation(aetopHandle, true);
                        } else {
                            console.log("setProperties() failed");
                            return reject("setProperties() failed");
                        }
                    }).then(function (retObj) {
                        console.log("MSMC CTSET2 Counter " + cnt_id + " operation enabled");
                        return retObj;
                    }).then(function (retObj) {
                        _self.ctset2AetHndl[cnt_id] = aetopHandle;
                        console.log("_profile_msmc_ctset2_start() passed: cnt_id = " + cnt_id);
                        return resolve(retObj);
                    }).catch(function (err) {
                        _self.ctset2AetHndl[cnt_id] = null;
                        return reject("_profile_msmc_ctset2_start() failed: cnt_id = " + cnt_id + err.toString());
                    });
                });
            },

            /////////////////////////////////////////////////////////
            // _onStop_uc1 -- called when STOP button is clicked
            /////////////////////////////////////////////////////////
            _onStop_uc1: function () {
                var _self = this;

                var data = [];

                if (_self.jobInProg[_self.corepacSelected]) {

                    /* Mark the job as finished */
                    _self.jobInProg[_self.corepacSelected] = false;
                    _self.msmc_ctset2_inuse = false;

                    /* Stop the profiling function and fetch the counter values for table update */
                    _self._profile_stop_uc1().then(function () {

                        /* Change the button from STOP to START button */
                        _self.update_start_stop_btn('#start_button_uc1', false);
                        _self.uc1_startStatus[_self.corepacSelected] = false;


                        /* Post Processing with returned counter data */
                        data = _self._post_process_uc1();

                        /* Update the table display with the new counter values */
                        _self.table_init_uc1(data);
                        _self.uc1_tdata[_self.corepacSelected] = JSON.parse(JSON.stringify(data));

                        /* Pop up a warning if there is any overflow in ARM PMU or CTSET2 counters */
                        if (_self.armPmu_alert != "") {
                            alert(_self.armPmu_alert);
                            /* reset alert after prompt */
                            _self.armPmu_alert = "";
                        }
                        if (_self.ctset2_alert != "") {
                            alert(_self.ctset2_alert);
                            /* reset alert after prompt */
                            _self.ctset2_alert = "";
                        }

                        console.log("_onStop_uc1() passed");

                    }).catch(function (err) {
                        /* Mark the job as not finished */
                        _self.jobInProg[_self.corepacSelected] = true;
                        if (_self.msmc_ctset2_present) {//Only do below when MSMC CTSET2 is present
                            _self.msmc_ctset2_inuse = true;
                        }
                        console.log("_onStop_uc1() failed: " + err.toString());

                    });

                }
            },

            /////////////////////////////////////////////////////////
            // _profile_stop_uc1()
            /////////////////////////////////////////////////////////
            _profile_stop_uc1: function () {
                var _self = this;

                var p = [];

                p[0] = _self._profile_l1_stop_uc1();
                p[1] = _self._profile_l2_stop_uc1();

                if (_self.msmc_ctset2_present) {
                    p[2] = _self._profile_l3_stop_uc1();
                }
                return Promise.all(p);
            },

            /////////////////////////////////////////////////////////
            // _profile_l1_stop_uc1()
            /////////////////////////////////////////////////////////
            _profile_l1_stop_uc1: function () {
                var _self = this;

                var core_names = _self.cpuFullNames_uc1[_self.corepacSelected];
                var p = [];

                if (_self.corepacInfo[_self.corepacSelected].type == "armv8") { /* A53/A72 Corepac */
                    var num_cores = _self.corepacInfo[_self.corepacSelected].num_cores;
                    var j = 0;
                    for (var i = 0; i < num_cores; i++) {
                        /* Configure PMU counters for ARM core L1 data and instruction cache */
                        p[j] = _self._profile_arm_pmu_stop(core_names[i], 0); // L1 instruction cache miss count
                        p[j + 1] = _self._profile_arm_pmu_stop(core_names[i], 1); // L1 instruction cache total count
                        p[j + 2] = _self._profile_arm_pmu_stop(core_names[i], 2); // L1 data cache miss count
                        p[j + 3] = _self._profile_arm_pmu_stop(core_names[i], 3); // L1 data cache total count
                        j += 4;
                    }
                } else if (_self.corepacInfo[i].type == "c7x") { // This is for C7x CorePac
                    /*  placeholder for now */
                }

                return Promise.all(p);
            },

            /////////////////////////////////////////////////////////
            // _profile_l2_stop_uc1()
            /////////////////////////////////////////////////////////
            _profile_l2_stop_uc1: function () {
                var _self = this;

                var core_names = _self.cpuFullNames_uc1[_self.corepacSelected];
                var p = [];

                if (_self.corepacInfo[_self.corepacSelected].type == "armv8") { /* A53/A72 Corepac */
                    /* We use ARM core 0 PMU counters for this purpose */
                    p[0] = _self._profile_arm_pmu_stop(core_names[0], 4); // L2 data cache miss count
                    p[1] = _self._profile_arm_pmu_stop(core_names[0], 5); // L2 data cache total count
                } else if (_self.corepacInfo[_self.corepacSelected].type == "c7x") { // This is for C7x CorePac
                    /*  placeholder for now */
                }

                return Promise.all(p);
            },


            /////////////////////////////////////////////////////////
            // _profile_l3_stop_uc1()
            // Stop all the CTSET2 counters for L3 cache benchmarking
            /////////////////////////////////////////////////////////
            _profile_l3_stop_uc1: function () {
                var _self = this;

                var p_ctset2 = [];

                /* Stop all the CTSET2 counters */
                for (var i = 0; i < _self.num_ctset2_cnt; i++) {
                    p_ctset2[i] = _self._profile_msmc_ctset2_stop(i);
                }

                /* Wait for all the counter stop operations to finish */
                return Promise.all(p_ctset2);
            },


            /////////////////////////////////////////////////////////
            // _post_process_uc1()
            /////////////////////////////////////////////////////////
            _post_process_uc1: function () {
                var _self = this;

                var l1_data = [];
                var l2_data;
                var l3_data;
                var data = [];

                l1_data = _self._post_process_l1_uc1();
                l2_data = _self._post_process_l2_uc1();
                if (_self.msmc_ctset2_present) {
                    l3_data = _self._post_process_l3_uc1();
                    /* Combine all the data and return */
                    data = l1_data.concat(l2_data).concat(l3_data);
                } else {
                    data = l1_data.concat(l2_data);
                }

                return data;
            },

            /////////////////////////////////////////////////////////
            // _post_process_l1_uc1()
            /////////////////////////////////////////////////////////
            _post_process_l1_uc1: function () {
                var _self = this;

                var data = [];
                var l1p_miss = [];
                var l1p_total = [];
                var l1d_miss = [];
                var l1d_total = [];
                var j = 0;

                var num_cores = _self.corepacInfo[_self.corepacSelected].num_cores;
                var core_names = _self.cpuFullNames_uc1[_self.corepacSelected];

                for (var i = 0; i < num_cores; i++) {
                    var obj;

                    /* Get L1P miss count */
                    obj = _self._get_arm_counter(core_names[i], 0);
                    if (obj.found) {
                        l1p_miss[i] = obj.cntval;
                        if (obj.ovfl == "TRUE") {
                            _self.armPmu_alert += core_names[i] + ": Counter used for L1P Miss has overflowed;\n";
                        }
                    }

                    /* Get L1P total count */
                    obj = _self._get_arm_counter(core_names[i], 1);
                    if (obj.found) {
                        l1p_total[i] = obj.cntval;
                        if (obj.ovfl == "TRUE") {
                            _self.armPmu_alert += core_names[i] + ": Counter used for L1P Total has overflowed;\n";
                        }
                    }

                    /* Get L1D miss count */
                    obj = _self._get_arm_counter(core_names[i], 2);
                    if (obj.found) {
                        l1d_miss[i] = obj.cntval;
                        if (obj.ovfl == "TRUE") {
                            _self.armPmu_alert += core_names[i] + ": Counter used for L1D Miss has overflowed;\n";
                        }
                    }

                    /* Get L1D total count */
                    obj = _self._get_arm_counter(core_names[i], 3);
                    if (obj.found) {
                        l1d_total[i] = obj.cntval;
                        if (obj.ovfl == "TRUE") {
                            _self.armPmu_alert += core_names[i] + ": Counter used for L1D Total has overflowed;\n";
                        }
                    }

                    /* Core #i L1P hit percentage */
                    if (l1p_total[i] == 0) {
                        data[j] = "No Cache Activity";
                    } else {
                        data[j] = ((l1p_total[i] - l1p_miss[i]) * 100 / l1p_total[i]).toFixed(2) + "%";
                    }


                    /* Core #i L1D hit percentage */
                    if (l1d_total[i] == 0) {
                        data[j + 1] = "No Cache Activity";
                    } else {
                        data[j + 1] = ((l1d_total[i] - l1d_miss[i]) * 100 / l1d_total[i]).toFixed(2) + "%";
                    }

                    j += 2;
                }

                return data;


            },

            /////////////////////////////////////////////////////////
            // _post_process_l2_uc1()
            /////////////////////////////////////////////////////////
            _post_process_l2_uc1: function () {
                var _self = this;

                var data;
                var l2d_miss;
                var l2d_total;
                var obj;

                var core_names = _self.cpuFullNames_uc1[_self.corepacSelected];

                /* Get L2D miss count */
                obj = _self._get_arm_counter(core_names[0], 4);
                if (obj.found) {
                    l2d_miss = obj.cntval;
                    if (obj.ovfl == "TRUE") {
                        _self.armPmu_alert += "Counter used for L2D Miss has overflowed;\n";
                    }
                }

                /* Get L2D total count */
                obj = _self._get_arm_counter(core_names[0], 5);
                if (obj.found) {
                    l2d_total = obj.cntval;
                    if (obj.ovfl == "TRUE") {
                        _self.armPmu_alert += "Counter used for L2D Total has overflowed;\n";
                    }
                }

                /* Shared L2D hit percentage */
                if (l2d_total == 0) {
                    data = "No Cache Activity";
                } else {
                    data = ((l2d_total - l2d_miss) * 100 / l2d_total).toFixed(2) + "%";
                }

                return data;
            },


            /////////////////////////////////////////////////////////
            // _post_process_l3_uc1()
            // Post Processing for ctset2
            /////////////////////////////////////////////////////////
            _post_process_l3_uc1: function () {
                var _self = this;

                var data = "0%";
                var cacheHitCnt;
                var cacheableCnt;


                /* Update the data for CTSET2 */
                cacheHitCnt = _self.ctset2Cnt[0] + _self.ctset2Cnt[1] + _self.ctset2Cnt[2] + _self.ctset2Cnt[3];
                cacheableCnt = _self.ctset2Cnt[4] + _self.ctset2Cnt[5] + _self.ctset2Cnt[6] + _self.ctset2Cnt[7];

                if (cacheableCnt == 0) {
                    data = "No Cache Activity";
                } else {
                    data = (cacheHitCnt * 100 / cacheableCnt).toFixed(2) + "%";
                }

                /* Update the overflow status for CTSET2*/
                for (var i = 0; i < _self.ctset2Cnt.length; i++) {
                    if (_self.ctset2Ovfl[i] == "overflowed") {
                        _self.ctset2_alert += "CTSET2 Counter " + i + " used for L3 Cache benchmarking has overflowed;\n";
                    }
                }

                return data;
            },
            //////////////////////////////////////////////////////// JavaScript source code specific to usecase 2 /////////////////////////////////////////////////////////////


            /////////////////////////////////////////////////////////
            // initialization for usecase2
            /////////////////////////////////////////////////////////
            init_uc2: function () {
                var _self = this;
                var data = ["", ""];

                // table header
                _self.uc2_th0 = "CPU Name";
                _self.uc2_th1 = "Cacheable Data Percentage";

                // Initialize the table display
                _self.table_init_uc2(data);
            },


            table_init_uc2: function (data) {
                var _self = this;
                var tableItems = [];
                var obj;

                if ((_self.devId == _self.deviceID1) || (_self.devId == _self.deviceID3) || (_self.devId == _self.deviceID4) || (_self.devId == _self.deviceID5) || (_self.devId == _self.deviceID6) || (_self.devId == _self.deviceID7)) {
                    //var cache_name;

                    for (var j = 0; j < _self.corepacInfo[_self.corepacSelected].num_cores; j++) {
                        obj = {"col1": "", "col2": ""};
                        obj.col1 = _self.mycpuNames[_self.corepacSelected][j];
                        obj.col2 = data[j];
                        tableItems.push(obj);
                    }
                } else { // other device
                    obj = {"col1": "", "col2": ""};
                    tableItems.push(obj);
                    tableItems.push(obj);
                }

                /* Update the table */
                _self.uc2_tableItems = JSON.parse(JSON.stringify(tableItems));
            },


            _onStart_uc2_hdlr: function () {
                var _self = this;

                /* if job not started yet, then start the job */
                if (!_self.uc2_startStatus[_self.corepacSelected]) {

                    _self._onStart_uc2().then(function () {
                        console.log("_onStart_uc2_hdlr() passed");
                        if (_self.start_alert[_self.corepacSelected] != "") {
                            alert(_self.start_alert[_self.corepacSelected]);
                            /* reset the alert after it has been prompted */
                            _self.start_alert[_self.corepacSelected] = "";
                        }
                    }).catch(function (err) {
                        console.log("_onStart_uc2_hdlr() failed:" + err.toString());
                    });
                } else { /* if job already started, then stop the job */
                    _self._onStop_uc2();
                }

            },

            /////////////////////////////////////////////////////////
            // _onStart_uc2 -- called when START button is clicked
            /////////////////////////////////////////////////////////
            _onStart_uc2: function () {
                var _self = this;

                _self.start_alert[_self.corepacSelected] = "";

                return new Promise(function (resolve, reject) {

                    // This use case cannot be started on either of the following conditions:
                    // 1) If other use case is in progress on the same corepac cores (meaning ARM PMU counters are not available)
                    if (_self.jobInProg[_self.corepacSelected]) { //case #1 above
                        _self.start_alert[_self.corepacSelected] = "This use case cannot be started because the other use case is in progress on the same CorePac cores using the shared PMU counters.";
                        return resolve("success");
                    } else {

                        _self.jobInProg[_self.corepacSelected] = true;

                        if (_self.rstOnStart[_self.corepacSelected]) {
                            var data = ["", ""];

                            // Update table display
                            _self.table_init_uc2(data);
                            _self.uc2_tdata[_self.corepacSelected] = JSON.parse(JSON.stringify(data));
                        }

                        _self._profile_start_uc2().then(function () {
                            console.log("_onStart_uc2() passed");

                            // Change the button from START button to STOP button
                            _self.update_start_stop_btn('#start_button_uc2', true);
                            _self.uc2_startStatus[_self.corepacSelected] = true;
                            return resolve("success");

                        }).catch(function (err) {

                            // Set the flag to indicate job not in progress
                            _self.jobInProg[_self.corepacSelected] = false;

                            console.log(err.toString());
                            return reject(err);
                        });
                    }
                });
            },


            /////////////////////////////////////////////////////////
            // _profile_start_uc2
            /////////////////////////////////////////////////////////
            _profile_start_uc2: function () {
                var _self = this;
                var p = [];
                return new Promise(function (resolve, reject) {
                    p[0] = _self._profile_l1_start_uc2();

                    /* Wait for all the start operations to finish */
                    Promise.all(p).then(function (retObj) {
                        console.log("_profile_start_uc2() passed");
                        return resolve(retObj);
                    }).catch(function (err) {
                        return reject("_profile_start_uc2() failed:" + err.toString());
                    });
                });
            },

            /////////////////////////////////////////////////////////
            // _profile_l1_start_uc2()
            //
            // Configure and enable all counters in CorePac needed for L1 cache benchmarking
            /////////////////////////////////////////////////////////
            _profile_l1_start_uc2: function () {
                var _self = this;

                var core_names = _self.cpuFullNames[_self.corepacSelected];
                var p = [];

                if (_self.corepacInfo[_self.corepacSelected].type == "armv8") { /* A53/A72 Corepac */
                    var num_cores = _self.corepacInfo[_self.corepacSelected].num_cores;
                    var j = 0;
                    for (var i = 0; i < num_cores; i++) {
                        /* Configure PMU counters for ARM core L1 data and instruction cache */
                        p[j] = _self._profile_arm_pmu_start(core_names[i], 0, "Level 1 data cache access"); // this is the count for cacheable access
                        p[j + 1] = _self._profile_arm_pmu_start(core_names[i], 1, "Data memory access");//this is the total access count
                        j += 2;

                    }
                } else if (_self.corepacInfo[i].type == "c7x") { // This is for C7x CorePac
                    /*  placeholder for now */
                }

                return Promise.all(p);
            },


            /////////////////////////////////////////////////////////
            // _onStop_uc2 -- called when STOP button is clicked
            /////////////////////////////////////////////////////////
            _onStop_uc2: function () {
                var _self = this;

                var data = [];

                if (_self.jobInProg[_self.corepacSelected]) {

                    /* Mark the job as finished */
                    _self.jobInProg[_self.corepacSelected] = false;

                    /* Stop the profiling function and fetch the counter values for table update */
                    _self._profile_stop_uc2().then(function () {

                        // Change the button from STOP button to START button
                        _self.update_start_stop_btn('#start_button_uc2', false);
                        _self.uc2_startStatus[_self.corepacSelected] = false;

                        /* Post Processing with returned counter data */
                        data = _self._post_process_uc2();

                        /* Update the table display with the new counter values */
                        _self.table_init_uc2(data);
                        _self.uc2_tdata[_self.corepacSelected] = JSON.parse(JSON.stringify(data));


                        /* Pop up a warning if there is any overflow in ARM PMU counters */
                        if (_self.armPmu_alert != "") {
                            alert(_self.armPmu_alert);
                            /* reset alert after prompt */
                            _self.armPmu_alert = "";
                        }

                        console.log("_onStop_uc2() passed");

                    }).catch(function (err) {
                        /* Mark the job as not finished */
                        _self.jobInProg[_self.corepacSelected] = true;

                        console.log("_onStop_uc2() failed: " + err.toString());

                    });
                }
            },


            /////////////////////////////////////////////////////////
            // _profile_stop_uc2()
            /////////////////////////////////////////////////////////
            _profile_stop_uc2: function () {
                var _self = this;

                var p = [];

                p[0] = _self._profile_l1_stop_uc2();

                return Promise.all(p);
            },

            /////////////////////////////////////////////////////////
            // _profile_l1_stop_uc2()
            /////////////////////////////////////////////////////////
            _profile_l1_stop_uc2: function () {
                var _self = this;

                var core_names = _self.cpuFullNames[_self.corepacSelected];
                var p = [];

                if (_self.corepacInfo[_self.corepacSelected].type == "armv8") { /* A53/A72 Corepac */
                    var num_cores = _self.corepacInfo[_self.corepacSelected].num_cores;
                    var j = 0;
                    for (var i = 0; i < num_cores; i++) {
                        p[j] = _self._profile_arm_pmu_stop(core_names[i], 0); // this is the count for cacheable access
                        p[j + 1] = _self._profile_arm_pmu_stop(core_names[i], 1); // this is the total access count
                        j += 2;

                    }
                } else if (_self.corepacInfo[i].type == "c7x") { // This is for C7x CorePac
                    /*  placeholder for now */
                }

                return Promise.all(p);
            },


            /////////////////////////////////////////////////////////
            // _post_process_uc2()
            /////////////////////////////////////////////////////////
            _post_process_uc2: function () {
                var _self = this;

                var l1_data = [];

                l1_data = _self._post_process_l1_uc2();

                return l1_data;
            },

            /////////////////////////////////////////////////////////
            // _post_process_l1_uc2()
            /////////////////////////////////////////////////////////
            _post_process_l1_uc2: function () {
                var _self = this;

                var data = [];
                var l1d_cacheable = [];
                var total = [];

                var num_cores = _self.corepacInfo[_self.corepacSelected].num_cores;
                var core_names = _self.cpuFullNames[_self.corepacSelected];

                for (var i = 0; i < num_cores; i++) {
                    var obj;

                    /* Get L1D cacheable access count */
                    obj = _self._get_arm_counter(core_names[i], 0);
                    if (obj.found) {
                        l1d_cacheable[i] = obj.cntval;
                        if (obj.ovfl == "TRUE") {
                            _self.armPmu_alert += core_names[i] + ": Counter used for L1D Cacheable access has overflowed;\n";
                        }
                    }

                    /* Get Total Access count */
                    obj = _self._get_arm_counter(core_names[i], 1);
                    if (obj.found) {
                        total[i] = obj.cntval;
                        if (obj.ovfl == "TRUE") {
                            _self.armPmu_alert += core_names[i] + ": Counter used for Total Access has overflowed;\n";
                        }
                    }

                    /* Core #i L1D Cacheable Percentage */
                    if (total[i] == 0) {
                        data[i] = "No Cache Activity";
                    } else {
                        data[i] = (l1d_cacheable[i] * 100 / total[i]).toFixed(2) + "%";
                    }
                }

                return data;
            },

            //////////////////////////////////////////////////////// JavaScript source code specific to usecase 3 /////////////////////////////////////////////////////////////


            /////////////////////////////////////////////////////////
            // initialization for usecase3
            /////////////////////////////////////////////////////////
            init_uc3: function () {
                var _self = this;
                var data = ["", "", "", ""];

                // table header
                _self.uc3_th0 = "CPU Name";
                _self.uc3_th1 = "MMU TLB Hit Percentage";
                _self.uc3_th0_c7 = "MMU TLB Name";
                _self.uc3_th1_c7 = "TLB Miss Count";

                // Initialize the table display
                _self.table_init_uc3(data);

            },

            table_init_uc3: function (data) {
                var _self = this;
                var tableItems = [];
                var i = 0;

                if ((_self.devId == _self.deviceID1) || (_self.devId == _self.deviceID3) || (_self.devId == _self.deviceID4) || (_self.devId == _self.deviceID5) || (_self.devId == _self.deviceID6) || (_self.devId == _self.deviceID7)) {
                    if (_self.corepacInfo[_self.corepacSelected].type === "armv8") {
                        for (var j = 0; j < _self.corepacInfo[_self.corepacSelected].num_cores; j++) {
                            var obj1 = {"col1": "", "col2": ""};
                            var obj2 = {"col1": "", "col2": ""};
                            obj1.col1 = _self.mycpuNames[_self.corepacSelected][j] + " L1 Instruction Cache";
                            obj1.col2 = data[i];
                            obj2.col1 = _self.mycpuNames[_self.corepacSelected][j] + " L1 Data Cache"
                            obj2.col2 = data[i + 1];
                            tableItems.push(obj1);
                            tableItems.push(obj2);
                            i = i + 2;
                        }
                    } else if (_self.corepacInfo[_self.corepacSelected].type === "c7x") {

                        var col1 = ["Instruction uTLB", "Instruction main TLB", "Data uTLB", "Data main TLB", "Stage 2 TLB"];
                        for (var i = 0; i < 5; i++) {
                            var obj = {"col1": "", "col2": ""};
                            var obj2 = {"col1": "", "col2": ""};
                            obj.col1 = col1[i];
                            obj.col2 = data[i];
                            tableItems.push(obj);
                        }
                    }
                } else { // other device
                    //placeholder for now, TODO
                }

                // Update the table
                _self.uc3_tableItems = JSON.parse(JSON.stringify(tableItems));

            },

            /////////////////////////////////////////////////////////
            // _onStart_uc3_hdlr -- called when START button is clicked
            /////////////////////////////////////////////////////////
            _onStart_uc3_hdlr: function () {
                var _self = this;

                /* if job not started yet, then start the job */
                if (!_self.uc3_startStatus[_self.corepacSelected]) {

                    _self._onStart_uc3().then(function () {
                        console.log("_onStart_uc3_hdlr() passed");
                        if (_self.start_alert[_self.corepacSelected] != "") {
                            alert(_self.start_alert[_self.corepacSelected]);
                            /* reset the alert after it has been prompted */
                            _self.start_alert[_self.corepacSelected] = "";
                        }
                    }).catch(function (err) {
                        console.log("_onStart_uc3_hdlr() failed:" + err.toString());
                    });
                } else { /* if job already started, then stop the job */
                    _self._onStop_uc3();
                }

            },

            /////////////////////////////////////////////////////////
            // _onStart_uc3
            /////////////////////////////////////////////////////////
            _onStart_uc3: function () {
                var _self = this;
                //var length = 0;
                _self.start_alert[_self.corepacSelected] = "";

                return new Promise(function (resolve, reject) {

                    // This use case cannot be started on either of the following conditions:
                    // 1) If other use case is in progress on the same corepac cores (meaning ARM PMU counters are not available)
                    if (_self.jobInProg[_self.corepacSelected]) { //case #1 above
                        _self.start_alert[_self.corepacSelected] = "This use case cannot be started because the other use case is in progress on the same CorePac cores using the shared PMU counters.";
                        return resolve("success");
                    } else {

                        _self.jobInProg[_self.corepacSelected] = true;

                        if (_self.rstOnStart[_self.corepacSelected]) {
                            var data = ["", "", "", ""];

                            // Update table display
                            _self.table_init_uc3(data);
                            _self.uc3_tdata[_self.corepacSelected] = JSON.parse(JSON.stringify(data));
                        }

                        _self._profile_start_uc3().then(function () {

                            console.log("_onStart_uc3() passed");

                            // Change the button from START button to STOP button
                            _self.update_start_stop_btn('#start_button_uc3', true);
                            _self.uc3_startStatus[_self.corepacSelected] = true;
                            return resolve("success");

                        }).catch(function (err) {

                            // Set the flag to indicate job not in progress
                            _self.jobInProg[_self.corepacSelected] = false;

                            console.log("_onStart_uc3() failed: " + err.toString());
                            return reject(err);
                        });
                    }
                });
            },

            /////////////////////////////////////////////////////////
            // _profile_start_uc3
            /////////////////////////////////////////////////////////
            _profile_start_uc3: function () {
                var _self = this;

                var p = [];

                return new Promise(function (resolve, reject) {
                    p[0] = _self._profile_l1_start_uc3();

                    /* Wait for all the start operations to finish */
                    Promise.all(p).then(function (retObj) {
                        console.log("_profile_start_uc3() passed");
                        return resolve(retObj);
                    }).catch(function (err) {
                        return reject("_profile_start_uc3() failed:" + err.toString());
                    });
                });
            },

            /////////////////////////////////////////////////////////
            // _profile_l1_start_uc3()
            //
            // Configure and enable all counters in CorePac needed for L1 cache benchmarking
            /////////////////////////////////////////////////////////
            _profile_l1_start_uc3: function () {
                var _self = this;

                var core_names = _self.cpuFullNames[_self.corepacSelected];
                var p = [];

                if (_self.corepacInfo[_self.corepacSelected].type == "armv8") { /* A53/A72 Corepac */
                    var num_cores = _self.corepacInfo[_self.corepacSelected].num_cores;
                    var j = 0;
                    for (var i = 0; i < num_cores; i++) {
                        /* Configure PMU counters for ARM core L1 data and instruction cache TLB hit/miss */
                        p[j] = _self._profile_arm_pmu_start(core_names[i], 0, "Level 1 instruction TLB refill"); // L1 instruction TLB miss count
                        p[j + 1] = _self._profile_arm_pmu_start(core_names[i], 1, "Level 1 instruction cache access"); // L1 instruction cache total count
                        p[j + 2] = _self._profile_arm_pmu_start(core_names[i], 2, "Level 1 data TLB refill"); // L1 data TLB miss count
                        p[j + 3] = _self._profile_arm_pmu_start(core_names[i], 3, "Data memory access");//Total data access count
                        j += 4;
                    }
                } else if (_self.corepacInfo[i].type == "c7x") { // This is for C7x CorePac
                    /*  placeholder for now */
                }

                return Promise.all(p);
            },


            /////////////////////////////////////////////////////////
            // _onStop_uc3 -- called when STOP button is clicked
            /////////////////////////////////////////////////////////
            _onStop_uc3: function () {
                var _self = this;

                var data = [];
                //var length = 0;
                //var cnt_id = 0;

                if (_self.jobInProg[_self.corepacSelected]) {

                    /* Mark the job as finished */
                    _self.jobInProg[_self.corepacSelected] = false;

                    /* Stop the profiling function and fetch the counter values for table update */
                    _self._profile_stop_uc3().then(function () {


                        // Change the button from STOP button to START button
                        _self.update_start_stop_btn('#start_button_uc3', false);
                        _self.uc3_startStatus[_self.corepacSelected] = false;

                        /* Post Processing with returned counter data */
                        data = _self._post_process_uc3();

                        /* Update the table display with the new counter values */
                        _self.table_init_uc3(data);
                        _self.uc3_tdata[_self.corepacSelected] = JSON.parse(JSON.stringify(data));

                        /* Pop up a warning if there is any overflow in ARM PMU counters */
                        if (_self.armPmu_alert != "") {
                            alert(_self.armPmu_alert);
                            /* reset alert after prompt */
                            _self.armPmu_alert = "";
                        }


                        console.log("_onStop_uc3() passed");

                    }).catch(function (err) {
                        /* Mark the job as not finished */
                        _self.jobInProg[_self.corepacSelected] = true;

                        console.log("_onStop_uc3() failed: " + err.toString());

                    });
                }
            },


            /////////////////////////////////////////////////////////
            // _profile_stop_uc3()
            /////////////////////////////////////////////////////////
            _profile_stop_uc3: function () {
                var _self = this;

                var p = [];

                p[0] = _self._profile_l1_stop_uc3();

                return Promise.all(p);
            },

            /////////////////////////////////////////////////////////
            // _profile_l1_stop_uc3()
            /////////////////////////////////////////////////////////
            _profile_l1_stop_uc3: function () {
                var _self = this;

                var core_names = _self.cpuFullNames[_self.corepacSelected];
                var p = [];

                if (_self.corepacInfo[_self.corepacSelected].type == "armv8") { /* A53/A72 Corepac */
                    var num_cores = _self.corepacInfo[_self.corepacSelected].num_cores;
                    var j = 0;
                    for (var i = 0; i < num_cores; i++) {
                        /* Configure PMU counters for ARM core L1 data and instruction cache */
                        p[j] = _self._profile_arm_pmu_stop(core_names[i], 0); // L1 instruction TLB miss count
                        p[j + 1] = _self._profile_arm_pmu_stop(core_names[i], 1); // L1 instruction cache total count
                        p[j + 2] = _self._profile_arm_pmu_stop(core_names[i], 2); // L1 data TLB miss count
                        p[j + 3] = _self._profile_arm_pmu_stop(core_names[i], 3); // data total count
                        j += 4;

                    }
                } else if (_self.corepacInfo[i].type == "c7x") { // This is for C7x CorePac
                    /*  placeholder for now */
                }

                return Promise.all(p);
            },


            /////////////////////////////////////////////////////////
            // _post_process_uc3()
            /////////////////////////////////////////////////////////
            _post_process_uc3: function () {
                var _self = this;

                var l1_data = [];

                l1_data = _self._post_process_l1_uc3();

                return l1_data;
            },

            /////////////////////////////////////////////////////////
            // _post_process_l1_uc3()
            /////////////////////////////////////////////////////////
            _post_process_l1_uc3: function () {
                var _self = this;

                var data = [];
                var l1p_total = [];
                var l1p_tlb_miss = [];
                var l1d_total = [];
                var l1d_tlb_miss = [];
                var j = 0;

                var num_cores = _self.corepacInfo[_self.corepacSelected].num_cores;
                var core_names = _self.cpuFullNames[_self.corepacSelected];

                for (var i = 0; i < num_cores; i++) {
                    var obj;

                    /* Get L1 instruction TLB miss count */
                    obj = _self._get_arm_counter(core_names[i], 0);
                    if (obj.found) {
                        l1p_tlb_miss[i] = obj.cntval;
                        if (obj.ovfl == "TRUE") {
                            _self.armPmu_alert += core_names[i] + ": Counter used for L1 instruction TLB miss has overflowed;\n";
                        }
                    }

                    /* Get L1 instruction Total Access count */
                    obj = _self._get_arm_counter(core_names[i], 1);
                    if (obj.found) {
                        l1p_total[i] = obj.cntval;
                        if (obj.ovfl == "TRUE") {
                            _self.armPmu_alert += core_names[i] + ": Counter used for L1 instruction cache total access has overflowed;\n";
                        }
                    }

                    /* Get L1 data TLB miss count */
                    obj = _self._get_arm_counter(core_names[i], 2);
                    if (obj.found) {
                        l1d_tlb_miss[i] = obj.cntval;
                        if (obj.ovfl == "TRUE") {
                            _self.armPmu_alert += core_names[i] + ": Counter used for L1 data TLB miss has overflowed;\n";
                        }
                    }

                    /* Get Data Total Access count */
                    obj = _self._get_arm_counter(core_names[i], 3);
                    if (obj.found) {
                        l1d_total[i] = obj.cntval;
                        if (obj.ovfl == "TRUE") {
                            _self.armPmu_alert += core_names[i] + ": Counter used for data access total has overflowed;\n";
                        }
                    }

                    /* Core #i L1 instruction TLB hit percentage */
                    if (l1p_total[i] == 0) {
                        data[j] = "No Cache Activity";
                    } else {
                        data[j] = ((l1p_total[i] - l1p_tlb_miss[i]) * 100 / l1p_total[i]).toFixed(2) + "%";
                    }

                    /* Core #i L1 data TLB hit percentage */
                    if (l1d_total[i] == 0) {
                        data[j + 1] = "No Cache Activity";
                    } else {
                        data[j + 1] = ((l1d_total[i] - l1d_tlb_miss[i]) * 100 / l1d_total[i]).toFixed(2) + "%";
                    }

                    j += 2;

                }

                return data;

            },

            //////////////////////////////////////////////////////// JavaScript source code specific to usecase 4 /////////////////////////////////////////////////////////////


            /////////////////////////////////////////////////////////
            // initialization for usecase4
            /////////////////////////////////////////////////////////
            init_uc4: function () {
                var _self = this;
                var data = ["", ""];

                // table header
                _self.uc4_th0 = "CPU Name";
                _self.uc4_th1 = "CPU Performance Benchmark (Instruction/Cycle)";

                // Initialize the table display
                _self.table_init_uc4(data);

            },


            table_init_uc4: function (data) {
                var _self = this;
                var tableItems = [];
                var obj;

                if ((_self.devId == _self.deviceID1) || (_self.devId == _self.deviceID3) || (_self.devId == _self.deviceID4) || (_self.devId == _self.deviceID5) || (_self.devId == _self.deviceID6) || (_self.devId == _self.deviceID7)) {
                    //var cache_name;

                    for (var j = 0; j < _self.corepacInfo[_self.corepacSelected].num_cores; j++) {
                        obj = {"col1": "", "col2": ""};
                        obj.col1 = _self.mycpuNames[_self.corepacSelected][j];
                        obj.col2 = data[j];
                        tableItems.push(obj);
                    }
                } else { // other device
                    obj = {"col1": "", "col2": ""};
                    tableItems.push(obj);
                    tableItems.push(obj);
                }

                /* Update the table */
                _self.uc4_tableItems = JSON.parse(JSON.stringify(tableItems));

            },

            /////////////////////////////////////////////////////////
            // _onStart_uc4_hdlr -- called when START button is clicked
            /////////////////////////////////////////////////////////
            _onStart_uc4_hdlr: function () {
                var _self = this;

                /* if job not started yet, then start the job */
                if (!_self.uc4_startStatus[_self.corepacSelected]) {

                    _self._onStart_uc4().then(function () {
                        console.log("_onStart_uc4_hdlr() passed");
                        if (_self.start_alert[_self.corepacSelected] != "") {
                            alert(_self.start_alert[_self.corepacSelected]);
                            /* reset the alert after it has been prompted */
                            _self.start_alert[_self.corepacSelected] = "";
                        }
                    }).catch(function (err) {
                        console.log("_onStart_uc4_hdlr() failed:" + err.toString());
                    });
                } else { /* if job already started, then stop the job */
                    _self._onStop_uc4();
                }

            },

            /////////////////////////////////////////////////////////
            // _onStart_uc4
            /////////////////////////////////////////////////////////
            _onStart_uc4: function () {
                var _self = this;
                _self.start_alert[_self.corepacSelected] = "";

                return new Promise(function (resolve, reject) {

                    // This use case cannot be started on either of the following conditions:
                    // 1) If other use case is in progress on the same corepac cores (meaning ARM PMU counters are not available)
                    if (_self.jobInProg[_self.corepacSelected]) { //case #1 above
                        _self.start_alert[_self.corepacSelected] = "This use case cannot be started because the other use case is in progress on the same CorePac cores using the shared PMU counters.";
                        return resolve("success");
                    } else {

                        _self.jobInProg[_self.corepacSelected] = true;

                        if (_self.rstOnStart[_self.corepacSelected]) {
                            var data = ["", ""];

                            // Update table display
                            _self.table_init_uc4(data);
                            _self.uc4_tdata[_self.corepacSelected] = JSON.parse(JSON.stringify(data));
                        }

                        _self._profile_start_uc4().then(function () {

                            console.log("_onStart_uc4() passed");

                            // Change the button from START button to STOP button
                            _self.update_start_stop_btn('#start_button_uc4', true);
                            _self.uc4_startStatus[_self.corepacSelected] = true;
                            return resolve("success");
                        }).catch(function (err) {

                            // Set the flag to indicate job not in progress
                            _self.jobInProg[_self.corepacSelected] = false;

                            console.log("_onStart_uc4() failed: " + err.toString());
                            return reject(err);
                        });
                    }
                });
            },

            /////////////////////////////////////////////////////////
            // _profile_start_uc4
            /////////////////////////////////////////////////////////
            _profile_start_uc4: function () {
                var _self = this;

                var p = [];

                return new Promise(function (resolve, reject) {
                    p[0] = _self._profile_l1_start_uc4();

                    /* Wait for all the start operations to finish */
                    Promise.all(p).then(function (retObj) {
                        console.log("_profile_start_uc4() passed");
                        return resolve(retObj);
                    }).catch(function (err) {
                        return reject("_profile_start_uc4() failed:" + err.toString());
                    });
                });
            },

            /////////////////////////////////////////////////////////
            // _profile_l1_start_uc4()
            //
            // Configure and enable all counters in CorePac needed for L1 cache benchmarking
            /////////////////////////////////////////////////////////
            _profile_l1_start_uc4: function () {
                var _self = this;

                var core_names = _self.cpuFullNames[_self.corepacSelected];
                var p = [];

                if (_self.corepacInfo[_self.corepacSelected].type == "armv8") { /* A53/A72 Corepac */
                    var num_cores = _self.corepacInfo[_self.corepacSelected].num_cores;
                    var j = 0;
                    for (var i = 0; i < num_cores; i++) {
                        /* Configure PMU counters for ARM core instruction count and cycle count */
                        p[j] = _self._profile_arm_pmu_start(core_names[i], 0, "Instruction architecturally executed"); // this is the count for cacheable access
                        p[j + 1] = _self._profile_arm_pmu_start(core_names[i], 1, "Cycle"); // this is the cycle count
                        j += 2;
                    }
                } else if (_self.corepacInfo[i].type == "c7x") { // This is for C7x CorePac
                    /*  placeholder for now */
                }

                return Promise.all(p);
            },


            /////////////////////////////////////////////////////////
            // _onStop_uc4 -- called when STOP button is clicked
            /////////////////////////////////////////////////////////
            _onStop_uc4: function () {
                var _self = this;

                var data = [];
                //var length = 0;
                //var cnt_id = 0;

                if (_self.jobInProg[_self.corepacSelected]) {

                    /* Mark the job as finished */
                    _self.jobInProg[_self.corepacSelected] = false;

                    /* Stop the profiling function and fetch the counter values for table update */
                    _self._profile_stop_uc4().then(function () {

                        // Change the button from STOP button to START button
                        _self.update_start_stop_btn('#start_button_uc4', false);
                        _self.uc4_startStatus[_self.corepacSelected] = false;

                        /* Post Processing with returned counter data */
                        data = _self._post_process_uc4();

                        /* Update the table display with the new counter values */
                        _self.table_init_uc4(data);
                        _self.uc4_tdata[_self.corepacSelected] = JSON.parse(JSON.stringify(data));

                        /* Pop up a warning if there is any overflow in ARM PMU counters */
                        if (_self.armPmu_alert != "") {
                            alert(_self.armPmu_alert);
                            /* reset alert after prompt */
                            _self.armPmu_alert = "";
                        }

                        console.log("_onStop_uc4() passed");

                    }).catch(function (err) {
                        /* Mark the job as not finished */
                        _self.jobInProg[_self.corepacSelected] = true;

                        console.log("_onStop_uc4() failed: " + err.toString());

                    });
                }
            },


            /////////////////////////////////////////////////////////
            // _profile_stop_uc4()
            /////////////////////////////////////////////////////////
            _profile_stop_uc4: function () {
                var _self = this;

                var p = [];

                p[0] = _self._profile_l1_stop_uc4();

                return Promise.all(p);
            },

            /////////////////////////////////////////////////////////
            // _profile_l1_stop_uc4()
            /////////////////////////////////////////////////////////
            _profile_l1_stop_uc4: function () {
                var _self = this;

                var core_names = _self.cpuFullNames[_self.corepacSelected];
                var p = [];

                if (_self.corepacInfo[_self.corepacSelected].type == "armv8") { /* A53/A72 Corepac */
                    var num_cores = _self.corepacInfo[_self.corepacSelected].num_cores;
                    var j = 0;
                    for (var i = 0; i < num_cores; i++) {
                        /* Configure PMU counters for ARM core L1 data and instruction cache */
                        p[j] = _self._profile_arm_pmu_stop(core_names[i], 0); // this is the instruction count
                        p[j + 1] = _self._profile_arm_pmu_stop(core_names[i], 1); // this is the cycle count
                        j += 2;
                    }
                } else if (_self.corepacInfo[i].type == "c7x") { // This is for C7x CorePac
                    /*  placeholder for now */
                }

                return Promise.all(p);
            },

            /////////////////////////////////////////////////////////
            // _post_process_uc4()
            /////////////////////////////////////////////////////////
            _post_process_uc4: function () {
                var _self = this;

                var data = [];
                var inst_cnt = [];
                var cycle_cnt = [];

                var num_cores = _self.corepacInfo[_self.corepacSelected].num_cores;
                var core_names = _self.cpuFullNames[_self.corepacSelected];

                for (var i = 0; i < num_cores; i++) {
                    var obj;

                    /* Get the instruction count */
                    obj = _self._get_arm_counter(core_names[i], 0);
                    if (obj.found) {
                        inst_cnt[i] = obj.cntval;
                        if (obj.ovfl == "TRUE") {
                            _self.armPmu_alert += core_names[i] + ": Counter used for Instruction count has overflowed;\n";
                        }
                    }

                    /* Get cycle count */
                    obj = _self._get_arm_counter(core_names[i], 1);
                    if (obj.found) {
                        cycle_cnt[i] = obj.cntval;
                        if (obj.ovfl == "TRUE") {
                            _self.armPmu_alert += core_names[i] + ": Counter used for Cycle count has overflowed;\n";
                        }
                    }

                    /* Core #i Instruction Per Cycle */
                    if (cycle_cnt[i] == 0) {
                        data[i] = "No data (Check if CPU is running)";
                    } else {
                        data[i] = (inst_cnt[i] / cycle_cnt[i]).toFixed(2);
                    }
                }

                return data;

            },

            /////////////////////////////////////////////////////////
            // _onStart_uc1_hdlr_c7 -- called when START/STOP button is clicked
            /////////////////////////////////////////////////////////
            _onStart_uc1_hdlr_c7: function () {
                var _self = this;

                /* if job not started yet, then start the job */
                if (!_self.uc1_startStatus[_self.corepacSelected]) {

                    _self._onStart_uc1_c7().then(function () {
                        console.log("_onStart_uc1_hdlr_c7() passed");
                        if (_self.start_alert[_self.corepacSelected] != "") {
                            alert(_self.start_alert[_self.corepacSelected]);
                            /* reset the alert after it has been prompted */
                            _self.start_alert[_self.corepacSelected] = "";
                        }
                    }).catch(function (err) {
                        console.log("_onStart_uc1_hdlr_c7() failed:" + err.toString());
                    });
                } else { /* if job already started, then stop the job */
                    _self._onStop_uc1_c7();
                }

            },

            /////////////////////////////////////////////////////////
            // _onStart_uc1_c7
            /////////////////////////////////////////////////////////
            _onStart_uc1_c7: function () {
                var _self = this;

                _self.start_alert[_self.corepacSelected] = "";

                return new Promise(function (resolve, reject) {

                    // This use case cannot be started on either of the following conditions:
                    // 1) If other use case is in progress on the same c7x cores (meaning the related corepac CTSET2 counters are not available)
                    // 2) If the same use case is in progress on the other corepac cores (meaning MSMC CTSET2 is not available for L3 cache benchmarking)
                    if (_self.jobInProg[_self.corepacSelected]) { //case #1 above
                        _self.start_alert[_self.corepacSelected] = "This use case cannot be started because the other use case is in progress on the same CorePac cores using the shared corepac CTSET2 counters.";
                        return resolve("success");
                    } else if (_self.msmc_ctset2_inuse) { // Case #2 above
                        _self.start_alert[_self.corepacSelected] = "This use case cannot be started because the same use case is in progress on the other CorePac cores using the shared CTSET2 resource.";
                        return resolve("success");
                    } else {

                        _self.jobInProg[_self.corepacSelected] = true;
                        _self.msmc_ctset2_inuse = true;

                        if (_self.rstOnStart[_self.corepacSelected]) {
                            var data = ["", "", ""];

                            // Initialize C7x CTSET2 counter values for L1/L2
                            _self._c7_cnt_reset();

                            // Initialize L3 counter values
                            _self._l3_cnt_reset();

                            // Update table display
                            _self.table_init_uc1(data);
                            _self.uc1_tdata[_self.corepacSelected] = JSON.parse(JSON.stringify(data));
                        }

                        _self.connect_msmc_ctset2();
                        _self.connect_c7x_ctset2();
                        _self._profile_start_uc1_c7().then(function () {
                            console.log("_onStart_uc1_c7() passed");

                            // Change the button from START to STOP.
                            _self.update_start_stop_btn('#start_button_uc1_c7', true);
                            _self.uc1_startStatus[_self.corepacSelected] = true;
                            return resolve("success");


                        }).catch(function (err) {
                            // Set the flag to indicate job failed
                            _self.jobInProg[_self.corepacSelected] = false;
                            _self.msmc_ctset2_inuse = false;

                            console.log(err.toString());
                            return reject(err);

                        });
                    }
                });
            },

            /////////////////////////////////////////////////////////
            // _profile_start_uc1_c7
            /////////////////////////////////////////////////////////
            _profile_start_uc1_c7: function () {
                var _self = this;

                var p = [];

                return new Promise(function (resolve, reject) {
                    // Before we start the job, update the L1P/L1D selection in case it was changed during last job run
                    if (_self.c7x_l1sel != _self.c7x_l1sel_flag) {
                        _self.c7x_l1sel = _self.c7x_l1sel_flag;

                        var data = ["", "", ""]
                        // Update the table display
                        _self.table_init_uc1(data);
                    }
                    if (_self.c7x_l1sel === "L1P")
                        p[0] = _self._profile_l1pl2_start_uc1_c7();
                    else
                        p[0] = _self._profile_l1dl2_start_uc1_c7();

                    p[1] = _self._profile_l3_start_uc1();

                    /* Wait for all the start operations to finish */
                    Promise.all(p).then(function (retObj) {
                        console.log("_profile_start_uc1_c7() passed");
                        return resolve(retObj);
                    }).catch(function (err) {
                        return reject("_profile_start_uc1_c7() failed:" + err.toString());
                    });
                });
            },

            /////////////////////////////////////////////////////////
            // _onStop_uc1_c7 -- called when STOP button is clicked
            /////////////////////////////////////////////////////////
            _onStop_uc1_c7: function () {
                var _self = this;

                var data = [];

                if (_self.jobInProg[_self.corepacSelected]) {

                    /* Mark the job as finished */
                    _self.jobInProg[_self.corepacSelected] = false;
                    _self.msmc_ctset2_inuse = false;

                    /* Stop the profiling function and fetch the counter values for table update */
                    _self._profile_stop_uc1_c7().then(function () {

                        /* Change the button from STOP to START button */
                        _self.update_start_stop_btn('#start_button_uc1_c7', false);
                        _self.uc1_startStatus[_self.corepacSelected] = false;


                        /* Post Processing with returned counter data */
                        data = _self._post_process_uc1_c7();

                        /* Save off the returned counter data */
                        if (_self.c7x_l1sel === "L1P")
                            _self.uc1data_c7l1p = data;
                        else
                            _self.uc1data_c7l1d = data;

                        /* Update the table display with the new counter values */
                        _self.table_init_uc1(data);
                        _self.uc1_tdata[_self.corepacSelected] = JSON.parse(JSON.stringify(data));

                        /* Pop up a warning if there is any overflow in C7x CTSET2 or MSMC CTSET2 counters */
                        if (_self.ctset2_alert_c7 != "") {
                            alert(_self.ctset2_alert_c7);
                            /* reset alert after prompt */
                            _self.ctset2_alert_c7 = "";
                        }
                        if (_self.ctset2_alert != "") {
                            alert(_self.ctset2_alert);
                            /* reset alert after prompt */
                            _self.ctset2_alert = "";
                        }


                        console.log("_onStop_uc1_c7() passed");

                    }).catch(function (err) {
                        /* Mark the job as not finished */
                        _self.jobInProg[_self.corepacSelected] = true;
                        _self.msmc_ctset2_inuse = true;


                        console.log("_onStop_uc1_c7() failed: " + err.toString());

                    });

                }
            },
            /////////////////////////////////////////////////////////
            // _profile_stop_uc1_c7()
            /////////////////////////////////////////////////////////
            _profile_stop_uc1_c7: function () {
                var _self = this;

                var p = [];

                p[0] = _self._profile_l1l2_stop_uc1_c7();
                p[1] = _self._profile_l3_stop_uc1();

                return Promise.all(p);
            },
            /////////////////////////////////////////////////////////
            // _profile_c7x_l1pl2_start_uc1()
            //
            // Configure and enable all MSMC CTSET2 counters needed for L3 cache benchmarking
            /////////////////////////////////////////////////////////
            _profile_l1pl2_start_uc1_c7: function () {
                var _self = this;

                var p_ctset2 = [];


                /* Config and start all the CTSET2 counters needed for C7x L1 and L2 cache benchmarking */

                /* L1P */
                p_ctset2[0] = _self._profile_c7x_ctset2_start(0, "32 Bit", "Edge", "Hit L1P Cache");
                p_ctset2[1] = _self._profile_c7x_ctset2_start(1, "32 Bit", "Edge", "Missed L1P Cache");

                /* L2 */
                p_ctset2[2] = _self._profile_c7x_ctset2_start(2, "32 Bit", "Edge", "Hit L2 Cache");
                p_ctset2[3] = _self._profile_c7x_ctset2_start(3, "32 Bit", "Edge", "Missed L2 Cache with silent or no eviction");
                p_ctset2[4] = _self._profile_c7x_ctset2_start(4, "32 Bit", "Edge", "Missed L2 Cache with victim writeback");

                _self.num_ctset2_cnt_c7 = 5;

                /* Wait for all the CTSET2 start operations to finish */
                return Promise.all(p_ctset2);

            },
            /////////////////////////////////////////////////////////
            // _profile_c7x_l1dl2_start_uc1()
            //
            // Configure and enable all MSMC CTSET2 counters needed for L3 cache benchmarking
            /////////////////////////////////////////////////////////
            _profile_l1dl2_start_uc1_c7: function () {
                var _self = this;

                var p_ctset2 = [];


                /* Config and start all the CTSET2 counters needed for C7x L1 and L2 cache benchmarking */

                /* L1D */
                p_ctset2[0] = _self._profile_c7x_ctset2_start(0, "32 Bit", "Edge", "DP0:Hit L1D Main Cache RAM");
                p_ctset2[1] = _self._profile_c7x_ctset2_start(1, "32 Bit", "Edge", "DP1:Hit L1D Main Cache RAM");
                p_ctset2[2] = _self._profile_c7x_ctset2_start(2, "32 Bit", "Edge", "DP0:Hit L1D Victim Cache");
                p_ctset2[3] = _self._profile_c7x_ctset2_start(3, "32 Bit", "Edge", "DP1:Hit L1D Victim Cache");

                /* L2 */
                p_ctset2[4] = _self._profile_c7x_ctset2_start(4, "32 Bit", "Edge", "Hit L2 Cache");
                p_ctset2[5] = _self._profile_c7x_ctset2_start(5, "32 Bit", "Edge", "Missed L2 Cache with silent or no eviction");
                p_ctset2[6] = _self._profile_c7x_ctset2_start(6, "32 Bit", "Edge", "Missed L2 Cache with victim writeback");

                _self.num_ctset2_cnt_c7 = 7;

                /* Wait for all the CTSET2 start operations to finish */
                return Promise.all(p_ctset2);

            },
            /////////////////////////////////////////////////////////
            // _profile_c7x_ctset2_start()
            //
            // Configure and enable CTSET2 counter in C7x Corepac
            /////////////////////////////////////////////////////////
            _profile_c7x_ctset2_start: function (cnt_id, cnt_size, evt_detect, evt_to_count) {
                var _self = this;

                var aetopHandle;
                var i;
                var ctset2_prop_setval;
                var ctset2_prop_getval;

                /* Initialize the CTSET2 counter overflow alert text */
                _self.ctset2_alert_c7 = "";

                var ctset2_name = _self.emulator + "/" + "CTSET2_1"; //HX, to-do, hard code for now for deviceID3, need to revisit

                return new Promise(function (resolve, reject) {
                    /* Create the AET operation server for CTSET2 */
                    _self.ta.cloudTrace.createOperation(ctset2_name, "AET").then(function (retObj) {
                        /* save the AET operation handle for later use */
                        aetopHandle = retObj.handle;
                        console.log("C7x CTSET2 Counter " + cnt_id + " operation created: id = " + aetopHandle);
                        return retObj;
                    }).then(function () {
                        // Get the property tree for CTSET2 counter
                        return _self.ta.cloudTrace.getProperties(aetopHandle);
                    }).then(function (retObj) {
                        ctset2_prop_setval = retObj.cfg;
                        var ctset2_prop = ctset2_prop_setval[0];

                        // Modify the properties for CTSET2 counter
                        for (i = 0; i < ctset2_prop.sub_properties.length; i++) {
                            if (ctset2_prop.sub_properties[i].name === "Counter Size") {
                                ctset2_prop.sub_properties[i].value = cnt_size;
                            } else if (ctset2_prop.sub_properties[i].name === "Event Detection Type") {
                                ctset2_prop.sub_properties[i].value = evt_detect;
                            } else if (ctset2_prop.sub_properties[i].name === "Event to Count") {
                                ctset2_prop.sub_properties[i].value = evt_to_count;
                            }
                        }

                        // Set the C7x ctset2 properties
                        return _self.ta.cloudTrace.setProperties(aetopHandle, ctset2_prop_setval);
                    }).then(function () {
                        // Get the C7x ctset2 properties again
                        return _self.ta.cloudTrace.getProperties(aetopHandle);
                    }).then(function (retObj) {
                        // Confirm the new ctset2 counter properties have been set correctly
                        ctset2_prop_getval = retObj.cfg;
                        if (JSON.stringify(ctset2_prop_getval) === JSON.stringify(ctset2_prop_setval)) {
                            console.log("setProperties() passed");
                            // Enable the AET operation for CTSET2
                            return _self.ta.cloudTrace.setEnableOperation(aetopHandle, true);
                        } else {
                            console.log("setProperties() failed");
                            return reject("setProperties() failed");
                        }
                    }).then(function (retObj) {
                        console.log("C7x CTSET2 Counter " + cnt_id + " operation enabled");
                        return retObj;
                    }).then(function (retObj) {
                        _self.ctset2AetHndl_c7[cnt_id] = aetopHandle;
                        console.log("_profile_c7x_ctset2_start() passed: cnt_id = " + cnt_id);
                        return resolve(retObj);
                    }).catch(function (err) {
                        _self.ctset2AetHndl_c7[cnt_id] = null;
                        return reject("_profile_c7x_ctset2_start() failed: cnt_id = " + cnt_id + err.toString());
                    });
                });
            },

            /////////////////////////////////////////////////////////
            // _profile_c7x_ctset2_stop()
            // Get the CTSET2 counter values and then disable the counters
            /////////////////////////////////////////////////////////
            _profile_c7x_ctset2_stop: function (cnt_id) {

                var _self = this;

                var aetopHandle = _self.ctset2AetHndl_c7[cnt_id];

                return new Promise(function (resolve, reject) {

                    _self.ta.cloudTrace.getProperties(aetopHandle).then(function (retObj) {
                        /* Get the current count value and overflow value */
                        var ctset2_prop = retObj.cfg[0];

                        for (var i = 0; i < ctset2_prop.sub_properties.length; i++) {
                            if (ctset2_prop.sub_properties[i].name === "Current Count") {
                                if (_self.rstOnStart[_self.corepacSelected])
                                    _self.ctset2Cnt_c7[cnt_id] = ctset2_prop.sub_properties[i].value;
                                else
                                    _self.ctset2Cnt_c7[cnt_id] += ctset2_prop.sub_properties[i].value;
                            } else if (ctset2_prop.sub_properties[i].name === "Overflow") {
                                _self.ctset2Ovfl_c7[cnt_id] = ctset2_prop.sub_properties[i].value;
                            }
                        }
                        console.log("C7x CTSET2 Counter " + cnt_id + " Count Value: " + _self.ctset2Cnt_c7[cnt_id] + ", Overflow: " + _self.ctset2Ovfl_c7[cnt_id]);
                        /* Disable the counter */
                        return _self.ta.cloudTrace.setEnableOperation(aetopHandle, false);
                    }).then(function () {
                        console.log("C7x CTSET2 Counter " + cnt_id + " operation disabled");
                        /* Release the AET operation */
                        return _self.ta.cloudTrace.releaseOperation(aetopHandle);
                    }).then(function (retObj) {
                        console.log("C7x CTSET2 Counter " + cnt_id + " operation released");
                        _self.ctset2AetHndl_c7[cnt_id] = null;
                        console.log("_profile_c7x_ctset2_stop() passed: cnt_id = " + cnt_id);
                        return resolve(retObj);
                    }).catch(function (err) {
                        _self.ctset2AetHndl_c7[cnt_id] = null;
                        return reject("_profile_c7x_ctset2_stop() failed: cnt_id = " + cnt_id + err.toString());
                    });
                });
            },
            /////////////////////////////////////////////////////////
            // _profile_l1l2_stop_uc1_c7()
            // Stop all the CTSET2 counters for C7x L1 and L2 cache benchmarking
            /////////////////////////////////////////////////////////
            _profile_l1l2_stop_uc1_c7: function () {
                var _self = this;

                var p_ctset2 = [];

                /* Stop all the CTSET2 counters */
                for (var i = 0; i < _self.num_ctset2_cnt_c7; i++) {
                    p_ctset2[i] = _self._profile_c7x_ctset2_stop(i);
                }

                /* Wait for all the counter stop operations to finish */
                return Promise.all(p_ctset2);
            },
            /////////////////////////////////////////////////////////
            // _post_process_uc1_c7()
            /////////////////////////////////////////////////////////
            _post_process_uc1_c7: function () {
                var _self = this;

                var l3_data;
                var l1_data = [];
                var data = [];

                if (_self.c7x_l1sel === "L1P")
                    l1_data = _self._post_process_l1pl2_uc1_c7();
                else
                    l1_data = _self._post_process_l1dl2_uc1_c7();

                l3_data = _self._post_process_l3_uc1();

                /* Combine all the data and return */
                data = l1_data.concat(l3_data);

                return data;
            },

            /////////////////////////////////////////////////////////
            // _post_process_l1pl2_uc1_c7()
            // Post Processing for C7x L1P and L2 data
            /////////////////////////////////////////////////////////
            _post_process_l1pl2_uc1_c7: function () {
                var _self = this;

                var data_l1p, data_l2;
                var cacheHitCnt_l1p, cacheHitCnt_l2;
                var cacheableCnt_l1p, cacheableCnt_l2;


                /* Update the L1P data for CTSET2 */
                cacheHitCnt_l1p = _self.ctset2Cnt_c7[0];
                cacheableCnt_l1p = _self.ctset2Cnt_c7[0] + _self.ctset2Cnt_c7[1];

                if (cacheableCnt_l1p == 0) {
                    data_l1p = "No Cache Activity";
                } else {
                    data_l1p = (cacheHitCnt_l1p * 100 / cacheableCnt_l1p).toFixed(2) + "%";
                }

                /* Update the L2 data for CTSET2 */
                cacheHitCnt_l2 = _self.ctset2Cnt_c7[2];
                cacheableCnt_l2 = _self.ctset2Cnt_c7[2] + _self.ctset2Cnt_c7[3] + _self.ctset2Cnt_c7[4];

                if (cacheableCnt_l2 == 0) {
                    data_l2 = "No Cache Activity";
                } else {
                    data_l2 = (cacheHitCnt_l2 * 100 / cacheableCnt_l2).toFixed(2) + "%";
                }

                /* Update the overflow status for CTSET2*/
                for (var i = 0; i < _self.num_ctset2_cnt_c7; i++) {
                    if (_self.ctset2Ovfl_c7[i] == "overflowed")
                        _self.ctset2_alert_c7 += "CTSET2 Counter " + i + " used for L1P Cache benchmarking has overflowed;\n";
                }

                return [data_l1p, data_l2];
            },

            /////////////////////////////////////////////////////////
            // _post_process_l1dl2_uc1_c7()
            // Post Processing for C7x L1D and L2 data
            /////////////////////////////////////////////////////////
            _post_process_l1dl2_uc1_c7: function () {
                var _self = this;

                var data_l1d, data_l2;
                var cacheHitCnt_l1d, cacheHitCnt_l2;
                var cacheableCnt_l1d, cacheableCnt_l2;


                /* Update the L1D data for CTSET2 */
                cacheHitCnt_l1d = _self.ctset2Cnt_c7[0] + _self.ctset2Cnt_c7[1];
                cacheableCnt_l1d = _self.ctset2Cnt_c7[0] + _self.ctset2Cnt_c7[1] + _self.ctset2Cnt_c7[2] + _self.ctset2Cnt_c7[3];

                if (cacheableCnt_l1d == 0) {
                    data_l1d = "No Cache Activity";
                } else {
                    data_l1d = (cacheHitCnt_l1d * 100 / cacheableCnt_l1d).toFixed(2) + "%";
                }

                /* Update the L2 data for CTSET2 */
                cacheHitCnt_l2 = _self.ctset2Cnt_c7[4];
                cacheableCnt_l2 = _self.ctset2Cnt_c7[4] + _self.ctset2Cnt_c7[5] + _self.ctset2Cnt_c7[6];

                if (cacheableCnt_l2 == 0) {
                    data_l2 = "No Cache Activity";
                } else {
                    data_l2 = (cacheHitCnt_l2 * 100 / cacheableCnt_l2).toFixed(2) + "%";
                }

                /* Update the overflow status for CTSET2*/
                for (var i = 0; i < _self.num_ctset2_cnt_c7; i++) {
                    if (_self.ctset2Ovfl_c7[i] == "overflowed")
                        _self.ctset2_alert_c7 += "CTSET2 Counter " + i + " used for L1P Cache benchmarking has overflowed;\n";
                }

                return [data_l1d, data_l2];
            },
            /////////////////////////////////////////////////////////
            // _onStart_uc3_hdlr_c7 -- called when START button is clicked
            /////////////////////////////////////////////////////////
            _onStart_uc3_hdlr_c7: function () {
                var _self = this;

                /* if job not started yet, then start the job */
                if (!_self.uc3_startStatus[_self.corepacSelected]) {

                    _self._onStart_uc3_c7().then(function () {
                        console.log("_onStart_uc3_hdlr_c7() passed");
                        if (_self.start_alert[_self.corepacSelected] != "") {
                            alert(_self.start_alert[_self.corepacSelected]);
                            /* reset the alert after it has been prompted */
                            _self.start_alert[_self.corepacSelected] = "";
                        }
                    }).catch(function (err) {
                        console.log("_onStart_uc3_hdlr_c7() failed:" + err.toString());
                    });
                } else { /* if job already started, then stop the job */
                    _self._onStop_uc3_c7();
                }

            },

            /////////////////////////////////////////////////////////
            // _onStart_uc3_c7
            /////////////////////////////////////////////////////////
            _onStart_uc3_c7: function () {
                var _self = this;

                _self.start_alert[_self.corepacSelected] = "";

                return new Promise(function (resolve, reject) {

                    // This use case cannot be started on either of the following conditions:
                    // 1) If other use case is in progress on the same c7x cores (meaning the related corepac CTSET2 counters are not available)
                    if (_self.jobInProg[_self.corepacSelected]) { //case #1 above
                        _self.start_alert[_self.corepacSelected] = "This use case cannot be started because the other use case is in progress on the same CorePac cores using the corepac CTSET2 counters.";
                        return resolve("success");
                    } else {

                        _self.jobInProg[_self.corepacSelected] = true;

                        if (_self.rstOnStart[_self.corepacSelected]) {
                            var data = ["", "", "", "", ""];

                            // Initialize C7x CTSET2 counter values for L1/L2
                            _self._c7_cnt_reset();

                            // Update table display
                            _self.table_init_uc3(data);
                            _self.uc3_tdata[_self.corepacSelected] = JSON.parse(JSON.stringify(data));
                        }

                        _self.connect_c7x_ctset2();

                        _self._profile_start_uc3_c7().then(function () {
                            console.log("_onStart_uc3_c7() passed");

                            // Change the button from START to STOP.
                            _self.update_start_stop_btn('#start_button_uc3_c7', true);
                            _self.uc3_startStatus[_self.corepacSelected] = true;
                            return resolve("success");


                        }).catch(function (err) {
                            // Set the flag to indicate job failed
                            _self.jobInProg[_self.corepacSelected] = false;

                            console.log(err.toString());
                            return reject(err);

                        });
                    }
                });
            },

            /////////////////////////////////////////////////////////
            // _profile_start_uc3_c7
            /////////////////////////////////////////////////////////
            _profile_start_uc3_c7: function () {
                var _self = this;
                var p_ctset2 = [];


                /* Config and start all the CTSET2 counters needed for MMU TLB cache benchmarking */
                p_ctset2[0] = _self._profile_c7x_ctset2_start(0, "32 Bit", "Edge", "CMMU Instruction uTLB miss");
                p_ctset2[1] = _self._profile_c7x_ctset2_start(1, "32 Bit", "Edge", "CMMU Instruction main TLB miss");
                p_ctset2[2] = _self._profile_c7x_ctset2_start(2, "32 Bit", "Edge", "CMMU load Store Data uTLB miss");
                p_ctset2[3] = _self._profile_c7x_ctset2_start(3, "32 Bit", "Edge", "CMMU Load Store Data main TLB miss");
                p_ctset2[4] = _self._profile_c7x_ctset2_start(4, "32 Bit", "Edge", "CMMU Stage 2 TLB cache miss");

                _self.num_ctset2_cnt_c7 = 5;

                /* Wait for all the CTSET2 start operations to finish */
                return Promise.all(p_ctset2);

            },
            /////////////////////////////////////////////////////////
            // _onStop_uc3_c7 -- called when STOP button is clicked
            /////////////////////////////////////////////////////////
            _onStop_uc3_c7: function () {
                var _self = this;

                var data = [];

                if (_self.jobInProg[_self.corepacSelected]) {

                    /* Mark the job as finished */
                    _self.jobInProg[_self.corepacSelected] = false;

                    /* Stop the profiling function and fetch the counter values for table update */
                    _self._profile_stop_uc3_c7().then(function () {

                        /* Change the button from STOP to START button */
                        _self.update_start_stop_btn('#start_button_uc3_c7', false);
                        _self.uc3_startStatus[_self.corepacSelected] = false;


                        /* Post Processing with returned counter data */
                        data = _self.ctset2Cnt_c7;

                        /* Update the table display with the new counter values */
                        _self.table_init_uc3(data);
                        _self.uc3_tdata[_self.corepacSelected] = JSON.parse(JSON.stringify(data));

                        /* Pop up a warning if there is any overflow in C7x CTSET2 counters */
                        if (_self.ctset2_alert_c7 != "") {
                            alert(_self.ctset2_alert_c7);
                            /* reset alert after prompt */
                            _self.ctset2_alert_c7 = "";
                        }

                        console.log("_onStop_uc3_c7() passed");

                    }).catch(function (err) {
                        /* Mark the job as not finished */
                        _self.jobInProg[_self.corepacSelected] = true;

                        console.log("_onStop_uc3_c7() failed: " + err.toString());

                    });

                }
            },
            /////////////////////////////////////////////////////////
            // _profile_stop_uc3_c7()
            /////////////////////////////////////////////////////////
            _profile_stop_uc3_c7: function () {
                var _self = this;

                var p_ctset2 = [];

                /* Stop all the CTSET2 counters */
                for (var i = 0; i < _self.num_ctset2_cnt_c7; i++) {
                    p_ctset2[i] = _self._profile_c7x_ctset2_stop(i);
                }

                /* Wait for all the counter stop operations to finish */
                return Promise.all(p_ctset2);
            },

        });
    </script>
</dom-module>
</body>
</html>