<!DOCTYPE html>
<!--
    Copyright (c) 2019-2020, Texas Instruments Incorporated
    All rights reserved.

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:

    *   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.
    notice, this list of conditions and the following disclaimer in the
    documentation and/or other materials provided with the distribution.
    *   Neither the name of Texas Instruments Incorporated nor the names of
    its contributors may be used to endorse or promote products derived
    from this software without specific prior written permission.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
    AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
    THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
    CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
    EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
    OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
    WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
    OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
    EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<link rel="import" href="../../components/polymer/polymer.html">
<script src="../../components/webcomponentsjs/webcomponents-lite.js"></script>
<link rel="import" href="../../components/web-animations-js/web-animations.min.js">
<link rel="import" href="../../components/neon-animation/web-animations.html">
<link rel="import" href="../../components/paper-icon-button/paper-icon-button.html">
<link rel="import" href="../../components/iron-icons/av-icons.html">
<link rel="import" href="../../components/iron-icons/iron-icons.html">
<link rel="import" href="../../components/paper-dialog/paper-dialog.html">
<link rel="import" href="../ti-trace-tables/ti-trace-table.html">
<link rel="import" href="../ti-trace-model/ti-trace-model.html">
<link rel="import" href="../ti-trace-common/ti-trace-control.html">
<link rel="import" href="../ti-trace-common/ti-trace-progress.html">
<link rel="import" href="../ti-trace-common/ti-trace-search-dialog.html">
<link rel="import" href="../ti-trace-common/ti-trace-filter-action-dialog.html">
<link rel="import" href="../ti-trace-common/ti-trace-search-action-dialog.html">
<link rel="import" href="../ti-trace-config/ti-trace-config-sys.html">
<dom-module id="ti-trace-dma-ringacc">
    <template>
        <style>
            html {
                margin: 0px;
                padding: 0px;
            }
            body {
                padding: 0;
                margin: 0;
                border: 0;
            }
            .page {
                height: 100%;
                flex: 1;
                display: flex;
                align-items: stretch;
                flex-direction: column;
                overflow: auto;
                -webkit-overflow-scrolling: touch;
                font-family: "Roboto Mono";
                -ms-text-size-adjust: 100%;
                -webkit-text-size-adjust: 100%;
                font-weight: 400;
                font-size: 12px;
            }
            paper-icon-button {
                color: white;
                padding: 0px;
                height: 24px;
                width: 24px;
            }
            paper-icon-button[disabled] {
                color: lightgrey;
            }
            paper-icon-button.record {
                color: red;
                padding: 0px;
                height: 24px;
                width: 24px;
            }
            paper-icon-button.stop {
                color: black;
                padding: 0px;
                height: 24px;
                width: 24px;
            }

        </style>
        <ti-trace-model id="tm" trace-agent="{{ta}}" device-info="{{liveDeviceInfo}}"></ti-trace-model>
        <ti-trace-progress id="progress" status="[[_traceStatus]]"></ti-trace-progress>
        <ti-trace-control id="control" status="[[_traceStatus]]" on-record-changed="_recordChanged"></ti-trace-control>
        <!-- <template is="dom-if" if="[[_isActive]]"> -->
        <div class="page" id="tableDiv">
        <div class="page">
                <!-- <template is="dom-if" if="[[_tableVisible]]" restamp> -->
                    <ti-trace-table id="traceTable" class="page" table-size=[[rowCount]] column-labels="[[columnNames]]" trace-data-provider="[[_traceDataProvider]]" 
                    tooltip="Click row to highlight source and assembly" active-item="{{activeItem}}" style="display:none">
                        <span>
                            Trace Data for [[activeCore]] - [[activeSink]]: [[_rowCountText]] trace records
                        </span>
                        <span slot="right">
                            <paper-icon-button id="search" icon="search" on-tap="_search_table"></paper-icon-button>
                            <paper-tooltip for="search" position="left">Search trace table</paper-tooltip>
                            <paper-icon-button id="filter" icon="filter-list"  disabled="[[_canNotFilter]]" on-tap="_filter_table"></paper-icon-button>
                            <paper-tooltip for="filter" position="left">Filter trace table</paper-tooltip>
                            <paper-icon-button id="redo" icon="autorenew" on-tap="_restart"></paper-icon-button>
                            <paper-tooltip for="redo" position="left">Clear table and restart</paper-tooltip>
                            <paper-icon-button id="save" icon="save" disabled="[[_canNotSave]]" on-tap="_save_as_tdf"></paper-icon-button>
                            <paper-tooltip for="save" position="left">Save trace data to file</paper-tooltip>
                        </span>
                    </ti-trace-table>
                <!-- </template> -->
            </div>
        </div>
        <div id="errorDiv">
            <h1>[[_errorMessage]]</h1>
        </div>
        <ti-trace-config-sys id="traceConfig" ta="[[ta]]" out-file="[[activeOutFileName]]" device-info="[[liveDeviceInfo]]"
            core="[[activeCore]]" options="{{_options}}" trace-routes="[[traceRoutes]]" trace-route="{{traceRoute}}"
            header-text="DMA Ring Accelerator Trace" aet-property-trees="{{aetPropertyTrees}}" receiver-property-tree="{{receiverPropertyTree}}"
            get-sys-trace-core="[[getSysTraceCore]]" sys-trace-type="dmaringacc" info-dlg-message="{{_infoDlgMessage}}"
            sync-halt-cores="[[syncHaltCores]]" sync-halt-core="{{syncHaltCore}}" no-cancel>
        </ti-trace-config-sys>
        <paper-dialog id="cfgErrorDlg" modal on-opened-changed="_errorDialogChanged">
            <h2>Trace Configuration Error</h2>
            <p>[[_traceConfigurationErrorMessage]]</p>
            <div class="buttons">
                <paper-button id="cfgErrorDlgDismiss" raised dialog-dismiss>Close</paper-button>
            </div>
        </paper-dialog>
        <paper-dialog id="simpleDlg" modal>
            <div>[[_simpleDlgMessage]]</div>
            <paper-button raised dialog-dismiss autofocus>Dismiss</paper-button>
        </paper-dialog>
        <paper-dialog id="errorDlg" modal>
            <h2>Error</h2>
            <div>[[_errorDlgMessage]]</div>
            <paper-button raised dialog-dismiss autofocus>Dismiss</paper-button>
        </paper-dialog>
        <ti-trace-search-dialog id="searchDlg" header-text="Search" trace-columns="[[_traceTableColumns]]" on-opened-changed="_searchDialogChanged"></ti-trace-search-dialog>
        <ti-trace-search-dialog id="filterDlg" header-text="Filter" trace-columns="[[_traceTableColumns]]" on-opened-changed="_filterDialogChanged"></ti-trace-search-dialog>
        <ti-trace-search-action-dialog id="searchActionDlg" on-search-action="_searchAction"></ti-trace-search-action-dialog>
        <ti-trace-filter-action-dialog id="filterActionDlg" on-filter-action="_filterAction"></ti-trace-filter-action-dialog>
        <paper-dialog id="infoDlg" modal>
            <div style="padding:10px 20px">
                <template is="dom-repeat" items="[[_infoDlgMessage]]" as="line">
                    [[line]]<br>
                </template>
            </div>
            <div style="padding:10px 20px">
                <paper-button raised dialog-confirm autofocus>Dismiss</paper-button>
            </div>
        </paper-dialog>
    </template>
    <script>
        /* eslint "no-console" : "off" */
        /* global Q:false */
        Polymer({
            is: 'ti-trace-dma-ringacc',
            properties: {
                activeCore: {
                    notify: true,
                    type: String,
                    reflectToAttribute: true,
                    value: undefined,
                    observer: "_activeCoreChanged"
                },
                activeSink: {
                    type: String,
                    value: undefined
                },
                activeItem: {
                    observer: "activeItemChanged"
                },
                liveDeviceInfo : {
                    notify: true,
                    type: Object,
                    reflectToAttribute: true,
                    value: undefined,
                    observer: "_liveDeviceInfoChanged",
                },
                deviceInfo : {
                    notify: true,
                    type: Object,
                    reflectToAttribute: true,
                    value: undefined,
                    observer: "_deviceInfoChanged",
                },
                traceOp : {
                    notify: true,
                    type: Number,
                    reflectToAttribute: true,
                    value: undefined
                },
                columnNames : {
                    notify: true,
                    type: Array,
                    reflectToAttribute: true,
                    value : function() {
                        return [];
                    }
                },
                activeOutFileName : {
                    type: String,
                    value: undefined,
                    reflectToAttribute: true,
                },
                aetPropertyTrees : {
                    type: Array,
                    value: undefined
                },
                ta : {
                    notify: true,
                    type: Object,
                    reflectToAttribute: true,
                    observer: "_taChanged"
                },
                receiverPropertyTree : {
                    type: Object,
                    value: undefined,
                },
                dmaRingaccProperties : {
                    notify: true,
                    reflectToAttribute: true,
                    type: Array
                },
                rowCount : {
                    notify: true,
                    reflectToAttribute: true,
                    type: Number,
                    value : 0
                },
                _rowCountText : {
                    notify: true,
                    reflectToAttribute: true,
                    type: String,
                    value: "0"
                },
                _tableVisible: {
                    notify: true,
                    reflectToAttribute: true,
                    value: false,
                },
                _traceDataProvider: {
                    type: Function,
                    value: function () {
                        return this._nullDataProviderFunction;
                    }
                    //value: undefined
                },
                _traceStatus : {
                    notify: true,
                    reflectToAttribute: true,
                    type: String,
                    value: ""
                },
                traceRoute : {
                    type: Object,
                    value: undefined
                },
                traceRoutes : {
                    notify: true,
                    reflectToAttribute: true,
                    type: Array,
                    value: function () {
                        return [];
                    }
                },
                _errorMessage : {
                    type: String,
                    value: undefined,
                },
                _errorDlgMessage : {
                    type: String,
                    value: undefined,
                    reflectToAttribute: true,
                },
                _simpleDlgMessage : {
                    type: String,
                    value: undefined,
                    reflectToAttribute: true,
                },
                _infoDlgMessage : {
                    type: Array,
                    value: function () {return [];},
                    reflectToAttribute: true,
                    notify: true
                },
                _isActive : {
                    type: Boolean,
                    value: false,
                    observer: "_isActiveChanged",
                },
                _isLive : {
                    type: Boolean,
                    value: undefined,
                },
                _traceConfigurationErrorMessage : {
                    type: String,
                    value: "",
                },
                _options : {
                    type: Array,
                    value: undefined,
                },
                _traceTableColumns : {
                    type: Array,
                    value: function () {return [];},
                    reflectToAttribute: true,
                    notify: true,
                },
                // state variables for buttons
                _canNotSave : {
                    type: Boolean,
                    value: true,
                    reflectToAttribute: true,
                    notify: true,
                },
                _canNotFilter : {
                    type: Boolean,
                    value: true,
                    reflectToAttribute: true,
                    notify: true,
                },
                aggrs: {
                    type: Array,
                    value: function() {
                        return [];
                    },
                    notify: true
                },
                syncHaltCores: {
                    type: Array,
                    value: function() {
                        return [];
                    },
                    notify: true
                },
                syncHaltCore: {
                    type: String,
                    value: "",
                    notify: true,
                    reflectToAttribute: true
                }
            },
            observers: ["_propertyTreesChanged(aetPropertyTrees.splices)"],
            traceTableColumns : [
                {
                    name : "Row No",
                    index : -1,
                    format: "unsigned",
                    datatype: "Number",
                    transform : {
                        type : "rowNumber"
                    }
                },
                {
                    name : "Master ID",
                    index : undefined,
                    indexName : "Master ID",
                    format : "hex",
                    datatype: "Number"
                },
                {   
                    name : "Master Name",
                    index : undefined,
                    indexName : "Master Name",
                    format : "default",
                    datatype: "String",
                },
                {  
                    name : "Operation",
                    index : undefined,
                    indexName : "RA Operation",
                    format : "default",
                    datatype: "String",
                },
                {  
                    name : "Data Message",
                    index : undefined,
                    indexName : "Data Message",
                    format : "default",
                    datatype: "String",
                },
                {  
                    name : "Queue",
                    index : undefined,
                    indexName : "RA Queue",
                    format: "unsigned",
                    datatype: "Number",
                },
                {
                    name : "Global Time Stamp",
                    index: undefined,
                    indexName : "Timestamp",
                    format: "unsigned",
                    datatype: "number",
                },
                {
                    name : "Status",
                    index : undefined,
                    indexName : "Trace Status",
                    format : "default",
                    datatype: "String",
                }
            ],
            ready: function() {
                this._errorMessage = "Waiting to connect to debug session";
                var params = location.search.substr(1).split("&").map(p => {
                    var tmp = p.split("=");
                    return {name : tmp[0], value: tmp[1]};
                });

                var coreNameParam = params.find(x => x.name === "coreName");

                this.coreName = (coreNameParam !== undefined) ? coreNameParam.value : undefined;

                var coreTypeParam = params.find(x => x.name === "coreType");

                this.coreType = (coreTypeParam !== undefined) ? coreTypeParam.value : undefined;

                var tdfFileParam = params.find(x => x.name === "tdf");

                this.tdfFile = (tdfFileParam !== undefined) ? decodeURIComponent(tdfFileParam.value) : undefined;

                this._isLive = this.tdfFile === undefined;

                this._filterActive = false;
                this._searchActive = false;
                this._searchCriteria = undefined;
                this._searchCursor = 0;

                this.rowCountUpdated = false;

                // Bind callback functions
                this.evtCallback = this._evtCallback.bind(this);
                this.traceTableSizeCallback = this._traceTableSizeCallback.bind(this);
                this.getSysTraceCore = this._getSysTraceCore.bind(this);

                // Set up column indexes
                this.lineNoColumn = this.traceTableColumns.findIndex(function (item) {return item.name === "Line No";});
                this.pcColumn = this.traceTableColumns.findIndex(function (item) {return item.name === "PC";});
                this.fileColumn = this.traceTableColumns.findIndex(function (item) {return item.name === "File";});
                this.directoryColumn = this.traceTableColumns.findIndex(function (item) {return item.name === "Directory";});

                var _self = this;
                this._isShutdown = false;
                // eslint-disable-next-line no-unused-vars
                window.addEventListener("beforeunload", function (ev) {
                    _self._shutdown();
                });
            },
            _showTable: function (show)
            {
                if (show) {
                    this.$$("#traceTable").style = "display:inline-block";
                } else {
                    this.$$("#traceTable").style = "display:none";
                }
            },
            _recordChanged: function (evt)
            {
                if (evt.detail.action == "stop") {
                    var _self = this;
                    this._syncWithTarget = false;  // no longer calling halt trace on target halt
                    this.ta.cloudTrace.stopTraceCapture(this.traceOp).then(function () {
                        _self.haltTrace();
                    });
                } else if (evt.detail.action == "start") {
                    this.ta.cloudTrace.startTraceCapture(this.traceOp);
                }
            },
            _systemEvent: function (sysEvt)
            {
                console.log("Received event: '" + sysEvt.eventName + "'");
            },
            _shutdown: function()
            {
                if (this._isShutdown) return;
                this._isShutdown = true;
                console.log("shutdown")
                this.ta.cloudTrace.shutdown();
            },
            _taChanged: function (val) {
                if (val !== undefined) {
                    this.ta.cloudTrace.addListener("systemEvent", this._systemEvent.bind(this));
                    if (!this._isLive) {
                        var _self = this;
                        var devInfo = {tdf: this.tdfFile};
                        this.ta.cloudTrace.getDevices(devInfo).then(function (ret) {
                            _self.deviceInfo = ret.devices[0].device_info;
                        }).catch(function (err) {
                            console.log(err.message);
                        });
                    }
                }
            },
            _searchAction : function (evt)
            {
                if (evt.detail.action === "next") {
                    this._searchCriteria.direction = "forward";
                    this._searchCriteria.starting = this._searchCursor;
                    this._searchTrace(this._searchCriteria);
                } else if (evt.detail.action === "prev") {
                    this._searchCriteria.direction = "backward";
                    this._searchCriteria.starting = this._searchCursor;
                    this._searchTrace(this._searchCriteria);
                } else if (evt.detail.action === "new") {
                    this._searchActive = false;
                    this._searchCursor = 0;
                    this._searchCriteria = undefined;
                    this.$.searchDlg.open();
                } else if (evt.detail.action === "cancel") {
                    this._searchActive = false;
                    this._searchCriteria = undefined;
                    this._searchCursor = 0;
                }
            },
            // eslint-disable-next-line no-unused-vars
            _search_table: function (evt) {
                if (this._searchActive) {
                    this.$.searchActionDlg.open();
                } else {
                    this.$.searchDlg.open();
                }
            },
            _filterAction: function (evt)
            {
                if (evt.detail.action === "new") {
                    this.$.filterDlg.open();
                } else if (evt.detail.action === "clear") {
                    this._clearFilter();
                    this._filterActive = false;
                }
            },
            // eslint-disable-next-line no-unused-vars
            _filter_table: function (evt) {
                if (this._filterActive) {
                    this.$.filterActionDlg.open();
                } else {
                    this.$.filterDlg.open();
                }
            },
            _errorDialogChanged : function () {
                if (!this.$.cfgErrorDlg.opened && this._isLive) {
                   this._restart();
                }
            },
            _restart: function ()
            {
                var _self = this;
                this._tableVisible = false;
                this._showTable(false)
                this._filterActive = false;
                this._searchActive = false;
                this._searchCriteria = undefined;
                this._searchCursor = 0;
                if (!this._isLive) {
                    window.history.back();
                } else {
                    this._preconfigureTrace().finally(function () {
                        _self._traceDataProvider = _self._nullDataProviderFunction;
                        _self.rowCount = 0;
                        _self._rowCountText = "0";
                        var grid = _self.$$("#traceTable");
                        if ((grid !== undefined) && (grid !== null)) {
                            grid.$.traceTable.clearCache();
                            grid.$.traceTable.notifyResize();
                        }
                        _self._activeCoreChanged(_self.activeCore);
                    });
                }
            },
            _searchTrace: function (criteria)
            {
                var _self = this;
                this.ta.cloudTrace.findInTrace(this.traceOp, criteria).then(function (ret) {
                    var row = ret.rowNumber;
                    if (row <= 0) {
                        _self._simpleDlgMessage = "Value not found";
                        _self.$$("#simpleDlg").open();
                    } else {
                        _self._searchCursor = row;
                        _self.$$("#traceTable").scrollTo(row-1);
                    }
                }).catch (function (e) {
                    console.log("Search error: "+JSON.stringify(e));
                })
            },
            _searchDialogChanged: function()
            {
                var dlg = this.$$("#searchDlg");
                if ((dlg === undefined) || (dlg === null)) {
                    return;
                }
                if (dlg.opened) {
                    return;
                }
                if (dlg.closingReason === "confirmed") {
                    this._searchCriteria = dlg.query;
                    this._searchCriteria.direction = "forward";
                    this._searchCriteria.starting = 0;
                    this._searchTrace(this._searchCriteria);
                    this._searchActive = true;
                }
            },
            _filterDialogChanged: function()
            {
                var dlg = this.$$("#filterDlg");
                if ((dlg === undefined) || (dlg === null)) {
                    return;
                }
                if (dlg.opened) {
                    return;
                }
                if (dlg.closingReason === "confirmed") {
                    this._set_filter(dlg.query);
                    this._filterActive = true;
                }
            },
            _set_filter: function(criteria)
            {
                this._tracedataProvider = this._nullDataProviderFunction;
                this.rowCount = 0;
                this._rowCountText = "0";
                var grid = this.$$("#traceTable");
                if ((grid !== undefined) && (grid !== null)) {
                    grid.$.traceTable.clearCache();
                    grid.$.traceTable.notifyResize();
                }
                var _self = this;
                _self._traceStatus = "Applying filter...";
                _self.$.progress.open();
                _self._canNotFilter = true;
                _self._canNotSave = true;
                this.ta.cloudTrace.filterTable(this.traceOp, criteria).then(function (ret) {
                    _self._traceDataProvider = _self._traceDataProviderFunction.bind(_self);
                    _self.rowCount = ret.rowCount;
                    _self.rowCountUpdated = true;
                    _self._rowCountText = ret.rowCount.toString().replace(/\B(?=(\d{3})+(?!\d))/g,",");
                    if ((grid !== undefined) && (grid !== null)) {
                        grid.$.traceTable.clearCache();
                        grid.$.traceTable.notifyResize();
                    }
                }).catch(function (e){
                    console.log("Error applying filter: " + JSON.stringify(e));
                    _self.ta.cloudTrace.clearFilter(_self.traceOp).then(function (ret) {
                        _self._traceDataProvider = _self._traceDataProviderFunction.bind(_self);
                        _self.rowCount = ret.rowCount;
                        _self.rowCountUpdated = true;
                        _self._rowCountText = ret.rowCount.toString().replace(/\B(?=(\d{3})+(?!\d))/g,",");
                        this.$$("#traceTable").clearCache();
                        this.$$("#traceTable").notifyResize();
                    });
                }).finally(function () {
                    _self._traceStatus = "";
                    _self.$.progress.close();
                    _self._canNotFilter = false;
                    _self._canNotSave = false;
                });
            },
            _clearFilter: function()
            {
                var _self = this;
                _self._traceStatus = "Removing filters...";
                _self.$.progress.open();
                this._canNotFilter = true;
                this._canNotSave = true;
                this.ta.cloudTrace.clearFilter(this.traceOp).then(function (ret) {
                    _self._traceDataProvider = _self._traceDataProviderFunction.bind(_self);
                    _self.rowCount = ret.rowCount;
                    _self.rowCountUpdated = true;
                    _self._rowCountText = ret.rowCount.toString().replace(/\B(?=(\d{3})+(?!\d))/g,",");
                    this.$$("#traceTable").clearCache();
                    this.$$("#traceTable").notifyResize();
                }).catch(function(e) {
                    console.log("Error clearing filter: " + JSON.stringify(e));
                }).finally(function () {
                    _self._traceStatus = "";
                    _self.$.progress.close();
                    _self._canNotFilter = false;
                    _self._canNotSave = false;
                });
            },
            _save_as_tdf: function()
            {
                this._canNotSave = true;
                var _self = this;
                var params = {};
                params.title = "Save Trace Data as...";
                params.names = [];
                params.extensions = [];
                if (this._isLive)
                {
                    //params.names.push("Trace Data File (.tdf)");
                    //params.extensions.push("*.tdf");
                }
                if (this.ta.cloudTrace.createTraceDb !== undefined)
                {
                    params.names.push("SQLite Database (.sqlite)");
                    params.extensions.push("*.sqlite");
                }
                params.names.push("Comma Separated File (.csv)");
                params.extensions.push("*.csv");
                params.style = "save";
                this.ta.cloudTrace.fileDialog(params).then(function (ret) {
                    var filename = ret.filename;
                    var indx = ret.extensionIndex;
                    if ((filename !== "") && (indx >= 0) && (indx < params.extensions.length)) {
                        var info = {};
                        if (params.extensions[indx] === "*.tdf")
                        {
                            if (filename.slice(-4) !== ".tdf") {
                                filename += ".tdf";
                            }
                            info.deviceId = _self.deviceId;
                            info.coreType = _self.coreType;
                            info.coreName = _self.coreName;
                            info.useCases = ["dma_ringacc_trace"];
                            _self._traceStatus = "Saving Trace Data as tdf...";
                            _self.$.progress.open();
                            return _self.ta.cloudTrace.saveAs(_self.traceOp, "tdf", filename, info).then(function () {
                                _self.$.progress.close();
                            });
                        } else if (params.extensions[indx] === "*.csv") {
                            if (filename.slice(-4) !== ".csv") {
                                filename += ".csv";
                            }
                            _self._traceStatus = "Saving Trace Data as csv...";
                            _self.$.progress.open();
                            return _self.ta.cloudTrace.saveAs(_self.traceOp, "csv", filename, info).then (function () {
                                _self.$.progress.close();
                            });
                        } else if (params.extensions[indx] == "*.sqlite") {
                            if (filename.slice(-7) !== ".sqlite") {
                                filename += ".sqlite";
                            }
                            _self._traceStatus = "Saving Trace Data to SQLite DB...";
                            _self.$.progress.open();
                            return _self.ta.cloudTrace.saveAs(_self.traceOp,"sqlite", filename, info).then (function() {
                                _self.$.progress.close();
                            });
                        }
                    }
                // eslint-disable-next-line no-unused-vars
                }).catch(function (err){
                    _self.$.progress.close();
                    _self._errorDlgMessage = "An error occured while saving";
                    _self.$.errorDlg.open();
                }).finally (function () {
                    _self._canNotSave = false;
                });
            },
            // This function is called when a row in the trace table is clicked on (selected).
            // It calls into CloudTrace to request the editor and disassembly windows to be updated
            // to highlight corresponding source and assembly text to be highlighted.
            activeItemChanged: function()
            {
                if ((this.activeItem !== undefined) && (this.activeItem !== null))
                {
                    var lineNo = parseInt(this.activeItem[this.lineNoColumn]);
                    var file = this.activeItem[this.fileColumn];
                    var dir = this.activeItem[this.directoryColumn];
                    var addr = this.activeItem[this.pcColumn];
                    if (lineNo !== undefined && ! isNaN(lineNo) && dir !== "" && file !== "")
                    {
                        this.ta.cloudTrace.setEditorViewLocation(dir+"/"+file,lineNo).then(function (ret) {
                            console.log(JSON.stringify(ret));
                        });
                    }
                    if (addr !== undefined)
                    {
                        this.ta.cloudTrace.setDisassemblyViewAddress(addr).then(function (ret) {
                            console.log(JSON.stringify(ret));
                        });
                    }
                }
            },
            /*
            * Data provider function that returns the empty array - used when trace data is not available
            */
            _nullDataProviderFunction: function (opts, callback)
            {
                console.log("_nullDataProviderFunction called");
                callback([], 0);
            },
            /*
            * Data provider function that calls into CloudTrace to get trace data - used when trace data is available.
            */
            _traceDataProviderFunction: function (params, cb) 
            {
                var _self = this;
                console.log("_traceDataProviderFunction called, page: " + params.page+" page size (" + params.pageSize +")");
                if (typeof this.traceOp !== 'undefined') {
                    this.ta.cloudTrace.readTraceDataPage(this.traceOp, params.page, params.pageSize).then(function (retObj) {
                        if (_self.rowCountUpdated) {
                            _self.rowCountUpdated = false;
                            _self.$$("#traceTable").$.traceTable.notifyResize();
                        }
                        cb(retObj.traceData, _self.rowCount);
                    }).fail(function (err) {
                        console.log("data provider command failed: "+JSON.stringify(err));
                        cb([], 0);
                    });
                } else {
                    console.log("unknown trace op");
                    cb([],0);
                }
            },
            _activeCoreChanged: function(val)
            {
                if (val === undefined) {
                    this.splice('traceRoutes',0,this.traceRoutes.length);
                    this.$.traceConfig.close();
                } else {
                    var probe = this.deviceInfo.name;
                    var traceRoutes = [];

                    this._getSysTraceCores();

                    for (var i = 0; i < this.deviceInfo.trace_routes.length; i++) {
                        
                        route = this.deviceInfo.trace_routes[i];

                        for (var j = 0; j < this.aggrs.length; j++) {

                            if (route.source == this.aggrs[j].name) {
                                if ((route.receiver !== "Pro Trace") || probe.includes("XDSPRO")) {
                                    traceRoutes.push(route);
                                    break;
                                }
                            }
                        }
                    }

                    this.splice('traceRoutes',0,this.traceRoutes.length, ...traceRoutes);
                    if (this._isLive) {
                        // Configure trace collection on live system
                        this.$.traceConfig.open();
                    } else {
                        
                        // Using TDF, so can just create decoder and go
                        var _self = this;
                        this._canNotSave = true;
                        this.ta.cloudTrace.addListener("traceTableSizeEvent", _self.traceTableSizeCallback);
                        this.ta.cloudTrace.createOperation(this.tdfFile,"TDF").then(function (ret) {
                            _self.traceOp = ret.handle;
                            if (_self.ta.cloudTrace.createTraceDb !== undefined) {
                                return _self.ta.cloudTrace.createTraceDb(_self.traceOp, {});
                            } else {
                                return _self.ta.cloudTrace.createTrace(_self.traceOp);
                            }
                        // eslint-disable-next-line no-unused-vars
                        }).then(function (ret) {
                            _self._traceCreated = true;
                            return _self.ta.cloudTrace.enableTraceTableSizeEvent(_self.traceOp);
                        // eslint-disable-next-line no-unused-vars
                        }).then(function (ret) {
                            return _self.ta.cloudTrace.readObjectFile(_self.traceOp, true, false);
                        // eslint-disable-next-line no-unused-vars
                        }).then(function (ret) {
                            return _self.ta.cloudTrace.readTraceColumnNames(_self.traceOp);
                        }).then(function (ret) {
                            console.log(JSON.stringify(ret));
                            _self.splice("_traceTableColumns", 0, _self._traceTableColumns.length, ..._self.traceTableColumns);
                            return _self.ta.cloudTrace.setupColumnProcessing(_self.traceOp, _self.traceTableColumns);
                        }).then(function () {
                            return _self.ta.cloudTrace.readTraceColumnNames(_self.traceOp);
                        }).then(function (ret) {
                            _self.columnNames = ret.columns;
                            _self._showTable(true);
                            _self._tableVisible = true;
                            setTimeout(function () {
                                _self._canNotSave = false;
                                _self._canNotFilter = false;
                            }, 500);
                            return _self.ta.cloudTrace.fetchTraceData(_self.traceOp);
                        }).catch(function (err) {
                            _self._traceStatus = "Error Reading Trace Data";
                            _self._tableVisible = false;
                            _self.showTable(false);
                            _self.ta.cloudTrace.disableTraceTableSizeEvent(_self.traceOp);
                            _self.ta.cloudTrace.removeListener("traceTableSizeEvent", _self.traceTableSizeCallback);
                            _self._releaseOperations();
                            _self._destroyTrace();
                            _self._traceCreated = false;
                            _self.$.progress.close();
                            _self._canNotFilter = false;
                            _self._canNotSave = false;
                            console.log("Failure: "+JSON.stringify(err));
                        }).finally(function () {  
                        });
                    }
                }
            },
            _propertyTreesChanged: function ()
            {
                if ((this.aetPropertyTrees !== undefined) && (this.aetPropertyTrees.length > 0)) {
                    this.rowCount = 0;
                    this._traceDataProvider = this._nullDataProviderFunction;
                    this._configureTrace(this.traceRoute, this.aetPropertyTrees, this.receiverPropertyTree);
                }
            },
            _isActiveChanged: function(val) {
                if (!val) {
                    this.$.tableDiv.style="display:none";
                    this.$.errorDiv.style="display:inline-block";
                    this.$.traceConfig.close();
                    this._errorMessage = "Waiting to connect to debug session";
                    var _self = this;
                    this.rowCount = 0;
                    this._traceDataProvider = this._nullDataProviderFunction;
                    var traceTable = this.$$("#traceTable");
                    if (traceTable !== null) {
                        traceTable.$.traceTable.size = 0;
                        traceTable.$.traceTable.notifyResize();
                    }
                    this._releaseOperations().then(function () {
                        return _self._destroyTrace();
                    });
                } else {
                    this.$.errorDiv.style="display:none";
                    this.$.tableDiv.style="display:flex";
                }
            },
            traceTableSizeCallback: undefined,                
            _traceTableSizeCallback: function(info)
            {
                console.log("Trace Table Size Event received: " + JSON.stringify(info));
                if (info.handle === this.traceOp) {
                    console.log("Number of rows: " + info.size);
                    if (this.rowCount == 0) {
                        this.$.progress.close();
                        this._traceDataProvider = this._traceDataProviderFunction.bind(this);
                        this.rowCount = info.size;
                        this.rowCountUpdated = true;
                        this._rowCountText = info.size.toString().replace(/\B(?=(\d{3})+(?!\d))/g,",");
                    } else {
                        this._rowCountText = info.size.toString().replace(/\B(?=(\d{3})+(?!\d))/g,",");
                        var _self = this;
                        this.debounce('updateRowCount', function () {
                            _self.rowCount = info.size;
                            _self.rowCountUpdated = true;
                        }, 500);
                    }
                    if (info.isFinal && ! this._isLive) { // tdf
                        this._canNotFilter = false;
                        this._canNotSave = false
                    }
                }
            },
            _processTrace: function () {
                this._releaseOperations();
            },
            _mapColumns: function (traceColumns, sourceColumns)
            {
                traceColumns.forEach(function (el) {
                    if (el.index === undefined) {
                        var indx = sourceColumns.indexOf(el.indexName);
                        if (indx >= 0) {
                            el.index = indx;
                        }
                    }
                });
            },
            haltTrace: function ()
            {
                var _self = this;
                this._releaseAetOperations();
                this.$.control.close();
                this.$.progress.open();
                this.ta.cloudTrace.readTraceColumnNames(this.traceOp).then(function (ret) {
                    var cols = [];
                    _self.traceTableColumns.forEach(function (el) {
                        cols.push(el);
                        if (el.index >= 0) {
                            el.index = undefined;
                        }
                    });
                    _self._mapColumns(cols, ret.columns);
                    var tcols = [];
                    cols.forEach(function (el) {
                        if (el.index !== undefined) {
                            tcols.push(el);
                        }
                    });
                    _self.splice("_traceTableColumns", 0, _self._traceTableColumns.length, ...tcols);
                    return _self.ta.cloudTrace.setupColumnProcessing(_self.traceOp, tcols);
                }).then(function () {
                    return _self.ta.cloudTrace.readTraceColumnNames(_self.traceOp);
                }).then(function (ret) {
                    _self.columnNames = ret.columns;
                    _self._tableVisible = true;
                    _self._showTable(true)
                    _self._canNotSave = false;
                    _self._canNotFilter = false;
                    _self._traceStatus = "Reading trace data...";
                    return _self.ta.cloudTrace.fetchTraceData(_self.traceOp);
                }).catch(function (err) {
                    _self._traceStatus = "Error Reading Trace Data";
                    _self._tableVisible = false;
                    _self._showTable(false);
                    var traceCpu = this.deviceInfo.name + "/" + this.activeCore;
                    _self.ta.cloudTrace.disableTargetEvents(traceCpu);
                    _self.ta.cloudTrace.removeListener("targetEvent",_self.evtCallback);
                    _self.ta.cloudTrace.disableTraceTableSizeEvent(_self.traceOp);
                    _self.ta.cloudTrace.removeListener("traceTableSizeEvent", _self.traceTableSizeCallback);
                    _self._releaseOperations();
                    _self._destroyTrace();
                    _self.$.progress.close();
                    _self._traceConfigurationErrorMessage = "An error occured while reading trace data";
                    _self.$.cfgErrorDlg.open();
                    _self._canNotFilter = false;
                    _self._canNotSave = false;
                    console.log("Failure: "+JSON.stringify(err));
                }).finally(function () {
                });
            },
            _evtCallback: function(info)
            {
                console.log("Event received: " + JSON.stringify(info));
                if (info.eventName === "Halt") {
                    var _self = this;
                    if (this._syncWithTarget) {
                        _self.$.control.disable();
                        // eslint-disable-next-line no-unused-vars
                        _self.ta.cloudTrace.stopTraceCapture(_self.traceOp).then(function (ret) {
                            _self.haltTrace();
                        });
                    }
                } else if (info.eventName == "PreRun") {
                    console.log("Target PreRun");
                } else if (info.eventName === "traceChannelRecording") {
                    this.$.control.setRecording(true);
                    this._traceStatus = "Trace recording enabled";
                    this._traceStatus = info.description;
                } else if (info.eventName === "traceChannelStoppedTrigger") {
                    this.$.control.setRecording(false);
                    this._traceStatus = "Trace recording halted";
                    this._traceStatus = info.description;
                } else if (info.eventName === "traceChannelStoppedTraceTrigger") {
                    this.$.control.setRecording(false);
                    this._traceStatus = "Trace recording halted";
                    this._traceStatus = info.description;
                } else if (info.eventName === "traceChannelStoppedError") {
                    this.$.control.setRecording(false);
                    this._traceStatus = "Trace recording halted due to error";
                    this._traceStatus = info.description;
                } else if (info.eventName === "traceChannelStoppedFull") {
                    this.haltTrace();
                    this.$.control.setRecording(false);
                    this._traceStatus = "Trace recording halted due to buffer full";
                    this._traceStatus = info.description;
                } else if (info.eventName === "traceChannelStoppedUserRequest") {
                    this.$.control.setRecording(false);
                    this._traceStatus = "Trace recording halted";
                    this._traceStatus = info.description;
                } else if (info.eventName === "TraceDataRead") {
                    console.log("Trace Data Read Completed");
                    //this._releaseOperations();                
                    var _self = this;         
                    var traceCpu = this.deviceInfo.name + "/" + this.activeCore;
                    this.ta.cloudTrace.disableTargetEvents(traceCpu);
                    this.ta.cloudTrace.removeListener("targetEvent",this.evtCallback);
                    this.ta.cloudTrace.disableTraceTableSizeEvent(this.traceOp);
                    this.ta.cloudTrace.removeListener("traceTableSizeEvent", this.traceTableSizeCallback);
                    //this.ta.cloudTrace.setEnableOperation(this.traceOp, false);
                    //this._processTrace();
                }
            },
            evtCallback: undefined,
            _findActiveCoreInfo: function (device, core)
            {
                if ((device === undefined) || (device.length == 0)) {
                    return undefined;
                }
                var value = device.find(x => x.local_name === core);

                if (value !== undefined) {
                    return value;
                }

                for (var i in device) {
                    value = this._findActiveCoreInfo(device[i].children, core);
                    if (value !== undefined) {
                        return value;
                    }
                }

                return undefined;
            },
            _liveDeviceInfoChanged: function (val)
            {
                if (this._isLive)
                {
                    this.deviceInfo = val;
                }
            },
            _deviceInfoChanged: function (val)
            {
                if (val === undefined) {
                    this.deviceId = undefined;
                    this._errorMessage = "Waiting to connect to debug session";
                    if (this._isActive) {
                        this._isActive = false;
                        // In this case we need to clear any operation handles etc.
                        this.aetOps = [];
                        this.traceOp = undefined;
                    }
                    if (this.activeCore !== undefined) {
                        this.activeCore = undefined;
                    }
                    if (this.activeOutFileName !== undefined) {
                        this.activeOutFileName = undefined;
                    }
                } else {
                    var coreInfo = this._findActiveCoreInfo(val.children, this.coreName);
                    if (coreInfo !== undefined) {
                        this.deviceId = val.id;
                        this._errorMessage = "";
                        if (!this._isActive) {
                            this._isActive = true;
                        }
                        var name = coreInfo.name.split("/")[1];
                        this.async(function () {
                            if (name !== this.activeCore) {
                                this.set('activeCore', name);
                                this.activeCore = name;
                            }
                            if (this.activeOutFileName !== coreInfo.out_file_name) {
                                this.activeOutFileName = coreInfo.out_file_name;
                            }
                        });
                    } else {
                        this.deviceId = undefined;
                        this._errorMessage = "No matching core in debug session";
                        if (this._isActive) {
                            this._isActive = false;
                        }
                        if (this.activeCore !== undefined) {
                            this.activeCore = undefined;
                        }
                        if (this.activeOutFileName !== undefined) {
                            this.activeOutFileName = undefined;
                        }
                    }
                }
            },
            _releaseAetOperations: function ()
            {
                var p = Q.defer();
                var _self = this;
                var promises = [];

                if ((this.aetOps !== undefined) && (this.aetOps.length > 0)) {
                    this.aetOps.forEach(op => promises.push(_self.ta.cloudTrace.releaseOperation(op)));
                    this.aetOps = [];
                    Q.all(promises).then(function() {
                        p.resolve();
                    }).catch(function (e) {
                        p.reject(e);
                    });
                } else {
                    p.resolve();
                }
                
                return p.promise;
            },
            _releaseOperations: function ()
            {
                var p = Q.defer();
                var promises = [];

                if (this.traceOp !== undefined) {
                    promises.push(this.ta.cloudTrace.releaseOperation(this.traceOp));
                    if (!this._traceCreated) {
                        this.traceOp = undefined;
                    }
                }
                promises.push(this._releaseAetOperations());
                if (promises.length > 0) {
                    Q.all(promises).then(function () {
                        p.resolve();
                    }).catch(function (e) {
                        p.reject(e);
                    });
                } else {
                    p.resolve();
                }
                return p.promise;
            },
            _destroyTrace: function ()
            {
                var p = Q.defer();
                if (this._traceCreated) {
                    this._traceCreated = false;
                    var traceHandle = this.traceOp;
                    this.ta.cloudTrace.destroyTrace(traceHandle).then(function () {
                        p.resolve();
                    }).catch(function (e) {
                        p.reject(e);
                    });
                } else {
                    p.resolve();
                }
                this.traceOp = undefined;
                return p.promise;
            },
            _preconfigureTrace: function()
            {
                var _self = this;
                var p = Q.defer();
                if (this.traceOp !== undefined) {
                    this.ta.cloudTrace.disableTraceTableSizeEvent(this.traceOp).then(function () {
                        return _self.ta.cloudTrace.removeListener("targetEvent", this.evtCallback);
                    }).then(function () {
                        return _self._releaseOperations();
                    }).then(function () {
                        return _self._destroyTrace();
                    }).then(function () {
                        p.resolve();
                    }).catch(function (e) {
                        p.reject(e);
                    });
                } else {
                    p.resolve();
                }
                return p.promise;
            },
            _configureTrace: function(traceRoute, aetPropertyTrees, receiverPropertyTree)
            {
                var _self = this;
                this._traceStatus = "Starting trace configuration";
                this._traceConfigurationErrorMessage = "";
                this.$.progress.open();
                this._syncWithTarget = this.$.traceConfig.synchronizeWithTarget;
                var tbr = undefined;
                if (traceRoute.hasOwnProperty('sink')) {
                    tbr = traceRoute.sink;
                    this.activeSink = tbr.substring(tbr.lastIndexOf('/')+1);
                } else {
                    this.activeSink = traceRoute.receiver;
                }

                this._canNotFilter = true;
                this._canNotSave = true;
                this._traceCreated = false;
                var traceCpu = traceRoute.source;
                console.log("configuring");
                this._preconfigureTrace().then(function () {
                    _self.ta.cloudTrace.addListener("traceTableSizeEvent", _self.traceTableSizeCallback);
                    return  _self.ta.cloudTrace.addListener("targetEvent", _self.evtCallback);
                }).then(function () {
                    var p = Q(true);
                    p = p.then(_self.$.tm.connectToCore(traceCpu));
                    if (tbr !== undefined) {
                        p = p.then(_self.$.tm.connectToCore.bind(_self.$.tm, tbr));
                    }
                    return p;
                }).then(function() {
                    var promises = [];
                    promises.push(_self.ta.cloudTrace.setPreRunTimeout(60000));
                    promises.push(_self.ta.cloudTrace.enableTargetEvents(traceCpu));
                    return Q.all(promises);
                }).then(function () {
                    // create AET operations and Trace operation
                    var promises = [];
                    aetPropertyTrees.forEach(() => promises.push(_self.ta.cloudTrace.createOperation(traceCpu,"AET")));
                    promises.push(_self.ta.cloudTrace.createOperation(traceCpu,"Trace"));
                    return Q.all(promises);
                }).then(function (ret) {
                    _self._traceStatus = "Configuring Trace Operation";
                    // Get the operation handles
                    _self.traceOp = ret.pop().handle;
                    _self.aetOps = ret.map(r => r.handle);
                    return _self.ta.cloudTrace.setEnableOperation(_self.traceOp, false);
                // eslint-disable-next-line no-unused-vars
                }).then(function (ret) {
                    // Assign the property trees to the operations
                    var promises = [];
                    for (var i in _self.aetOps) {
                        console.log("AET properties sent: " + JSON.stringify(aetPropertyTrees[i], null, 2));
                        promises.push(_self.ta.cloudTrace.setProperties(_self.aetOps[i], [aetPropertyTrees[i]]));
                    }
                    promises.push(_self.ta.cloudTrace.setProperties(_self.traceOp, [receiverPropertyTree]));
                    console.log("Receiver properties sent: " + JSON.stringify(receiverPropertyTree, null, 2));
                    return Q.all(promises);
                }).then(function () {
                    // Read back the property trees
                    var promises = [];
                    _self.aetOps.forEach(op => promises.push(_self.ta.cloudTrace.getProperties(op)));
                    promises.push(_self.ta.cloudTrace.getProperties(_self.traceOp));
                    return Q.all(promises);
                }).then(function (ret) {
                    console.log("AET properties received: ");
                    for (var i = 0; i < ret.length - 1; i++) {
                        console.log(JSON.stringify(ret[i]));
                    }
                    console.log("Receiver properties received: " + JSON.stringify(ret[ret.length-1]));
                    return _self.ta.cloudTrace.enableTraceTableSizeEvent(_self.traceOp);
                }).then(function () {
                    // Enable the AET and trace operations (cause them to execute)
                    // Enable AET first for system trace usecases.
                    var promises = [];
                    _self._traceStatus = "Enabling AET and Trace Operations";
                    _self.aetOps.forEach(op => promises.push(_self.ta.cloudTrace.setEnableOperation(op, true)));
                    promises.push(_self.ta.cloudTrace.setEnableOperation(_self.traceOp, true));                    
                    return Q.all(promises);
                }).then(function () {
                    _self._traceStatus = "Creating Trace Decoder";
                    if (_self.ta.cloudTrace.createTraceDb !== undefined) {
                        return _self.ta.cloudTrace.createTraceDb(_self.traceOp);
                    } else {
                        return _self.ta.cloudTrace.createTrace(_self.traceOp);
                    }
                }).then(function () {
                    _self._traceCreated = true;
                    _self._traceStatus = "Enabling trace capture...";
                    return _self.ta.cloudTrace.readObjectFile(_self.traceOp, true, false);
                }).then(function () {
                    _self._traceStatus = "Trace will be collected when target runs";
                    _self.$.progress.close();
                    _self.$.control.open(true);
                    return _self.ta.cloudTrace.preRunComplete();
                }).catch(function (err){
                    console.log("Operation failed" + JSON.stringify(err));
                    _self.ta.cloudTrace.preRunComplete();
                    if (err.message !== undefined) {
                        _self._traceConfigurationErrorMessage = JSON.stringify(err.message);
                    } else {
                        _self._traceConfigurationErrorMessage = JSON.stringify(err);
                    }
                    _self._traceStatus = "Trace Generation Error - Operation Cancelled";
                    var promises = [];
                    if (_self.traceOp !== undefined) {
                        promises.push(_self.ta.cloudTrace.disableTraceTableSizeEvent(_self.traceOp));
                    }
                    promises.push(_self.ta.cloudTrace.removeListener("traceTableSizeEvent", _self.traceTableSizeCallback));
                    promises.push(_self.ta.cloudTrace.removeListener("targetEvent", _self.evtCallback));
                    promises.push(_self._releaseOperations());
                    promises.push(_self._destroyTrace());
                    Q.all(promises).finally(function () {
                        _self.$.progress.close();
                        _self.$.control.close();
                        _self.$.cfgErrorDlg.open();
                    });
                    _self._canNotFilter = false;
                    _self._canNotSave = false;
                });
            },
            _getSysTraceCore: function() {

                var core;

                // For initial configuration, just use the first aggregator.
                if (this.aggrs.length > 0) {
                    core = this.aggrs[0].name;
                }

                return core;
            },
            _getSysTraceCores: function() {

                var stms = [];
                var aggrs = [];
                var ringaccs = [];
                var syncCores = [];

                for (let cluster of this.deviceInfo.children) {
                    for (let node of cluster.children) {
                        if (node.type == "STM") {
                            var nodeObj = {
                                name: node.name,
                                local_name: node.local_name,
                                type: node.type
                            }
                            stms.push(nodeObj);
                        }
                        if (node.type == "Trace Aggregator") {
                            var nodeObj = {
                                name: node.name,
                                local_name: node.local_name,
                                type: node.type
                            }
                            aggrs.push(nodeObj);
                        }
                        else if (node.type == "Ring Accelerator") {
                            var nodeObj = {
                                name: node.name,
                                local_name: node.local_name,
                                type: node.type
                            }
                            ringaccs.push(nodeObj);
                        }
                    }
                }

                // Strip out any system trace node from being in the sync core list.
                for (let route of this.deviceInfo.trace_routes) {
                    if (!syncCores.includes(route.source)) {
                        
                        if (stms.some(e => e.name === route.source)) {
                            continue;
                        }
                        else if (aggrs.some(e => e.name === route.source)) {
                            continue;
                        }

                        syncCores.push(route.source);
                    }
                }

                this.aggrs = aggrs;
                syncCores.unshift("none");
                this.syncHaltCores = syncCores;
            },
        });
    </script>
</dom-module>
