"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.wrapDSModule = exports.initScriptingConsole = exports.initScripting = exports.sleep = void 0;
const syncAgent_1 = require("./syncAgent");
const path = require("path");
const fs = require("fs");
const os_1 = require("os");
const child_process_1 = require("child_process");
const errors_1 = require("./errors");
// Assume we are in ccs/scripting/node_modules/scripting
const defaultCcsRoot = path.join(__dirname, "..", "..", "..");
let scriptingAgent = null;
let existingDS = null;
/**
 * Blocks execution for a given amount of time
 *
 * @param ms - The sleep duration in milliseconds
 */
function sleep(ms) {
    if (scriptingAgent) {
        // Sleep while processing incoming events
        scriptingAgent.sleep(ms);
    }
    else {
        // If scripting has not been initialized, then just block
        const dummyBuffer = new Int32Array(new SharedArrayBuffer(4), 0, 1);
        dummyBuffer[0] = 0;
        Atomics.wait(dummyBuffer, 0, 0, ms);
    }
}
exports.sleep = sleep;
/**
 * Initialize the debugger process for scripting
 *
 * @returns A {@link DebuggerScripting} object.
 */
function initScripting(options) {
    if (existingDS !== null) {
        if (options?.timeout) {
            existingDS.setScriptingTimeout(options.timeout);
        }
        return existingDS;
    }
    if (scriptingAgent !== null) {
        throw new Error("Scripting has already been initialized. Did you forget to call shutdown()?");
    }
    const ccsBase = path.join(options?.ccsRoot || defaultCcsRoot, "ccs_base");
    const cloudAgentDir = path.join(ccsBase, "cloudagent");
    const inProcess = options?.inProcess || false;
    const initialTimeout = options?.timeout ?? 0;
    let ccsProcess;
    let ccxmlFile;
    const syncAgent = (0, syncAgent_1.setupSynchronousClient)(cloudAgentDir, inProcess, errors_1.ScriptingTimeoutError);
    scriptingAgent = syncAgent;
    syncAgent.setTimeout(initialTimeout);
    const cloudAgentPort = syncAgent.launchCloudAgent();
    const cloudAgent = syncAgent.createModule(cloudAgentPort);
    const ds = cloudAgent.getSubModule("DS");
    const onShutdown = () => {
        if (ccsProcess && ccsProcess.exitCode === null) {
            ccsProcess.kill();
        }
        syncAgent.shutdown();
        if (scriptingAgent === syncAgent) {
            scriptingAgent = null;
        }
    };
    existingDS = wrapDSModule(syncAgent, ds, { exposeRaw: !!options?.exposeRaw, onShutdown });
    existingDS.configure = (ccxml) => {
        const ret = ds.scripting.configure(ccxml);
        ccxmlFile = ccxml;
        return ret;
    };
    existingDS.deconfigure = () => {
        ccxmlFile = undefined;
        return ds.scripting.deconfigure();
    };
    existingDS.launchCCS = (ccstudioArg) => {
        // If CCS was launched previously, exitCode will null if it is still running
        if (ccsProcess && ccsProcess.exitCode === null) {
            throw new Error("CCS is already running");
        }
        const ext = (0, os_1.platform)() === "win32" ? ".exe" : "";
        const ccstudio = ccstudioArg || path.join(ccsBase, "../theia/ccstudio" + ext);
        if (!fs.existsSync(ccstudio)) {
            if (!ccstudioArg &&
                !fs.existsSync(path.join(ccsBase, "../theia")) &&
                fs.existsSync(path.join(ccsBase, "../eclipse"))) {
                // Looks like we are in a CCS Eclipse install
                throw new Error(`Cannot find ccs executable '${ccstudio}'. launchCCS is not supported in Eclipse-based CCS.`);
            }
            throw new Error(`Cannot find ccs executable '${ccstudio}'.`);
        }
        const args = [`--agent-port=${cloudAgentPort}`];
        if (ccxmlFile) {
            args.push(`--ccxml=${ccxmlFile}`);
        }
        // IDE will signal with an event when it is ready, block until that event
        const eventBroker = cloudAgent.getSubModule("EventBroker");
        ccsProcess = (0, child_process_1.spawn)(ccstudio, args);
        syncAgent.waitForEvent(eventBroker, "attachedToCloudAgent");
        eventBroker.close();
    };
    return existingDS;
}
exports.initScripting = initScripting;
function initScriptingConsole(syncAgent, dsPort) {
    const dsRaw = syncAgent.createModule(dsPort);
    existingDS = wrapDSModule(syncAgent, dsRaw, { exposeRaw: false });
    dsRaw.addListener("close", () => { existingDS = null; });
    return existingDS;
}
exports.initScriptingConsole = initScriptingConsole;
function wrapDSModule(syncAgent, ds, options) {
    // Lazily load trace
    let trace = null;
    const lazyTraceHandler = {
        get(target, prop, receiver) {
            if (prop === "trace") {
                if (!trace) {
                    const traceModule = ds.getSubModule("trace");
                    traceModule.addListener("close", () => { trace = null; });
                    if (options.exposeRaw) {
                        trace = { ...traceModule.scripting, _raw: traceModule };
                    }
                    else {
                        trace = traceModule.scripting;
                    }
                }
                return trace;
            }
            return Reflect.get(target, prop, receiver);
        }
    };
    const extraFns = {
        openSession: (corePatArg) => {
            const corePat = corePatArg || /.*/;
            const re = corePat instanceof RegExp ? corePat : RegExp(corePat);
            const { cores: debugCores, nonDebugCores } = ds.listCores();
            const cores = [...debugCores, ...nonDebugCores];
            // Exact match takes priority over regex match
            const core = cores.find((core) => core === corePatArg) || cores.find((core) => core.match(re));
            if (core === undefined) {
                throw new Error("No matching core found");
            }
            const task = ds.getSubModule(core);
            if (options.exposeRaw) {
                return { ...task.scripting, _raw: task };
            }
            return task.scripting;
        },
        setScriptingTimeout: syncAgent.setTimeout,
        getScriptingTimeout: syncAgent.getTimeout,
        shutdown: () => {
            try {
                ds.scripting.deconfigure();
            }
            catch {
                // swallow, we might not currently be configured
            }
            if (options.onShutdown) {
                options.onShutdown();
            }
        },
        launchCCS: () => { },
    };
    const dsScriptingObject = { ...ds.scripting, ...extraFns };
    if (options.exposeRaw) {
        dsScriptingObject._raw = ds;
    }
    return new Proxy(dsScriptingObject, lazyTraceHandler);
}
exports.wrapDSModule = wrapDSModule;
