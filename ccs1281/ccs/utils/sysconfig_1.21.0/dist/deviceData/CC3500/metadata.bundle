defineResource("/CC3500/templates/csv/summary.csv.xdt", function(_, system, pmux, scripting, require) { "use strict";return function(args) {
var __t, __p = '', __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }

 var $legacy = pmux.getScript("/legacy/adapt.js")(pmux), assignmentErrors = $legacy.assignmentErrors, assignments = $legacy.assignments, peripheralConfigurables = $legacy.peripheralConfigurables, peripheralConfigurations = $legacy.peripheralConfigurations, selectedUseCases = $legacy.selectedUseCases, version = $legacy.version, deviceData = $legacy.deviceData;

	var gpioType = function( assignment ) {
		if( assignment.input ) {
			return "Input";
		} else if( assignment.output ) {
			return "Output";
		} else if( assignment.outputOpenDrain ) {
			return "Output OD";
		} else {
			return "";
		}
	};
;
__p += 'Pin#, PORT IO, Function, Direction\n';
 for( var i = 0; i < assignments.length; ++i ) {
;
__p +=
((__t = (assignments[i].devicePin.ball)) == null ? '' : __t) +
',' +
((__t = (assignments[i].devicePin.designSignalName)) == null ? '' : __t) +
',' +
((__t = (assignments[i].peripheralPin.name)) == null ? '' : __t) +
',' +
((__t = (gpioType( assignments[i] ))) == null ? '' : __t) +
'\n';
 }
;

return __p
}; });
defineResource("/CC3500/templates/driverlib/CC3500_LAUNCHXL.c.xdt", function(_, system, pmux, scripting, require) { "use strict";return function(args) {
var __t, __p = '', __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }

 var $legacy = pmux.getScript("/legacy/adapt.js")(pmux), assignmentErrors = $legacy.assignmentErrors, assignments = $legacy.assignments, peripheralConfigurables = $legacy.peripheralConfigurables, peripheralConfigurations = $legacy.peripheralConfigurations, selectedUseCases = $legacy.selectedUseCases, version = $legacy.version, deviceData = $legacy.deviceData;

    // Change to either "" or "MAP_" depending on if the code is to be in ROM 
    // or not
    var MAP_ = "";
    
    var date = new Date();
    
    var getGPIOPinNo = function( assignment ) {
        return parseInt( assignment.peripheralPin.name.match( /GPIO_([0-9]+)/ )[1] );
    };
    
    var getGPIOID = function( assignment ) {
        return Math.floor( getGPIOPinNo( assignment ) / 8 );
    };
    
    var getTimerId = function( assignment ) {
        return Math.floor( parseInt( assignment.peripheral.name[ assignment.peripheral.name.length - 1 ] ) / 2 );
    };
    
    var mapPeripheral = function( assignment ) {
        switch( assignment.interfaceName ) {
            case "GPIO":
                return "PRCM_GPIOA" + getGPIOID( assignment );
                
            case "UART":
            case "I2C":
                return "PRCM_" + assignment.interfaceName + "A" + assignment.peripheral.name[ assignment.peripheral.name.length - 1 ];
                
            case "TimerPWM":
            case "TimerCP":
                return "PRCM_TIMERA" + getTimerId( assignment );
                
            case "SPI":
                return "PRCM_GSPI";
                
            case "McASP":
                return "PRCM_I2S";

            default:
                return "PRCM_" + assignment.interfaceName.toUpperCase();
        }
    };
    
    var PinType = function( assignment ) {
        switch( assignment.interfaceName ) {
            case "TimerPWM":
            case "TimerCP":
                return MAP_ + "PinTypeTimer";
                
            case "McASP":
                return MAP_ + "PinTypeI2S";
                
            default:
                return MAP_ + "PinType" + assignments[i].interfaceName;
        }
    };
    
    var clocksToEnable = {};
    for( var i = 0; i < assignments.length; ++i ) {
        if( assignments[i].interfaceName !== "JTAG" ) {
            clocksToEnable[ mapPeripheral( assignments[i] ) ] = {};
        }
    };
    
    var gpioType = function( assignment ) {
        if( assignment.input ) {
            return "Input";
        } else if( assignment.output ) {
            return "Output";
        } else {
            return "Output OD";
        }
    };

    var PINnumber = function( assignment ) {
        // controlRegisterOffset refers to the pin ball number of the default package
        // this is because code gen for both mod and default package need to refer to this value
        // and this is the only way to share it /*****without _ ********/
        if( _( assignment.devicePin.controlRegisterOffset.toString() ).size() === 1 ) {
            return "PIN0" + assignment.devicePin.controlRegisterOffset;
        } else {
            return "PIN" + assignment.devicePin.controlRegisterOffset;
        }
    };
    
    var PIN_number = function( assignment ) {
        // controlRegisterOffset refers to the pin ball number of the default package
        // this is because code gen for both mod and default package need to refer to this value
        // and this is the only way to share it
        if( _( assignment.devicePin.controlRegisterOffset.toString() ).size() === 1 ) {
            return "PIN_0" + assignment.devicePin.controlRegisterOffset;
        } else {
            return "PIN_" + assignment.devicePin.controlRegisterOffset;
        }
    };
    
    // PIN_number_devicePin is variant of PIN_number() in which passing devicePin as argument in 
    //  place of assignment
    var PIN_number_devicePin = function( devicePin ) {
        // controlRegisterOffset refers to the pin ball number of the default package
        // this is because code gen for both mod and default package need to refer to this value
        // and this is the only way to share it
        if( _( devicePin.controlRegisterOffset.toString() ).size() === 1 ) {
            return "PIN_0" + devicePin.controlRegisterOffset;
        } else {
            return "PIN_" + devicePin.controlRegisterOffset;
        }
    };
    
    var getChannelNo = function( assignment ) {
    //return parseInt( assignment.peripheralPin.name.match( /([0-9]+)/ )[1] );
    return  assignment.peripheralPin.name.match( /([0-9]+)/ )[1] ;
    };
    
    var getGPIOName = function( assignment ) {
        var name = assignment.peripheralPin.name.split(".")[1];
        return name;
    };
    var isGPIOInput = function( assignment ) {
        var name = assignments[i].configurables['io']['name'].split("/")[0];
        return name == "Input";
    };
    
;
__p += '\n/* ' +
((__t = (MAP_ === "" ? "" : "rom_")) == null ? '' : __t) +
'CC3500_LAUNCHXL.c\n *\n * configure the device pins for different signals\n *\n *\n * Copyright (c) 2016, Texas Instruments Incorporated\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * *  Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *\n * *  Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * *  Neither the name of Texas Instruments Incorporated nor the names of\n *    its contributors may be used to endorse or promote products derived\n *    from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;\n * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR\n * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n * This file was automatically generated on ' +
((__t = (date.toLocaleDateString())) == null ? '' : __t) +
' at ' +
((__t = (date.toLocaleTimeString())) == null ? '' : __t) +
'\n * by TI PinMux version ' +
((__t = (version)) == null ? '' : __t) +
'\n */\n\n/*\n *  ======== CC3500_LAUNCHXL.c ========\n *  This file is responsible for setting up the board specific items for the\n *  CC3500_LAUNCHXL board.\n */\n\n#include <stdint.h>\n#include <stdbool.h>\n\n#include <ti/devices/CC35XX/inc/hw_ints.h>\n#include <ti/devices/CC35XX/inc/hw_memmap.h>\n#include <ti/devices/CC35XX/inc/hw_types.h>\n\n#include <ti/devices/CC35XX/driverlib/rom.h>\n#include <ti/devices/CC35XX/driverlib/rom_map.h>\n#include <ti/devices/CC35XX/driverlib/adc.h>\n#include <ti/devices/CC35XX/driverlib/pin.h>\n#include <ti/devices/CC35XX/driverlib/prcm.h>\n#include <ti/devices/CC35XX/driverlib/spi.h>\n#include <ti/devices/CC35XX/driverlib/sdhost.h>\n#include <ti/devices/CC35XX/driverlib/timer.h>\n#include <ti/devices/CC35XX/driverlib/uart.h>\n#include <ti/devices/CC35XX/driverlib/udma.h>\n#include <ti/devices/CC35XX/driverlib/wdt.h>\n\n#include <ti/drivers/Power.h>\n#include <ti/drivers/power/PowerCC35XX.h>\n\n#include "CC3500_LAUNCHXL.h"\n\n/*\n *  This define determines whether to use the UARTCC35XXDMA driver\n *  or the UARTCC35XX (no DMA) driver.  Set to 1 to use the UARTCC35XXDMA\n *  driver.\n */\n#ifndef TI_DRIVERS_UART_DMA\n#define TI_DRIVERS_UART_DMA 0\n#endif\n\n';
return __p
}; });
defineResource("/CC3500/templates/driverlib/CC3500_LAUNCHXL.h.xdt", function(_, system, pmux, scripting, require) { "use strict";return function(args) {
var __t, __p = '', __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }

 var $legacy = pmux.getScript("/legacy/adapt.js")(pmux), assignmentErrors = $legacy.assignmentErrors, assignments = $legacy.assignments, peripheralConfigurables = $legacy.peripheralConfigurables, peripheralConfigurations = $legacy.peripheralConfigurations, selectedUseCases = $legacy.selectedUseCases, version = $legacy.version, deviceData = $legacy.deviceData;
;
__p += '/*\n * Copyright (c) 2016, Texas Instruments Incorporated\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * *  Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *\n * *  Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * *  Neither the name of Texas Instruments Incorporated nor the names of\n *    its contributors may be used to endorse or promote products derived\n *    from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;\n * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR\n * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n/** ============================================================================\n *  @file       C3235SF_LAUNCHXL.h\n *\n *  @brief      CC3235SF Board Specific APIs\n *\n *  The CC3235SF_LAUNCHXL header file should be included in an application as\n *  follows:\n *  @code\n *  #include <CC3235SF_LAUNCHXL.h>\n *  @endcode\n *\n *  ============================================================================\n */\n/** ============================================================================\n\n';
 var date = new Date();
;
__p += ' *  This file was automatically generated on ' +
((__t = (date.toLocaleDateString())) == null ? '' : __t) +
' at ' +
((__t = (date.toLocaleTimeString())) == null ? '' : __t) +
'\n *  by TI PinMux version ' +
((__t = (version)) == null ? '' : __t) +
'\n *  ============================================================================\n */\n#ifndef __CC3235SF_LAUNCHXL_H\n#define __CC3235SF_LAUNCHXL_H\n\n#ifdef __cplusplus\nextern "C" {\n#endif\n\n#define CC3235SF_LAUNCHXL_GPIO_LED_OFF (0)\n#define CC3235SF_LAUNCHXL_GPIO_LED_ON  (1)\n\n/*!\n *  @def    CC3235SF_LAUNCHXL_ADCName\n *  @brief  Enum of ADC names on the CC3235SF_LAUNCHXL dev board\n */\ntypedef enum CC3235SF_LAUNCHXL_ADCName {\n    CC3235SF_LAUNCHXL_ADC0 = 0,\n    CC3235SF_LAUNCHXL_ADC1,\n\n    CC3235SF_LAUNCHXL_ADCCOUNT\n} CC3235SF_LAUNCHXL_ADCName;\n\n/*!\n *  @def    CC3235SF_LAUNCHXL_CryptoName\n *  @brief  Enum of Crypto names on the CC3235SF_LAUNCHXL dev board\n */\ntypedef enum CC3235SF_LAUNCHXL_CryptoName {\n    CC3235SF_LAUNCHXL_CRYPTO0 = 0,\n\n    CC3235SF_LAUNCHXL_CRYPTOCOUNT\n} CC3235SF_LAUNCHXL_CryptoName;\n\n/*!\n *  @def    CC3235SF_LAUNCHXL_GPIOName\n *  @brief  Enum of GPIO names on the CC3235SF_LAUNCHXL dev board\n */\ntypedef enum CC3235SF_LAUNCHXL_GPIOName {\n    CC3235SF_LAUNCHXL_GPIO_SW2 = 0,\n    CC3235SF_LAUNCHXL_GPIO_SW3,\n    CC3235SF_LAUNCHXL_GPIO_LED_D7,\n\n    /*\n     *  CC3235SF_LAUNCHXL_GPIO_LED_D5 and CC3235SF_LAUNCHXL_GPIO_LED_D6 are shared with the\n     *  I2C and PWM peripherals. In order for those examples to work, these\n     *  LEDs are  taken out of gpioPinCOnfig[]\n     */\n    //CC3235SF_LAUNCHXL_GPIO_LED_D6,\n    //CC3235SF_LAUNCHXL_GPIO_LED_D5,\n\n    CC3235SF_LAUNCHXL_GPIOCOUNT\n} CC3235SF_LAUNCHXL_GPIOName;\n\n/*!\n *  @def    CC3235SF_LAUNCHXL_I2CName\n *  @brief  Enum of I2C names on the CC3235SF_LAUNCHXL dev board\n */\ntypedef enum CC3235SF_LAUNCHXL_I2CName {\n    CC3235SF_LAUNCHXL_I2C0 = 0,\n\n    CC3235SF_LAUNCHXL_I2CCOUNT\n} CC3235SF_LAUNCHXL_I2CName;\n\n/*!\n *  @def    CC3235SF_LAUNCHXL_I2SName\n *  @brief  Enum of I2S names on the CC3235SF_LAUNCHXL dev board\n */\ntypedef enum CC3235SF_LAUNCHXL_I2SName {\n    CC3235SF_LAUNCHXL_I2S0 = 0,\n\n    CC3235SF_LAUNCHXL_I2SCOUNT\n} CC3235SF_LAUNCHXL_I2SName;\n\n/*!\n *  @def    CC3235SF_LAUNCHXL_PWMName\n *  @brief  Enum of PWM names on the CC3235SF_LAUNCHXL dev board\n */\ntypedef enum CC3235SF_LAUNCHXL_PWMName {\n    CC3235SF_LAUNCHXL_PWM6 = 0,\n    CC3235SF_LAUNCHXL_PWM7,\n\n    CC3235SF_LAUNCHXL_PWMCOUNT\n} CC3235SF_LAUNCHXL_PWMName;\n\n/*!\n *  @def    CC3235SF_LAUNCHXL_SDFatFSName\n *  @brief  Enum of SDFatFS names on the CC3235SF_LAUNCHXL dev board\n */\ntypedef enum CC3235SF_LAUNCHXL_SDFatFSName {\n    CC3235SF_LAUNCHXL_SDFatFS0 = 0,\n\n    CC3235SF_LAUNCHXL_SDFatFSCOUNT\n} CC3235SF_LAUNCHXL_SDFatFSName;\n\n/*!\n *  @def    CC3235SF_LAUNCHXL_SDName\n *  @brief  Enum of SD names on the CC3235SF_LAUNCHXL dev board\n */\ntypedef enum CC3235SF_LAUNCHXL_SDName {\n    CC3235SF_LAUNCHXL_SD0 = 0,\n\n    CC3235SF_LAUNCHXL_SDCOUNT\n} CC3235SF_LAUNCHXL_SDName;\n/*!\n *  @def    CC3235SF_LAUNCHXL_SDSPIName\n *  @brief  Enum of SDSPI names on the CC3235SF_LAUNCHXL dev board\n */\ntypedef enum CC3235SF_LAUNCHXL_SDSPIName {\n    CC3235SF_LAUNCHXL_SDSPI0 = 0,\n\n    CC3235SF_LAUNCHXL_SDSPICOUNT\n} CC3235SF_LAUNCHXL_SDSPIName;\n\n/*!\n *  @def    CC3235SF_LAUNCHXL_SPIName\n *  @brief  Enum of SPI names on the CC3235SF_LAUNCHXL dev board\n */\ntypedef enum CC3235SF_LAUNCHXL_SPIName {\n    CC3235SF_LAUNCHXL_SPI0 = 0,\n    CC3235SF_LAUNCHXL_SPI1,\n\n    CC3235SF_LAUNCHXL_SPICOUNT\n} CC3235SF_LAUNCHXL_SPIName;\n\n/*!\n *  @def    CC3235SF_LAUNCHXL_UARTName\n *  @brief  Enum of UARTs on the CC3235SF_LAUNCHXL dev board\n */\ntypedef enum CC3235SF_LAUNCHXL_UARTName {\n    CC3235SF_LAUNCHXL_UART0 = 0,\n    CC3235SF_LAUNCHXL_UART1,\n\n    CC3235SF_LAUNCHXL_UARTCOUNT\n} CC3235SF_LAUNCHXL_UARTName;\n\n/*!\n *  @def    CC3235SF_LAUNCHXL_WatchdogName\n *  @brief  Enum of Watchdogs on the CC3235SF_LAUNCHXL dev board\n */\ntypedef enum CC3235SF_LAUNCHXL_WatchdogName {\n    CC3235SF_LAUNCHXL_WATCHDOG0 = 0,\n\n    CC3235SF_LAUNCHXL_WATCHDOGCOUNT\n} CC3235SF_LAUNCHXL_WatchdogName;\n\n/*!\n *  @brief  Initialize the general board specific settings\n *\n *  This function initializes the general board specific settings.\n */\nextern void CC3235SF_LAUNCHXL_initGeneral(void);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* __CC3235SF_LAUNCHXL_H */\n';
return __p
}; });