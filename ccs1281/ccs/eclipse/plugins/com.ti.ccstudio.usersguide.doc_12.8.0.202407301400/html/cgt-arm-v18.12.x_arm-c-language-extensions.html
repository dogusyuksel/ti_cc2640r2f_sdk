<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">

<!-- OPTIONAL BUT RECOMMENDED: Add a summary for your page below, then remove the comments. The summary should inform users what the page is about (within 160 chars). It will appear in Google search results below the Title and can have a huge effect on click-through rate -->

<meta name="description" content="Use Arm C Language Extensions (ACLE) to Make Your Arm Applications More Portable"> 

<!-- Change the product name and link if desired -->
<meta name="product-name" content="TI Code Generation Tools">
<meta name="product-link" content="https://www.ti.com/tool/TI-CGT">

<!-- Change the title text for your page -->
<title>Use Arm C Language Extensions (ACLE) to Make Your Arm Applications More Portable</title>

<script src='https://software-dl.ti.com/ccs/esd/documents/web_support_v2/loader.js'></script>

</head>

<xmp theme="united2" style="display:none;" class="col-xs-6">

<!-- Start of markdown source -->

There are a variety of different Arm compilers available with which to develop applications to run on an Arm processor. Historically, each compiler has supported a collection of predefined macro symbols that facilitate configuring an application to a specific Arm processor variant and set of features. A given Arm compiler also provides attributes, pragmas, and intrinsics to facilitate access to Arm-specific features and processor specific instructions. However, in many cases, the names and/or syntax of these predefined macro symbols, attributes, pragmas, and intrinsics vary by compiler even though they may serve the same function.

The Arm C Language Extensions (ACLE) specification maintained by Arm Limited provides a single de facto standard definition of these predefined macro symbols, attributes, pragmas, and intrinsics "to enable C/C++ programmers to exploit the Arm architecture with minimal restrictions on source code portability." ([Arm C Language Extensions Documentation - Release ACLE Q2 2018](https://static.docs.arm.com/101028/0006/Q1-ACLE_2018Q2_release-0006.pdf?_ga=2.48136815.956254943.1548190879-2113270987.1548190750)) That is, C/C++ source code that adheres to the ACLE specification should be portable from one Arm compiler to another as long as each Arm compiler supports the ACLE as documented.

Beginning with version 18.12.x.LTS of the TI Arm Code Generation Tools package, the TI Arm Optimizing C/C++ Compiler supports the Arm C Language Extensions (ACLE) that are applicable to the Cortex-M and Cortex-R Arm processor variants. The latest version of the 18.12.x.LTS TI Arm Code Generation Tools Package can be downloaded from the [Arm code generation tools - compiler](https://www.ti.com/tool/arm-cgt) page.

For a full description of all of the extensions, you should refer to the ACLE specification itself:

* [Arm C Language Extensions Documentation - Release ACLE Q2 2018](https://static.docs.arm.com/101028/0006/Q1-ACLE_2018Q2_release-0006.pdf?_ga=2.48136815.956254943.1548190879-2113270987.1548190750)

## A Sampling of the ACLE

In the sub-sections below, a few examples are provided to show how to use ACLE predefined macro symbols, intrinsics, attributes, and pragmas and how to migrate C/C++ code that makes use of TI-specific pre-defined macro symbols, intrinsics, attributes, and pragmas into compliance with the ACLE specification.


### Testing for Support of ACLE

An Arm compiler that supports the ACLE will define a predefined macro symbol called **__ARM_ACLE** whose value indicates which version of the ACLE specification the Arm compiler claims to support. The value of **__ARM_ACLE** is (100 x major version number) + minor version number. An Arm compiler that implements version 2.0 of the ACLE specification will define **__ARM_ACLE** as (100 x 2) + 0 = 200. 

If you have written your code to comply to version 2.0 of the ACLE specification and you expect an Arm compiler to support version 2.0 or later, then you can test the Arm compiler you are using via:

```cpp
#if !defined(__ARM_ACLE) || (__ARM_ACLE < 200)
#error "Compiler does not support ACLE version 2.0 specification"
#endif
```


### Configure Your Application with ACLE Predefined Macro Symbols

An Arm compiler that supports the ACLE will define the ACLE predefined macro symbols according to the command-line options that the compiler is invoked with. The ACLE predefined macro symbols can be used alone or in combination with other ACLE predefined macro symbols to configure source code that is intended to be included in an application only when compiling for a specific Arm processor variant or architectural feature.

For example, suppose you have a need of a function in your application that performs a signed 16-bit multiplication on the lower half of one incoming signed 32-bit value with the upper half of a second incoming signed 32-bit value. You might write such a function as follows:

```cpp
int32_t mpy_16low_x_16high(int32_t op1, int32_t op2)
{
#if defined(__ARM_FEATURE_DSP)
   return __smulbt(op1, op2);
#else
   int32_t lo_op1 = ((int32_t)(op1 << 16) >> 16);
   int32_t hi_op2 = (op2 >> 16);
   return (lo_op1 * hi_op2);
#endif
}
```

If your application is compiled for an Arm processor variant that supports DSP instructions, such as the Cortex-M4, then the compiler will predefine the macro symbol **__ARM_FEATURE_DSP** to 1. Your implementation of the above mpy_16low_c16high() function will then make use of the **__smulbt()** intrinsic when the source code is compiled for Cortex-M4.

Another useful ACLE predefined symbol that may prove particularly useful is **__ARM_ARCH**. This symbol can be used in combination with other ACLE predefined macro symbols to configure code written for a particular Arm processor variant. The table below shows both the TI Arm compiler (armcl) and clang-based compiler options to specify a particular Arm processor variant and the corresponding TI-specific and ACLE predefined symbols that can be used to configure code for the specified Arm processor variant:

armcl option | clang option | TI predefined symbol | ACLE predefined symbol(s)
-------------|--------------|----------------------|--------------------------
-mv6M0 | -mcpu=cortex-m0 | \_\_TI\_ARM\_V6M0\_\_ | (\_\_ARM\_ARCH == 6) && (\_\_ARM\_ARCH_PROFILE == 'M')
-mv7M3 | -mcpu=cortex-m3 | \_\_TI\_ARM\_V7M3\_\_ | (\_\_ARM\_ARCH == 7) && (\_\_ARM\_ARCH\_PROFILE == 'M') && (\_\_ARM\_FEATURE\_SIMD32 == 0)
-mv7M4 | -mcpu=cortex-m4 | \_\_TI\_ARM\_V7M4\_\_ | (\_\_ARM\_ARCH == 7) && (\_\_ARM\_ARCH\_PROFILE == 'M') && (\_\_ARM\_FEATURE\_SIMD32 == 1)
-mv7R4 | -mcpu=cortex-r4 | \_\_TI\_ARM\_V7R4\_\_ | (\_\_ARM\_ARCH == 7) && (\_\_ARM\_ARCH\_PROFILE == 'R')

If your source code uses a TI-specific predefined macro like **\_\_TI\_ARM\_V6M0\_\_**, to make the code ACLE-compliant you should convert the use of **\_\_TI\_ARM\_V6M0\_\_** into the functionally equivalent (**__ARM_ARCH** == 6) && (**__ARM_ARCH_PROFILE** == 'M') like so:

```
#if defined(__TI_ARM_V6M0__)
<code intended to be compiled for Cortex-M0>
#endif
```

becomes:

```
#if (__ARM_ARCH == 6) && (__ARM_ARCH_PROFILE == 'M')
<code intended to be compiled for Cortex-M0>
#endif
```


### Include the arm_acle.h Header File to Use ACLE Intrinsics

In the include sub-directory of the TI Arm Code Generation Tools package installation, you will find the arm_acle.h header file. Other Arm compilers that support the ACLE will also provide their own versions of the arm_acle.h header file. The arm_acle.h header contains declarations and in many cases definitions of the ACLE intrinsic functions that are supported by thr Arm compiler.

When migrating your code to ACLE-compliance you will want to include the arm_acle.h file in any C/C++ source file that makes use of ACLE intrinsics. 

To make your code more portable and ACLE-compliant, you should replace references to TI-specific intrinsics with the functionally equivalent ACLE version of that intrinsic. For example, if you have references to **_sadd** and **_ssub** in your code, then these should be replaced by **__qadd** and **__qsub**, respectively.

The ACLE specification provides a complete list of portable intrinsics. The following intrinsics are supported by the TI compiler and do not require any transformation to become ACLE-compliant:

*  void     __wfi(void);
*  void     __wfe(void);
*  uint32_t __ror(uint32_t x, uint32_t y);
*  uint32_t __clz(uint32_t x);
*  uint32_t __rev(uint32_t x);
*  uint32_t __rev16(uint32_t x);
*  int16_t  __revsh(int16_t x);
*  uint32_t __rbit(uint32_t x);

#### Map of TI-Specific Intrinsics to ACLE Intrinsics

The tables below provide some guidelines about how to map a TI-specific intrinsic into its functionally equivalent ACLE counterpart. It is recommended that you update your source code to use the ACLE-compliant forms of these intrinsics.

In many cases an extra underscore can be prepended to the name of the intrinsic to make a TI-specific intrinsic name ACLE-compliant, as in the following cases:

TI-Specific Intrinsic Name | Equivalent ACLE Intrinsic Name
---------------------------|-------------------------------
_smulbb  | __smulbb
_smulbt  | __smulbt
_smultb  | __smultb
_smultt  | __smultt
_smulwb  | __smulwb
_smulbw  | __smulbw
_smlabb  | __smlabb
_smlabt  | __smlabt
_smlatb  | __smlatb
_smlatt  | __smlatt
_smlawb  | __smlawb
_smlawt  | __smlawt
_ssat16  | __ssat16
_usat16  | __usat16
_sel     | __sel
_qadd8   | __qadd8
_qadd8   | __qsub8
_qadd8   | __sadd8
_qadd8   | __shadd8
_qadd8   | __shsub8
_qadd8   | __ssub8
_uadd8   | __uadd8
_uhadd8  | __uhadd8
_uhsub8  | __uhsub8
_uqadd8  | __uqadd8
_uqsub8  | __uqsub8
_usub8   | __usub8
_usad8   | __usad8
_qadd16  | __qadd16
_qsub16  | __qsub16
_sadd16  | __sadd16
_shadd16 | __shadd16
_shsub16 | __shsub16
_ssub16  | __ssub16
_uadd16  | __uadd16
_uhadd16 | __uhadd16
_uhsub16 | __uhsub16
_uqadd16 | __uqadd16
_uqsub16 | __uqsub16
_smuad   | __smuad
_smuadx  | __smuadx
_smusd   | __smusd
_smusdx  | __smusdx

In some cases, the TI-specific intrinsic name may require more modification to make it ACLE-compliant, as in the following cases:

TI-Specific Intrinsic Name | Equivalent ACLE Intrinsic Name
---------------------------|-------------------------------
_sadd      | __qadd
_ssub      | __qsub
_qaddsubx  | __qasx
_qsubaddx  | __qsax
_saddsubx  | __sasx
_shaddsubx | __shasx
_shsubaddx | __shsax
_ssubaddx  | __ssax
_uaddsubx  | __uasx
_uhaddsubx | __uhasx
_uhsubaddx | __uhsax
_uqaddsubx | __uqasx
_uqsubaddx | __uqsax
fmaf       | __fmaf
__MCR      | __arm_mcr
__MRC      | __arm_mrc
__MCR2     | __arm_mcr2
__MRC2     | __arm_mrc2
__MCRR     | __arm_mcrr
__MCRR2    | __arm_mcrr2
__MRRC     | __arm_mrrc
__MRRC2    | __arm_mrrc2

A few of the TI-specific intrinsics allow you to specify an optional shift amount to be applied to the input operand, but the ACLE versions of these intrinsics do not allow a shift amount argument to be specified. In such cases, a TI-specific version of the intrinsic can be transformed into its ACLE-compliant form only when the shift amount operand for the TI-specific instrinisc is assumed to be 0, as in the following cases:

TI-Specific Intrinsic | Equivalent ACLE Intrinsic
----------------------|--------------------------
int32_t _ssata(int32_t x, 0, CONST(1,32) y); | int32_t __ssat(int32_t x, CONST(1,32) y);
uint32_t _usata(int32_t x, 0, CONST(0,31) y); | uint32_t __usat(int32_t x, CONST(0,31) y);
int16x2_t _sxtab16(int16x2_t x, int8x4_t y, 0); | int16x2_t __sxtab16(int16x2_t x, int8x4_t y);
int16x2_t _sxtb16(int16x2_t x, 0); | int16x2_t __sxtb16(int16x2_t x);
uint16x2_t _uxtab16(uint16x2_t x, uint8x4_t y, 0); | uint16x2_t __uxtab16(uint16x2_t x, uint8x4_t y);
uint16x2_t _uxtb16(uint16x2_t x, 0); | uint16x2_t __uxtb16(uint16x2_t x);

If the shift amount operand on the TI-specific form of the intrinsic is not 0, then you may need to shift the input operand in place before calling the ACLE form of the intrinsic.

In a few cases, the order of the arguments specified to the TI-specific form of an intrinsic is different from the order of the arguments specified to the ACLE equivalent intrinsic. You will need to account for this reordering of arguments when updating your source code to use the ACLE-compliant versions of the following intrinsics:

TI-Specific Intrinsic | Equivalent ACLE Intrinsic
----------------------|--------------------------
uint32_t _usada8(uint32_t z, uint8x4_t x, uint8x4_t y); | uint32_t __usada8(uin8x4_t x, uint8x4_t y, uint32_t z);
int32_t _smlad(int32_t z, int16x2_t x, int16x2_t y); | int32_t __smlad(int16x2_t x, int16x2_t y, int32_t z);
int32_t _smladx(int32_t z, int16x2_t x, int16x2_t y); | int32_t __smladx(int16x2_t x, int16x2_t y, int32_t z);
int64_t _smlald(int64_t z, int16x2_t x, int16x2_t y); | int64_t __smlald(int16x2_t x, int16x2_t y, int64_t z);
int64_t _smlaldx(int64_t z, int16x2_t x, int16x2_t y); | int64_t __smlaldx(int16x2_t x, int16x2_t y, int64_t z);
int32_t _smlsd(int32_t z, int16x2_t x, int16x2_t y); | int32_t __smlsd(int16x2_t x, int16x2_t y, int32_t z);
int32_t _smlsdx(int32_t z, int16x2_t x, int16x2_t y); | int32_t __smlsdx(int16x2_t x, int16x2_t y, int32_t z);
int64_t _smlsld(int64_t z, int16x2_t x, int16x2_t y); | int64_t __smlsld(int16x2_t x, int16x2_t y, int64_t z);
int64_t _smlsldx(int64_t z, int16x2_t x, int16x2_t y); | int64_t __smlsldx(int16x2_t x, int16x2_t y, int64_t z);


### Use Attributes Instead of Pragmas Where Applicable

The ACLE specification calls for an Arm compiler to support several GCC-style attributes, including: **alias**, **common**, **nocommon**, **noinline**, **packed**, **section**, **visibility**, and **weak**. For more details on these attributes, please refer to available online GCC documentation (see [Extensions to the C Language Family](https://gcc.gnu.org/onlinedocs/gcc/C-Extensions.html#C-Extensions), particularly subsections on function, variable, and type attributes).

In addition to the above GCC-style attributes, the ACLE also calls for an Arm compiler to support the **pcs**, **target**, and **aligned** attributes. While the TI Arm compiler does not support the **pcs** attribute, it does support the **target** and **aligned** attributes. The TI Arm compiler also supports some TI-specific pragmas that are functionally equivalent to some of the attributes listed above.

Among these TI-specific pragmas, some of the more commonly used ones are **DATA_ALIGN**, **CODE_SECTION**, and **DATA_SECTION**. If your source code contains uses of these TI-specific pragmas, then you should convert them into their functionally equivalent attributes to help make your code ACLE-compliant. Consider an example where a data object is required to go into a specific section with a minimum alignment:

In a C source file, you may have applied both a DATA_ALIGN and a DATA_SECTION pragma to a data object to align a data object called "my_global_array" in a specific section:

```cpp
#pragma DATA_SECTION(my_global_array, ".bss:my_global_array")
#pragma DATA_ALIGN("my_global_array", 64)
int my_global_array[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
```

Both of the above pragmas can be replaced by the use of a **section** attribute and an **aligned** attribute as follows:

```cpp
int my_global_array[10] __attribute__((section(".bss:my_global_array"), aligned(64))) = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
```

As you can see, an advantage of using attributes as opposed to pragmas is that attributes can be combined together and may be specified with the declaration or definition of the object to which they apply.


<!-- End of markdown source -->

<div id="footer"></div>
</xmp>
</html>
