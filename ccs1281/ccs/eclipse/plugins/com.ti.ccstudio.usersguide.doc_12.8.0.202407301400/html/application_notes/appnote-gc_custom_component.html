<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="description" content="Instructions for creating a GUI Composer v3 custom component.">
<meta name="product-name" content="GUI Composer">
<meta name="product-link" content="https://dev.ti.com/gc/">
<title>GUI Composer Custom Component</title>
<script src='https://software-dl.ti.com/ccs/esd/documents/web_support_v2/loader.js'></script>
<style>
    figcaption {
        font-size: 12.5px;
        font-style: italic;
        margin-bottom: 20px;
    }
    author {
        display: flex;
        font-style: italic;
    }
    author name {
        flex: 1;
    }
</style>

</head>

<xmp theme="united2" style="display:none;" class="col-xs-6">

<!-- Start of markdown source -->
<author><name>Patrick Chuong</name><group>SDTO</group></author>

# Overview
GUI Composer Designer (GCD) is a WYSIWYG editor that enables embedded developers with little to no frontend experience to quickly create a GUI application
that communicates with TI devices using a variety of communication methods. It comes with a standard core library out of the box, including visual
components and non-visual components, such as a button, graph, gauge, transport, model, and codec. These components are implemented using standard HTML
and Javascript, with the latest W3C standard of WebComponent v1.0. Using the standard core library is sufficient for simple GUI application. However, there
are times that an application requires to have a specific widget that is not included in the core library. This application note provides a guide on how
to create a custom component and register it with GCD to allow dragging and dropping the custom component from the component palette to the application
```index.gui``` file.

This application note assumes that you are experienced in using GCD with the v2 component library and is meant to provide step by step instruction on
creating a v3 custom component that extends the ```gc-widget-label``` component. The custom component will change the label text color and mouse cursor
when it is hovered.

# References
* https://dev.ti.com/gc/designer/help/GC_UserGuide_v2/getting-started.html
* https://stenciljs.com/
* https://www.typescriptlang.org/
* https://sass-lang.com/documentation/syntax/

# Preparations
There are two methods that can be used to create a custom component.
1. By creating a standard WebComponent using the cloud GCD or desktop GCD, this does not require transpile step. This method should only be used when creating
a one-off custom component that is not re-useable in other project.
2. By using StencilJS with desktop GCD, this method requires setting up a build environment. This is the preferred method for long term maintenance,
and the custom component is contribute-able back to the core library.

The second method requires Node v12 to be installed, Node can be downloaded from here https://nodejs.org/dist/latest-v12.x/.

Both methods require a v3 library project. For the purpose of this application note, create a project with the name ```CustomComponent```.

# Creating custom component method 1
This method is simple, there is no build environment to setup or to transpile code. It can be used with the cloud GCD and the desktop GCD. The v3 library has a
helper ```(GcWebComponentHelper)``` class that can be used to simplify the process of developing custom components.

## Steps to create the custom component
* In the ```CustomComponent``` project folder, create a folder with the name ```dist```.
* In the ```dist``` folder, create a file with the name ```gc-widget-enhanced-label.js``` using the sample source code in ```Figure 1```. The sample code has commented out
statements that can be enabled if needed, it also references two external files (html and css) that need to be created in the steps to follow. The
code uses standard WebComponent API with the help of the GcWebComponentHelper class to define properties and bind internal properties within the host.
```
import { GcWebComponentHelper, getModulePath }
    from '../components/@ti/gc-core-webcomponent/lib/GcWebComponentHelper';
const MODULE_PATH = getModulePath(import.meta);
const COMPONENT_NAME = 'gc-widget-enhanced-label';
class WidgetEnhancedLabel extends HTMLElement {
    static get properties() {
        return {
            label: {
                type: 'string',             /* type - boolean|number|string                            */
                value: 'Hover over me!!!',  /* default value                                           */
                // reflect: true,           /* reflect to attribute                                    */
                // notify: true,            /* fire changed event, whenever the property value changed */
            }
        };
    }
    constructor() {
        super();
        this.helper = new GcWebComponentHelper(this, COMPONENT_NAME, MODULE_PATH);

        this.helper.templateHtmlFile = './gc-widget-enhanced-label.html';
        this.helper.cssFile = './gc-widget-enhanced-label.css';

        // property watcher, i.e label
        // this.helper.watch('<property_name>', (newValue, oldValue) => { });

        // event listener, i.e on-clicked
        // this.addEventListener('<event_name>', () => { });

        this.helper.init();
    }
}
customElements.define(COMPONENT_NAME, WidgetEnhancedLabel);
```
<figcaption>Figure 1</figcaption>


* In the ```dist``` folder, create a file with the name ```gc-widget-enhanced-label.html``` using the sample code in ```Figure 2```. This file contains the html
template that will be rendered by the browser. It supports both one-way and two-way internal element-to-element binding. Use ```[[ ]]``` notation for one-way
binding and use ```{{ }}``` notation for two-way binding. The sample code has an element ```gc-widget-label``` with an id ```label```. An element that
uses databinding is required to have a unique id. It also has an attribute ```label``` that is bound to the ```WidgetEnhancedLabel``` custom component
```label``` property.
```html
<gc-widget-label id="label" label="[[label]]" />
```
<figcaption>Figure 2</figcaption>

* In the ```dist``` folder, create a file with the name ```gc-widget-enhanced-label.css``` using the sample code in ```Figure 3```. This file contains CSS
styles that decorate the containing ```gc-widget-label``` element,  having the label change to ```#cc0000``` color and cursor change to ```pointer``` when
the mouse is hovered.
```css
gc-widget-label {
    --gc-hover-color: #cc0000;
    --gc-hover-cursor: pointer;
}
```
<figcaption>Figure 3</figcaption>

# Creating custom component method 2

This method involves some basic knowledge of Typescript and SASS, see the reference links above for more detail on these two technologies. An internet connection is required
to setup the build environment by installing node module packages. It requires a build step to transpile Typescript to Javascript
to generate the final output that can be consumed by the browser.

The custom component is developed using StencilJS, see the reference link above for more information and here is a direct link to the StencilJS component documentation, 
https://stenciljs.com/docs/component/. It has type safety check by using Typescript language and code completion when developing the custom component with Visual Studio Code.

## Steps to create the custom component
* In the ```CustomComponent``` project folder, create a file with name ```package.json``` using the sample JSON object in ```Figure 4```. This file is mainly
used to install the StencilJS node module by running ```npm install```, it also has a npm script to build the custom components.
```json
{
    "name": "customcomponent",
    "version": "1.0.0",
    "description": "",
    "main": "index.js",
    "scripts": {
      "build": "node node_modules/@stencil/core/bin/stencil build"
    },
    "author": "",
    "license": "ISC",
    "dependencies": {
      "@stencil/core": "1.8.11",
      "@stencil/sass": "1.1.1"
    }
  }
```
<figcaption>Figure 4</figcaption>

* In the ```CustomComponent``` project folder, create a file with the name ```stencil.config.ts``` using the sample code in ```Figure 5```. This file is used to
configure the custom component source directory and output target. It also includes the SASS plugin to compile the SASS to CSS.
```Javascript
import { Config } from '@stencil/core';
import { sass } from '@stencil/sass';
export const config: Config = {
    namespace: 'custom-component',
    srcDir: './src',
    plugins:[
        sass({})
    ],
    outputTargets: [
        {
            type: 'www',
            dir: 'dist',
            serviceWorker: null
        }
    ]
};
```
<figcaption>Figure 5</figcaption>

* Open a terminal window and change the directory to the ```CustomComponent``` project folder, enter ```npm install``` and press enter to install the dependent
node modules. You might need to setup a npm proxy if you are behind a corporate proxy. To configure a npm proxy, enter these commands in the terminal window.
    * ```npm config set proxy http://proxy_host:port```
    * ```npm config set https-proxy https://proxy_host:port```
* At this point, the environment is ready to create a custom component using StencilJS. The source should be placed in the ```src``` folder and the output
will be generated in the ```dist``` folder. Now, let's create an enhanced ```gc-widget-label``` custom component.
* In the ```CustomComponent``` project folder, create a ```src``` folder.
* In the ```src``` folder, create a file with the name ```gc-widget-enhanced-label.tsx``` using the sample code in ```Figure 6```. This sample code defines the
custom component with the tag name ```<gc-widget-enhanced-label />``` and has a label property. The render function of this custom component uses a standard
```gc-widget-label``` component and bound the local label property with the containing widget label property. Note that StencilJS does not support two ways
databinding and it uses single mustached notation rather than double mustached notation.
```typescript
import { h, Component, Prop } from '@stencil/core';
@Component({
    tag: 'gc-widget-enhanced-label',
    styleUrl: 'gc-widget-enhanced-label.scss',
    shadow: true
})
export class WidgetEnhancedLabel {
    @Prop() label: string = 'Hover over me!!!';

    render() {
        return <gc-widget-label label={ this.label } />
    }
}
```
<figcaption>Figure 6</figcaption>

* In the ```src``` folder, create a file with name ```gc-widget-enhanced-label.scss``` using the sample SCSS code in ```Figure 7```. These style rules will
only affect elements inside the custom component host. These style rules work the same as method 1 above.
```css
gc-widget-label {
    --gc-hover-color: #cc0000;
    --gc-hover-cursor: pointer;
}
```
<figcaption>Figure 7</figcaption>

* To transpile the .tsx (Typescript) file into .js (Javascript), execute ```npm run build``` in the terminal window of the ```CustomComponent``` project folder.
[[r Caution:
    This action will delete everything inside the ```dist``` folder.
]]


# Registering custom component with GCD
The steps to register the custom component with GCD are the same. However, to use the newly created custom component, it is required to import the custom component
Javascript file in the ```index.gui``` file and will be outlined later in the section blow.

* In the ```CustomComponent``` project folder, create a file with the name ```metadata.json``` using the sample JSON code in ```Figure 8```. This JSON file is
the entry point for GCD to discover custom component(s) for the active project. To add additional custom components, create the corresponding metadata file and add the
relative path file entry to the JSON array.
```json
[
    "metadata/gc-widget-enhanced-label.json"
]
```
<figcaption>Figure 8</figcaption>

* In the ```CustomComponent``` project folder, create a folder with the name ```metadata```. Within the ```metadata``` folder, create a file with name
```gc-widget-enhanced-label.json``` using the sample metadata JSON definition in ```Figure 9```.
```json
{
        "id": "gc-widget-enhanced-label",
        "label": "Enhanced Label",
        "group": "Custom",
        "archetype": "<gc-widget-enhanced-label></gc-widget-enhanced-label>",
        "metaProperties": {
            "label": {
                "name": "label",
                "kind": "string",
                "title": "The label display text"
            }
        },
        "version": 3
}
```
<figcaption>Figure 9</figcaption>

    * id: Prefix for the auto generated component id when it is added to the ```index.gui``` file
    * label: The display label to show in the GCD component palette
    * group: The group name to place this custom component within the component palette
    * archetype: The corresponding HTML markup text to insert in the ```index.gui``` file
    * metaProperties: Defines the matching properties that can be edit by the user using the GCD ```Properties``` view
        * name: The property name to display in the ```Properties``` view
        * kind: The property editor kind, can be ```string|number|boolean|select```
        * title: The tooltip description for the property
    * version: The component library version

* Before custom component can be used in GCD with drag and drop, component needs to be loaded by main  ```index.gui``` file. In GCD, switch the ```index.gui``` file to source mode
and add the following script tag to the top of the file.
    * **Method 1:** ```<script type="module" src="./dist/gc-widget-enhanced-label.js"></script>```, additional custom component Javascript file is required to be include with
        a new script tag.
    * **Method 2:** ```<script type="module" src="./dist/build/custom-component.esm.js"></script>```, this is the only required script tag, all additional custom components
        will be dynamically loaded by the bootstrap ```custom-component.esm.js``` file.
* At this point, everything is ready. Refresh the browser to reload the custom component metadata files.

<!-- End of markdown source -->

<div id="footer"></div>
</xmp>
</html>
