<?xml version="1.0" encoding="utf-8"?>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd" lang="en-us" xml:lang="en-us" data-mc-search-type="Stem" data-mc-help-system-file-name="index.xml" data-mc-path-to-help-system="../../" data-mc-target-type="WebHelp2" data-mc-runtime-file-type="Topic" data-mc-preload-images="false" data-mc-in-preview-mode="false" data-mc-toc-path="">
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <meta charset="utf-8" />
        <meta name="description" content="" />
        <meta name="author" content="" />
        <title>13 Sharing C/C++ Header Files With Assembly Source</title>
        <link href="../../Skins/Default/Stylesheets/Slideshow.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../Skins/Default/Stylesheets/TextEffects.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../Skins/Default/Stylesheets/Topic.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../Skins/Default/Stylesheets/Components/Styles.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../Skins/Default/Stylesheets/Components/Tablet.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../Skins/Default/Stylesheets/Components/Mobile.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../Resources/Stylesheets/headerfooter.css" rel="stylesheet" />
        <script src="../../Resources/Scripts/custom.modernizr.js">
        </script>
        <script src="../../Resources/Scripts/jquery.min.js">
        </script>
        <script src="../../Resources/Scripts/require.min.js">
        </script>
        <script src="../../Resources/Scripts/require.config.js">
        </script>
        <script src="../../Resources/Scripts/foundation.min.js">
        </script>
        <script src="../../Resources/Scripts/plugins.min.js">
        </script>
        <script src="../../Resources/Scripts/MadCapAll.js">
        </script>
    </head>
    <body>
        <div class="content">
            <div id="contentBody">
                <div class="row collapse">
                    <div class="sideContent">
                        <div class="clearfix">
                        </div>
                    </div>
                    <div id="loadContentArea">
                        <div class="c12 docHeader">
                            <div class="c4 docTitle">
                                <p>
                                    <strong>ARM Assembly
							Language Tools
			v18.1.0.LTS User's Guide</strong>
                                    <br />
                                    <span id="litnumber">SPNU118U</span> - REVISED JANUARY 2018</p>
                            </div>
                        </div>
                    </div>
                    <div class="odsHeader">
                        <p class="pdf">
                            <a class="downloadPDF" href="http://www.ti.com/litv/SPNU118U" target="_new">Download PDF</a>
                        </p>
                    </div>
                    <div id="loadContentArea1">
                        <div class="subsection">
                            <h2 id="STDZ0953502">
                                <a MadCap:generatedBookmark="TOC" name="13_Sharing_C_C++_Header_Files_With_Assembly_Source">
                                </a>
                                <span class="section-label">13 </span>Sharing C/C++ Header Files With Assembly Source</h2>
                            <div class="subsection">
                                <p>You can use the .cdecls assembler directive to share C headers containing declarations and prototypes between C and assembly code. Any legal C/C++ can be used in a .cdecls block and the C/C++ declarations will cause suitable assembly to be generated automatically, allowing you to reference the C/C++ constructs in assembly code.</p>
                            </div>
                            <div class="subsection">
                                <h3 id="STDZ095556">
                                    <a MadCap:generatedBookmark="TOC" name="13.1_Overview_of_the_.cdecls_Directive">
                                    </a>
                                    <span class="section-label">13.1 </span>Overview of the .cdecls Directive</h3>
                                <p> The .cdecls directive allows programmers in mixed assembly and C/C++ environments to share C headers containing declarations and prototypes between the C and assembly code. Any legal C/C++ can be used in a .cdecls block and the C/C++ declarations will cause suitable assembly to be generated automatically. This allows the programmer to reference the C/C++ constructs in assembly code — calling functions, allocating space, and accessing structure members — using the equivalent assembly mechanisms. While function and variable definitions are ignored, most common C/C++ elements are converted to assembly: enumerations, (non function-like) macros, function and variable prototypes, structures, and unions. </p>
                                <p>See the <span class="crossreference"><a href="assembler-directives.html#IDcdeclsdesc">.cdecls directive</a></span> description for details on the syntax of the .cdecls assembler directive.</p>
                                <p>The .cdecls directive can appear anywhere in an assembly source file, and can occur multiple times within a file. However, the C/C++ environment created by one .cdecls is <b>not</b> inherited by a later .cdecls; the C/C++ environment starts over for each .cdecls instance. </p>
                                <p>For example, the following code causes the warning to be issued: </p>
                                <code>    .cdecls C,NOLIST
 %{
 #define ASMTEST 1
 %}

 .cdecls C,NOLIST
 %{
 #ifndef ASMTEST
 #warn "ASMTEST not defined!" /* will be issued */
 #endif
 %}</code>
                                <p>Therefore, a typical use of the .cdecls block is expected to be a single usage near the beginning of the assembly source file, in which all necessary C/C++ header files are included. </p>
                                <p>Use the compiler --include_path=<i>path</i> options to specify additional include file paths needed for the header files used in assembly, as you would when compiling C files. </p>
                                <p>Any C/C++ errors or warnings generated by the code of the .cdecls are emitted as they normally would for the C/C++ source code. C/C++ errors cause the directive to fail, and any resulting converted assembly is not included. </p>
                                <p>C/C++ constructs that cannot be converted, such as function-like macros or variable definitions, cause a comment to be output to the converted assembly file. For example: </p>
                                <code>; ASM HEADER WARNING - variable definition 'ABCD' ignored</code>
                                <p>The prefix ASM HEADER WARNING appears at the beginning of each message. To see the warnings, either the WARN parameter needs to be specified so the messages are displayed on STDERR, or else the LIST parameter needs to be specified so the warnings appear in the listing file, if any. </p>
                                <p>Finally, note that the converted assembly code does not appear in the same order as the original C/C++ source code and C/C++ constructs may be simplified to a normalized form during the conversion process, but this should not affect their final usage. </p>
                            </div>
                            <div class="subsection">
                                <h3 id="STDZ0956208">
                                    <a MadCap:generatedBookmark="TOC" name="13.2_Notes_on_C_C++_Conversions">
                                    </a>
                                    <span class="section-label">13.2 </span>Notes on C/C++ Conversions</h3>
                                <p> The following sections describe C and C++ conversion elements that you need to be aware of when sharing header files with assembly source.</p>
                                <div class="subsection">
                                    <h4 id="STDZ0955743">
                                        <a MadCap:generatedBookmark="TOC" name="13.2.1_Comments">
                                        </a>
                                        <span class="section-label">13.2.1 </span>Comments</h4>
                                    <p> Comments are consumed entirely at the C level, and do not appear in the resulting converted assembly file. </p>
                                </div>
                                <div class="subsection">
                                    <h4 id="STDZ0953795">
                                        <a MadCap:generatedBookmark="TOC" name="13.2.2_Conditional_Compilation_(_if__else__ifdef_etc.)">
                                        </a>
                                        <span class="section-label">13.2.2 </span>Conditional Compilation (#if/#else/#ifdef/etc.)</h4>
                                    <p> Conditional compilation is handled entirely at the C level during the conversion step. Define any necessary macros either on the command line (using the compiler --define=<i>name</i>=<i>value</i> option) or within a .cdecls block using #define. The #if, #ifdef, etc. C/C++ directives are <b>not</b> converted to assembly .if, .else, .elseif, and .endif directives. </p>
                                </div>
                                <div class="subsection">
                                    <h4 id="SPRU1869005">
                                        <a MadCap:generatedBookmark="TOC" name="13.2.3_Pragmas">
                                        </a>
                                        <span class="section-label">13.2.3 </span>Pragmas</h4>
                                    <p> Pragmas found in the C/C++ source code cause a warning to be generated as they are not converted. They have no other effect on the resulting assembly file. See <span class="crossreference"><a href="assembler-directives.html#IDcdeclsdesc">the .cdecls topic</a></span> for the WARN and NOWARN parameter discussion for where these warnings are created.</p>
                                </div>
                                <div class="subsection">
                                    <h4 id="STDZ095920">
                                        <a MadCap:generatedBookmark="TOC" name="13.2.4_The__error_and__warning_Directives">
                                        </a>
                                        <span class="section-label">13.2.4 </span>The #error and #warning Directives</h4>
                                    <p> These preprocessor directives are handled completely by the compiler during the parsing step of conversion. If one of these directives is encountered, the appropriate error or warning message is emitted. These directives are not converted to .emsg or .wmsg in the assembly output. </p>
                                </div>
                                <div class="subsection">
                                    <h4 id="STDZ0952442">
                                        <a MadCap:generatedBookmark="TOC" name="13.2.5_Predefined_symbol____ASM_HEADER___">
                                        </a>
                                        <span class="section-label">13.2.5 </span>Predefined symbol _ _ASM_HEADER_ _</h4>
                                    <p> The C/C++ macro _ _ASM_HEADER_ _ is defined in the compiler while processing code within .cdecls. This allows you to make changes in your code, such as not compiling definitions, during the .cdecls processing. </p>
                                    <span class="note">
                                        <p class="note_title">NOTE</p>
                                        <b>Be Careful With the _ _ASM_HEADER_ _ Macro</b>
                                        <p>You must be very careful not to use this macro to introduce any changes in the code that could result in inconsistencies between the code processed while compiling the C/C++ source and while converting to assembly.</p>
                                    </span>
                                </div>
                                <div class="subsection">
                                    <h4 id="STDZ0952566">
                                        <a MadCap:generatedBookmark="TOC" name="13.2.6_Usage_Within_C_C++_asm(_)_Statements">
                                        </a>
                                        <span class="section-label">13.2.6 </span>Usage Within C/C++ asm( ) Statements</h4>
                                    <p> The .cdecls directive is not allowed within C/C++ asm( ) statements and will cause an error to be generated. </p>
                                </div>
                                <div class="subsection">
                                    <h4 id="STDZ0952071">
                                        <a MadCap:generatedBookmark="TOC" name="13.2.7_The__include_Directive">
                                        </a>
                                        <span class="section-label">13.2.7 </span>The #include Directive</h4>
                                    <p> The C/C++ #include preprocessor directive is handled transparently by the compiler during the conversion step. Such #includes can be nested as deeply as desired as in C/C++ source. The assembly directives .include and .copy are not used or needed within a .cdecls. Use the command line --include_path option to specify additional paths to be searched for included files, as you would for C compilation. </p>
                                </div>
                                <div class="subsection">
                                    <h4 id="STDZ0952685">
                                        <a MadCap:generatedBookmark="TOC" name="13.2.8_Conversion_of__define_Macros">
                                        </a>
                                        <span class="section-label">13.2.8 </span>Conversion of #define Macros</h4>
                                    <p> Only object-like macros are converted to assembly. Function-like macros have no assembly representation and so cannot be converted. Pre-defined and built-in C/C++ macros are not converted to assembly (i.e., __FILE__, __TIME__, __TI_COMPILER_VERSION__, etc.). For example, this code is converted to assembly because it is an object-like macro:</p>
                                    <code>#define NAME Charley</code>
                                    <p>This code is not converted to assembly because it is a function-like macro:</p>
                                    <code>#define MAX(x,y) (x&gt;y ? x : y)</code>
                                    <p>Some macros, while they are converted, have no functional use in the containing assembly file. For example, the following results in the assembly substitution symbol FOREVER being set to the value while(1), although this has no useful use in assembly because while(1) is not legal assembly code.</p>
                                    <code>#define FOREVER while(1)</code>
                                    <p>Macro values are <b>not</b> interpreted as they are converted. For example, the following results in the assembler substitution symbol OFFSET being set to the literal string value 5+12 and <b>not</b> the value 17. This happens because the semantics of the C/C++ language require that macros are evaluated in context and not when they are parsed.</p>
                                    <code>#define OFFSET 5+12</code>
                                    <p>Because macros in C/C++ are evaluated in their usage context, C/C++ printf escape sequences such as \n are not converted to a single character in the converted assembly macro. See <span class="crossreference"><a href="#STDZ0959975">Section 13.2.11</a></span> for suggestions on how to use C/C++ macro strings. </p>
                                    <p>Macros are converted using the .define directive (see <span class="crossreference"><a href="#STDZ0955397">Section 13.4.2</a></span>), which functions similarly to the .asg assembler directive. The exception is that .define disallows redefinitions of register symbols and mnemonics to prevent the conversion from corrupting the basic assembly environment. To remove a macro from the assembly scope, .undef can be used following the .cdecls that defines it (see <span class="crossreference"><a href="#STDZ0959759">Section 13.4.3</a></span>). </p>
                                    <p>The macro functionality of # (stringize operator) is only useful within functional macros. Since functional macros are not supported by this process, # is not supported either. The concatenation operator ## is only useful in a functional context, but can be used degenerately to concatenate two strings and so it is supported in that context. </p>
                                </div>
                                <div class="subsection">
                                    <h4 id="STDZ0951764">
                                        <a MadCap:generatedBookmark="TOC" name="13.2.9_The__undef_Directive">
                                        </a>
                                        <span class="section-label">13.2.9 </span>The #undef Directive</h4>
                                    <p> Symbols undefined using the #undef directive before the end of the .cdecls are not converted to assembly. </p>
                                </div>
                                <div class="subsection">
                                    <h4 id="STDZ0959730">
                                        <a MadCap:generatedBookmark="TOC" name="13.2.10_Enumerations">
                                        </a>
                                        <span class="section-label">13.2.10 </span>Enumerations </h4>
                                    <p> Enumeration members are converted to .enum elements in assembly. For example: </p>
                                    <code>enum state { ACTIVE=0x10, SLEEPING=0x01, INTERRUPT=0x100, POWEROFF, LAST}; </code>
                                    <p>is converted to the following assembly code: </p>
                                    <code>state .enum
ACTIVE .emember 16
SLEEPING .emember 1
NTERRUPT .emember 256
POWEROFF .emember 257
LAST .emember 258
 .endenum</code>
                                    <p>The members are used via the pseudo-scoping created by the .enum directive.</p>
                                    <p>The usage is similar to that for accessing structure members, enum_name.member.</p>
                                    <p>This pseudo-scoping is used to prevent enumeration member names from corrupting other symbols within the assembly environment. </p>
                                </div>
                                <div class="subsection">
                                    <h4 id="STDZ0959975">
                                        <a MadCap:generatedBookmark="TOC" name="13.2.11_C_Strings">
                                        </a>
                                        <span class="section-label">13.2.11 </span>C Strings</h4>
                                    <p> Because C string escapes such as \n and \t are not converted to hex characters 0x0A and 0x09 until their use in a string constant in a C/C++ program, C macros whose values are strings cannot be represented as expected in assembly substitution symbols. For example: </p>
                                    <code>#define MSG "\tHI\n"</code>
                                    <p>becomes, in assembly: </p>
                                    <code>.define """\tHI\n""",MSG ; 6 quoted characters! not 5!</code>
                                    <p>When used in a C string context, you expect this statement to be converted to 5 characters (tab, H, I, newline, NULL), but the .string assembler directive does not know how to perform the C escape conversions. </p>
                                    <p>You can use the .cstring directive to cause the escape sequences and NULL termination to be properly handled as they would in C/C++. Using the above symbol MSG with a .cstring directive results in 5 characters of memory being allocated, the same characters as would result if used in a C/C++ strong context. (See <span class="crossreference"><a href="#STDZ0958507">Section 13.4.7</a></span> for the .cstring directive syntax.) </p>
                                </div>
                                <div class="subsection">
                                    <h4 id="STDZ0954746">
                                        <a MadCap:generatedBookmark="TOC" name="13.2.12_C_C++_Built-In_Functions">
                                        </a>
                                        <span class="section-label">13.2.12 </span>C/C++ Built-In Functions</h4>
                                    <p> The C/C++ built-in functions, such as sizeof( ), are not translated to their assembly counterparts, if any, if they are used in macros. Also, their C expression values are not inserted into the resulting assembly macro because macros are evaluated in context and there is no active context when converting the macros to assembly. </p>
                                    <p>Suitable functions such as <span>$</span>$sizeof( ) are available in assembly expressions. However, as the basic types such as int/char/float have no type representation in assembly, there is no way to ask for <span>$</span>$sizeof(int), for example, in assembly. </p>
                                </div>
                                <div class="subsection">
                                    <h4 id="STDZ0956761">
                                        <a MadCap:generatedBookmark="TOC" name="13.2.13_Structures_and_Unions">
                                        </a>
                                        <span class="section-label">13.2.13 </span>Structures and Unions</h4>
                                    <p> C/C++ structures and unions are converted to assembly .struct and .union elements. Padding and ending alignments are added as necessary to make the resulting assembly structure have the same size and member offsets as the C/C++ source. The primary purpose is to allow access to members of C/C++ structures, as well as to facilitate debugging of the assembly code. For nested structures, the assembly .tag feature is used to refer to other structures/unions. </p>
                                    <p>The alignment is also passed from the C/C++ source so that the assembly symbol is marked with the same alignment as the C/C++ symbol. (See <span class="crossreference"><a href="#SPRU1869005">Section 13.2.3</a></span> for information about pragmas, which may attempt to modify structures.) Because the alignment of structures is stored in the assembly symbol, built-in assembly functions like <span>$</span>$sizeof( ) and <span>$</span>$alignof( ) can be used on the resulting structure name symbol. </p>
                                    <p>When using unnamed structures (or unions) in typedefs, such as:</p>
                                    <code>typedef struct { int a_member; } mystrname;</code>
                                    <p>This is really a shorthand way of writing: </p>
                                    <code>struct temporary_name { int a_member; };
typedef temporary_name mystrname;</code>
                                    <p>The conversion processes the above statements in the same manner: generating a temporary name for the structure and then using .define to output a typedef from the temporary name to the user name. You should use your <i>mystrname</i> in assembly the same as you would in C/C++, but do not be confused by the assembly structure definition in the list, which contains the temporary name. You can avoid the temporary name by specifying a name for the structure, as in:</p>
                                    <code>typedef struct a_st_name { ... } mystrname;</code>
                                    <p>If a shorthand method is used in C to declare a variable with a particular structure, for example:</p>
                                    <code>extern struct a_name { int a_member; } a_variable;</code>
                                    <p>Then after the structure is converted to assembly, a .tag directive is generated to declare the structure of the external variable, such as: </p>
                                    <code>_a_variable .tag a_st_name</code>
                                    <p>This allows you to refer to _a_variable.a_member in your assembly code. </p>
                                </div>
                                <div class="subsection">
                                    <h4 id="STDZ0957520">
                                        <a MadCap:generatedBookmark="TOC" name="13.2.14_Function_Variable_Prototypes">
                                        </a>
                                        <span class="section-label">13.2.14 </span>Function/Variable Prototypes</h4>
                                    <p> Non-static function and variable prototypes (not definitions) will result in a .global directive being generated for each symbol found. </p>
                                    <p>See <span class="crossreference"><a href="#STDZ0953435">Section 13.3.1</a></span> for C++ name mangling issues. </p>
                                    <p>Function and variable definitions will result in a warning message being generated (see the WARN/NOWARN parameter discussion for where these warnings are created) for each, and they will not be represented in the converted assembly. </p>
                                    <p>The assembly symbol representing the variable declarations will not contain type information about those symbols. Only a .global will be issued for them. Therefore, it is your responsibility to ensure the symbol is used appropriately. </p>
                                    <p>See <span class="crossreference"><a href="#STDZ0956761">Section 13.2.13</a></span> for information on variables names which are of a structure/union type. </p>
                                </div>
                                <div class="subsection">
                                    <h4 id="STDZ0959775">
                                        <a MadCap:generatedBookmark="TOC" name="13.2.15_C_Constant_Suffixes">
                                        </a>
                                        <span class="section-label">13.2.15 </span>C Constant Suffixes </h4>
                                    <p> The C constant suffixes u, l, and f are passed to the assembly unchanged. The assembler will ignore these suffixes if used in assembly expressions. </p>
                                </div>
                                <div class="subsection">
                                    <h4 id="STDZ0953349">
                                        <a MadCap:generatedBookmark="TOC" name="13.2.16_Basic_C_C++_Types">
                                        </a>
                                        <span class="section-label">13.2.16 </span>Basic C/C++ Types </h4>
                                    <p> Only complex types (structures and unions) in the C/C++ source code are converted to assembly. Basic types such as int, char, or float are not converted or represented in assembly beyond any existing .int, .char, .float, etc. directives that previously existed in assembly. </p>
                                    <p>Typedefs of basic types are therefore also not represented in the converted assembly. </p>
                                </div>
                            </div>
                            <div class="subsection">
                                <h3 id="STDZ0951513">
                                    <a MadCap:generatedBookmark="TOC" name="13.3_Notes_on_C++_Specific_Conversions">
                                    </a>
                                    <span class="section-label">13.3 </span>Notes on C++ Specific Conversions</h3>
                                <p> The following sections describe C++ specific conversion elements that you need to be aware of when sharing header files with assembly source.</p>
                                <div class="subsection">
                                    <h4 id="STDZ0953435">
                                        <a MadCap:generatedBookmark="TOC" name="13.3.1_Name_Mangling">
                                        </a>
                                        <span class="section-label">13.3.1 </span>Name Mangling</h4>
                                    <p> Symbol names may be mangled in C++ source files. When mangling occurs, the converted assembly will use the mangled names to avoid symbol name clashes. You can use the demangler (<span>armdem</span>) to demangle names and identify the correct symbols to use in assembly. </p>
                                    <p>To defeat name mangling in C++ for symbols where polymorphism (calling a function of the same name with different kinds of arguments) is not required, use the following syntax: </p>
                                    <code>extern "C" void somefunc(int arg);</code>
                                    <p>The above format is the short method for declaring a single function. To use this method for multiple functions, you can also use the following syntax: </p>
                                    <code>extern "C" {
 void somefunc(int arg);
 int anotherfunc(int arg);
 ...
 }</code>
                                </div>
                                <div class="subsection">
                                    <h4 id="STDZ0952970">
                                        <a MadCap:generatedBookmark="TOC" name="13.3.2_Derived_Classes">
                                        </a>
                                        <span class="section-label">13.3.2 </span>Derived Classes</h4>
                                    <p> Derived classes are only partially supported when converting to assembly because of issues related to C++ scoping which does not exist in assembly. The greatest difference is that base class members do not automatically become full (top-level) members of the derived class. For example:</p>
                                    <code>----------------------------------------------------------
 class base
 {
 public:
 int b1;
 };

 class derived : public base
 {
 public:
 int d1;
 }</code>
                                    <p>In C++ code, the class derived would contain both integers b1 and d1. In the converted assembly structure "derived", the members of the base class must be accessed using the name of the base class, such as derived.__b_base.b1 rather than the expected derived.b1.</p>
                                    <p>A non-virtual, non-empty base class will have __b_ prepended to its name within the derived class to signify it is a base class name. That is why the example above is derived.__b_base.b1 and not simply derived.base.b1.</p>
                                </div>
                                <div class="subsection">
                                    <h4 id="STDZ095475">
                                        <a MadCap:generatedBookmark="TOC" name="13.3.3_Templates">
                                        </a>
                                        <span class="section-label">13.3.3 </span>Templates</h4>
                                    <p> No support exists for templates. </p>
                                </div>
                                <div class="subsection">
                                    <h4 id="STDZ0951134">
                                        <a MadCap:generatedBookmark="TOC" name="13.3.4_Virtual_Functions">
                                        </a>
                                        <span class="section-label">13.3.4 </span>Virtual Functions </h4>
                                    <p> No support exists for virtual functions, as they have no assembly representation. </p>
                                </div>
                            </div>
                            <div class="subsection">
                                <h3 id="STDZ0952927">
                                    <a MadCap:generatedBookmark="TOC" name="13.4_Special_Assembler_Support">
                                    </a>
                                    <span class="section-label">13.4 </span>Special Assembler Support</h3>
                                <div class="subsection">
                                    <h4 id="STDZ0955032">
                                        <a MadCap:generatedBookmark="TOC" name="13.4.1_Enumerations_(.enum_.emember_.endenum)">
                                        </a>
                                        <span class="section-label">13.4.1 </span>Enumerations (.enum/.emember/.endenum)</h4>
                                    <p> The following directives support a pseudo-scoping for enumerations:</p>
                                    <div class="subsection">
                                        <table class="tabbedtext">
                                            <colgroup>
                                                <col align="left" />
                                                <col align="left" />
                                            </colgroup>
                                            <tbody>
                                                <tr>
                                                    <td> <i>ENUM_NAME</i> <![CDATA[ ]]></td>
                                                    <td> <b>.enum</b> <![CDATA[ ]]></td>
                                                </tr>
                                                <tr>
                                                    <td> <i>MEMBER1</i> <![CDATA[ ]]></td>
                                                    <td> <b>.emember</b> [<i>value</i>]</td>
                                                </tr>
                                                <tr>
                                                    <td> <i>MEMBER2</i> <![CDATA[ ]]></td>
                                                    <td> <b>.emember</b> [<i>value</i>]</td>
                                                </tr>
                                                <tr>
                                                    <td>...</td>
                                                    <td />
                                                </tr>
                                                <tr>
                                                    <td />
                                                    <td> <b>.endenum </b> <![CDATA[ ]]></td>
                                                </tr>
                                            </tbody>
                                        </table>
                                    </div>
                                    <p>The <b>.enum</b> directive begins the enumeration definition and <b>.endenum</b> terminates it.</p>
                                    <p>The enumeration name (<i>ENUM_NAME</i>) cannot be used to allocate space; its size is reported as zero. </p>
                                    <p>The format to use the value of a member is <i>ENUM_NAME.MEMBER</i>, similar to a structure member usage. </p>
                                    <p>The <b>.emember</b> directive optionally accepts the value to set the member to, just as in C/C++. If not specified, the member takes a value one more than the previous member. As in C/C++, member names cannot be duplicated, although values can be. Unless specified with .emember, the first enumeration member will be given the value 0 (zero), as in C/C++. </p>
                                    <p>The .endenum directive cannot be used with a label, as structure .endstruct directives can, because the .endenum directive has no value like the .endstruct does (containing the size of the structure). </p>
                                    <p>Conditional compilation directives (.if/.else/.elseif/.endif) are the only other non-enumeration code allowed within the .enum/.endenum sequence. </p>
                                </div>
                                <div class="subsection">
                                    <h4 id="STDZ0955397">
                                        <a MadCap:generatedBookmark="TOC" name="13.4.2_The_.define_Directive">
                                        </a>
                                        <span class="section-label">13.4.2 </span>The .define Directive</h4>
                                    <p> The .define directive functions in the same manner as the .asg directive, except that .define disallows creation of a substitution symbol that has the same name as a register symbol or mnemonic. It does not create a new symbol name space in the assembler, rather it uses the existing substitution symbol name space. The syntax for the directive is:</p>
                                    <p> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<b>.define</b>&#160;<i>substitution string</i><b>,</b>&#160;<i>substitution symbol name</i></p>
                                    <p>The .define directive is used to prevent corruption of the assembly environment when converting C/C++ headers.</p>
                                </div>
                                <div class="subsection">
                                    <h4 id="STDZ0959759">
                                        <a MadCap:generatedBookmark="TOC" name="13.4.3_The_.undefine_.unasg_Directives">
                                        </a>
                                        <span class="section-label">13.4.3 </span>The .undefine/.unasg Directives</h4>
                                    <p> The .undef directive is used to remove the definition of a substitution symbol created using .define or .asg. This directive will remove the named symbol from the substitution symbol table from the point of the .undef to the end of the assembly file. The syntax for these directives is:</p>
                                    <p> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<b>.undefine</b>&#160;<i>substitution symbol name</i></p>
                                    <p> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<b>.unasg</b>&#160;&#160;&#160;<i>substitution symbol name</i></p>
                                    <p>This can be used to remove from the assembly environment any C/C++ macros that may cause a problem. </p>
                                    <p>Also see <span class="crossreference"><a href="#STDZ0955397">Section 13.4.2</a></span>, which covers the .define directive. </p>
                                </div>
                                <div class="subsection">
                                    <h4 id="STDZ0953052">
                                        <a MadCap:generatedBookmark="TOC" name="13.4.4_The_$$defined(_)_Built-In_Function">
                                        </a>
                                        <span class="section-label">13.4.4 </span>The <span>$</span>$defined( ) Built-In Function</h4>
                                    <p> The <span>$</span>$defined directive returns true/1 or false/0 depending on whether the name exists in the current substitution symbol table or the standard symbol table. In essence <span>$</span>$defined returns TRUE if the assembler has any user symbol in scope by that name. This differs from <span>$</span>$isdefed in that <span>$</span>$isdefed only tests for NON-substitution symbols. The syntax is: </p>
                                    <p> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<b><span>$</span>$defined(</b>&#160;<i>substitution symbol name</i><b>)</b></p>
                                    <p>A statement such as ".if <span>$</span>$defined(macroname)" is then similar to the C code "#ifdef macroname". </p>
                                    <p>See <span class="crossreference"><a href="#STDZ0955397">Section 13.4.2</a></span> and <span class="crossreference"><a href="#STDZ0959759">Section 13.4.3</a></span> for the use of .define and .undef in assembly. </p>
                                </div>
                                <div class="subsection">
                                    <h4 id="STDZ0959533">
                                        <a MadCap:generatedBookmark="TOC" name="13.4.5_The_$$sizeof_Built-In_Function">
                                        </a>
                                        <span class="section-label">13.4.5 </span>The <span>$</span>$sizeof Built-In Function</h4>
                                    <p> The assembly built-in function <span>$</span>$sizeof( ) can be used to query the size of a structure in assembly. It is an alias for the already existing <span>$</span>$structsz( ). The syntax is:</p>
                                    <p> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<b><span>$</span>$sizeof(</b>&#160;<i>structure name</i><b>)</b></p>
                                    <p>The <span>$</span>$sizeof function can then be used similarly to the C built-in function sizeof( ).</p>
                                    <p>The assembler's <span>$</span>$sizeof( ) built-in function cannot be used to ask for the size of basic C/C++ types, such as <span>$</span>$sizeof(int), because those basic type names are not represented in assembly. Only complex types are converted from C/C++ to assembly. </p>
                                    <p>Also see <span class="crossreference"><a href="#STDZ0954746">Section 13.2.12</a></span>, which notes that this conversion does not happen automatically if the C/C++ sizeof( ) built-in function is used within a macro. </p>
                                </div>
                                <div class="subsection">
                                    <h4 id="STDZ0957554">
                                        <a MadCap:generatedBookmark="TOC" name="13.4.6_Structure_Union_Alignment_and_$$alignof(_)">
                                        </a>
                                        <span class="section-label">13.4.6 </span>Structure/Union Alignment and <span>$</span>$alignof( )</h4>
                                    <p> The assembly .struct and .union directives take an optional second argument which can be used to specify a minimum alignment to be applied to the symbol name. This is used by the conversion process to pass the specific alignment from C/C++ to assembly. </p>
                                    <p>The assembly built-in function <span>$</span>$alignof( ) can be used to report the alignment of these structures. This can be used even on assembly structures, and the function will return the minimum alignment calculated by the assembler. </p>
                                </div>
                                <div class="subsection">
                                    <h4 id="STDZ0958507">
                                        <a MadCap:generatedBookmark="TOC" name="13.4.7_The_.cstring_Directive">
                                        </a>
                                        <span class="section-label">13.4.7 </span>The .cstring Directive</h4>
                                    <p> You can use the .cstring directive to cause the escape sequences and NULL termination to be properly handled as they would in C/C++. </p>
                                    <code>    .cstring "String with C escapes.\nWill be NULL terminated.\012"</code>
                                    <p>See <span class="crossreference"><a href="#STDZ0959975">Section 13.2.11</a></span> for more information on the .cstring directive. </p>
                                </div>
                            </div>
                        </div>
                    </div>
                    <a href="../Resources/MasterPages/..SPNU118U_HTML/abstract.html">Back to Top</a>
                    <p />
                    <a href="http://www.go-dsp.com/forms/techdoc/doc_feedback.htm?litnum=SPNU118U&amp;partnum=ARM">Submit Documentation Feedback</a>
                    <p>Copyright© 2018, Texas Instruments Incorporated. An <a href="includes/important_notice.html">IMPORTANT NOTICE</a> for this document addresses availability, warranty, changes, use in safety-critical applications, intellectual property matters and other important disclaimers.</p>
                </div>
            </div>
        </div>
    </body>
</html>