<!DOCTYPE html>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd" lang="en-us" xml:lang="en-us" data-mc-search-type="Stem" data-mc-help-system-file-name="index.xml" data-mc-path-to-help-system="../../" data-mc-target-type="WebHelp2" data-mc-runtime-file-type="Topic" data-mc-preload-images="false" data-mc-in-preview-mode="false" data-mc-toc-path="">
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <meta charset="utf-8" />
        <meta name="description" content="" />
        <meta name="author" content="" /><title>12 Hex Conversion Utility Description</title>
        <link href="../../Skins/Default/Stylesheets/Slideshow.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../Skins/Default/Stylesheets/TextEffects.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../Skins/Default/Stylesheets/Topic.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../Skins/Default/Stylesheets/Components/Styles.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../Skins/Default/Stylesheets/Components/Tablet.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../Skins/Default/Stylesheets/Components/Mobile.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../Resources/Stylesheets/headerfooter.css" rel="stylesheet" />
        <script src="../../Resources/Scripts/custom.modernizr.js">
        </script>
        <script src="../../Resources/Scripts/jquery.min.js">
        </script>
        <script src="../../Resources/Scripts/require.min.js">
        </script>
        <script src="../../Resources/Scripts/require.config.js">
        </script>
        <script src="../../Resources/Scripts/foundation.min.js">
        </script>
        <script src="../../Resources/Scripts/plugins.min.js">
        </script>
        <script src="../../Resources/Scripts/MadCapAll.js">
        </script>
    </head>
    <body>
        <div class="content">
            <div id="contentBody">
                <div class="row collapse">
                    <div class="sideContent">
                        <div class="clearfix">
                        </div>
                    </div>
                    <div id="loadContentArea">
                        <div class="c12 docHeader">
                            <div class="c4 docTitle">
                                <p><strong>ARM Assembly
							Language Tools
			v18.1.0.LTS User's Guide</strong>
                                    <br /><span id="litnumber">SPNU118U</span> - REVISED JANUARY 2018</p>
                            </div>
                        </div>
                    </div>
                    <div class="odsHeader">
                        <p class="pdf"><a class="downloadPDF" href="http://www.ti.com/litv/SPNU118U" target="_new">Download PDF</a>
                        </p>
                    </div>
                    <div id="loadContentArea1">
                        <div class="subsection">
                            <h2 id="STDZ0790730"><a name="12_Hex_Conversion_Utility_Description" data-mc-generated-bookmark="TOC"></a><span class="section-label">12 </span>Hex Conversion Utility Description</h2>
                            <div class="subsection">
                                <p> The <span>ARM</span> assembler and linker create object files which are in binary formats that encourage modular programming and provide powerful and flexible methods for managing code segments and target system memory.</p>
                                <p>Most EPROM programmers do not accept object files as input. The hex conversion utility converts an object file into one of several standard ASCII hexadecimal formats, suitable for loading into an EPROM programmer. The utility is also useful in other applications requiring hexadecimal conversion of an object file (for example, when using debuggers and loaders).</p>
                                <p>The hex conversion utility can produce these output file formats: </p>
                                <ul>
                                    <li value="1"> ASCII-Hex, supporting <span>16-bit</span> addresses</li>
                                    <li value="2">Extended Tektronix (Tektronix)</li>
                                    <li value="3"> Intel MCS-86 (Intel)</li>
                                    <li value="4"> Motorola Exorciser (Motorola-S), supporting 16-bit addresses</li>
                                    <li value="5"> Texas Instruments SDSMAC (TI-Tagged), supporting 16-bit addresses</li>
                                    <li value="6"> Texas Instruments TI-TXT format, supporting 16-bit addresses</li>
                                    <li id="t365188-4" value="7">C arrays</li>
                                </ul>
                            </div>
                            <div class="subsection">
                                <h3 id="STDZ0798702"><a name="12.1_The_Hex_Conversion_Utility's_Role_in_the_Software_Development_Flow" data-mc-generated-bookmark="TOC"></a><span class="section-label">12.1 </span>The Hex Conversion Utility's Role in the Software Development Flow</h3>
                                <p><span class="crossreference"><a href="#STDZ0795017" class="selected">Figure 12-1</a></span> highlights the role of the hex conversion utility in the software development process. </p>
                                <div class="figure"><span class="caption" id="STDZ0795017"><span class="figure-label">Figure 12-1 </span>The Hex Conversion Utility in the <span>ARM</span> Software Development Flow</span> <img alt="hexconvflow_pnu118.gif" itemprop="image" src="ods/images/SPNU118U/hexconvflow_pnu118.gif" title="The Hex Conversion Utility in&#xA;    the ARM&#xA;    Software Development Flow" /> </div>
                            </div>
                            <div class="subsection">
                                <h3 id="STDZ0796941"><a name="12.2_Invoking_the_Hex_Conversion_Utility" data-mc-generated-bookmark="TOC"></a><span class="section-label">12.2 </span>Invoking the Hex Conversion Utility</h3>
                                <p>There are two basic methods for invoking the hex conversion utility:</p>
                                <ul>
                                    <li value="1"><b>Specify the options and filenames on the command line.</b> The following example converts the file firmware.out into TI-Tagged format, producing two output files, firm.lsb and firm.msb.</li><code>    armhex -t firmware -o firm.lsb -o firm.msb</code>
                                    <li value="2"><b>Specify the options and filenames in a command file.</b> You can create a file that stores command line options and filenames for invoking the hex conversion utility. The following example invokes the utility using a command file called hexutil.cmd:</li><code>    armhex hexutil.cmd</code>
                                </ul>
                                <p>In addition to regular command line information, you can use the hex conversion utility ROMS and SECTIONS directives in a command file.</p>
                                <div class="subsection">
                                    <h4 id="STDZ0790731"><a name="12.2.1_Invoking_the_Hex_Conversion_Utility_From_the_Command_Line" data-mc-generated-bookmark="TOC"></a><span class="section-label">12.2.1 </span>Invoking the Hex Conversion Utility From the Command Line</h4>
                                    <p>To invoke the hex conversion utility, enter:</p>
                                    <div class="subsection">
                                        <table class="tabbedtext">
                                            <colgroup>
                                                <col />
                                            </colgroup>
                                            <tbody>
                                                <tr>
                                                    <td> <b> <span>armhex</span> <![CDATA[ ]]></b>[<i>options</i>] <i>filename</i> <![CDATA[ ]]></td>
                                                </tr>
                                            </tbody>
                                        </table>
                                    </div>
                                    <div class="subsection">
                                        <table class="tabbedtext">
                                            <colgroup>
                                                <col align="left" />
                                                <col align="left" />
                                            </colgroup>
                                            <tbody align="left">
                                                <tr>
                                                    <td class="noBorderBottom" valign="top"> <b> <span>armhex</span> <![CDATA[ ]]></b> <![CDATA[ ]]></td>
                                                    <td valign="top">is the command that invokes the hex conversion utility.</td>
                                                </tr>
                                                <tr>
                                                    <td valign="top"> <i>options</i></td>
                                                    <td valign="top">
                                                        <p>supplies additional information that controls the hex conversion process. You can use options on the command line or in a command file. <span class="crossreference"><a href="#STDZ079114" class="selected">Table 12-1</a></span> lists the basic options.</p>
                                                        <ul>
                                                            <li value="1">All options are preceded by a hyphen and are not case sensitive.</li>
                                                            <li value="2">Several options have an additional parameter that must be separated from the option by at least one space.</li>
                                                            <li value="3">Options with multi-character names must be spelled exactly as shown in this document; no abbreviations are allowed.</li>
                                                            <li value="4">Options are not affected by the order in which they are used. The exception to this rule is the --quiet option, which must be used before any other options.</li>
                                                        </ul>
                                                    </td>
                                                </tr>
                                                <tr>
                                                    <td valign="top"> <i>filename</i></td>
                                                    <td valign="top">names an object file or a command file (for more information, see <span class="crossreference"><a href="#STDZ079298" class="selected">Section 12.2.2</a></span>).</td>
                                                </tr>
                                            </tbody>
                                        </table>
                                    </div>
                                    <div class="subsection">
                                        <p class="table" id="STDZ079114"><span class="table-label">Table 12-1 </span>Basic Hex Conversion Utility Options </p>
                                        <table class="gentable">
                                            <colgroup>
                                                <col />
                                                <col align="left" />
                                                <col align="left" />
                                                <col align="left" />
                                            </colgroup>
                                            <thead class="tbl_hdr_gray">
                                                <tr valign="middle">
                                                    <th align="left">Option</th>
                                                    <th>Alias</th>
                                                    <th>Description</th>
                                                    <th>See</th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                <tr valign="middle">
                                                    <td align="center" colspan="4"><b>General Options</b>
                                                    </td>
                                                </tr>
                                                <tr valign="middle">
                                                    <td>--byte</td>
                                                    <td>-byte</td>
                                                    <td>Number output locations by bytes rather than by target addressing</td>
                                                    <td>--</td>
                                                </tr>
                                                <tr valign="middle">
                                                    <td>--entrypoint=<i>addr</i></td>
                                                    <td>-e</td>
                                                    <td>Specify the entry point at which to begin execution after boot loading</td>
                                                    <td><span class="crossreference"><a href="#spnu1182372" class="selected">Table 12-2</a></span>
                                                    </td>
                                                </tr>
                                                <tr valign="middle">
                                                    <td>--exclude={<i>fname</i>(<i>sname</i>) | <br /><span>&#160;&#160;&#160;&#160;</span><i>sname</i>} </td>
                                                    <td>-exclude</td>
                                                    <td>If the filename (<i>fname</i>) is omitted, all sections matching <i>sname</i> will be excluded.</td>
                                                    <td><span class="crossreference"><a href="#STDZ0794913" class="selected">Section 12.7</a></span> <![CDATA[ ]]></td>
                                                </tr>
                                                <tr valign="middle">
                                                    <td>--fill=<i>value</i> <![CDATA[ ]]></td>
                                                    <td>-fill</td>
                                                    <td>Fill holes with <i>value</i> <![CDATA[ ]]></td>
                                                    <td><span class="crossreference"><a href="#STDZ0799675" class="selected">Section 12.9.2</a></span>
                                                    </td>
                                                </tr>
                                                <tr valign="middle">
                                                    <td>--help</td>
                                                    <td>-options, -h</td>
                                                    <td>Display the syntax for invoking the utility and list available options. If the option is followed by another option or phrase, detailed information about that option or phrase is displayed. </td>
                                                    <td><span class="crossreference"><a href="#STDZ079298" class="selected">Section 12.2.2</a></span> <![CDATA[ ]]></td>
                                                </tr>
                                                <tr valign="middle">
                                                    <td>--image</td>
                                                    <td>-image</td>
                                                    <td>Select image mode </td>
                                                    <td><span class="crossreference"><a href="#STDZ0792553" class="selected">Section 12.9.1</a></span>
                                                    </td>
                                                </tr>
                                                <tr valign="middle">
                                                    <td>--linkerfill</td>
                                                    <td>-linkerfill</td>
                                                    <td>Include linker fill sections in images</td>
                                                    <td>--</td>
                                                </tr>
                                                <tr valign="middle">
                                                    <td>--map=<i>filename</i></td>
                                                    <td>-map</td>
                                                    <td>Generate a map file</td>
                                                    <td><span class="crossreference"><a href="#STDZ0790734" class="selected">Section 12.4.2</a></span> <![CDATA[ ]]></td>
                                                </tr>
                                                <tr valign="middle">
                                                    <td>--memwidth=<i>value</i> <![CDATA[ ]]></td>
                                                    <td>-memwidth</td>
                                                    <td>Define the system memory word width (default <span>16</span> bits)</td>
                                                    <td><span class="crossreference"><a href="#STDZ0796400" class="selected">Section 12.3.2</a></span> <![CDATA[ ]]></td>
                                                </tr>
                                                <tr valign="middle">
                                                    <td>--outfile=<i>filename</i> <![CDATA[ ]]></td>
                                                    <td>-o</td>
                                                    <td>Specify an output filename</td>
                                                    <td><span class="crossreference"><a href="#STDZ0791687" class="selected">Section 12.8</a></span> <![CDATA[ ]]></td>
                                                </tr>
                                                <tr valign="middle">
                                                    <td>--quiet</td>
                                                    <td>-q</td>
                                                    <td>Run quietly (when used, it must appear <i>before</i> other options)</td>
                                                    <td><span class="crossreference"><a href="#STDZ079298" class="selected">Section 12.2.2</a></span>
                                                    </td>
                                                </tr>
                                                <tr valign="middle">
                                                    <td>--romwidth=<i>value</i> <![CDATA[ ]]></td>
                                                    <td>-romwidth</td>
                                                    <td>Specify the ROM device width (default depends on format used). This option is ignored for the TI-TXT and TI-Tagged formats.</td>
                                                    <td><span class="crossreference"><a href="#STDZ0798652" class="selected">Section 12.3.3</a></span>
                                                    </td>
                                                </tr>
                                                <tr valign="middle">
                                                    <td>--zero</td>
                                                    <td>-zero, -z</td>
                                                    <td>Reset the address origin to 0 in image mode</td>
                                                    <td><span class="crossreference"><a href="#STDZ0790735" class="selected">Section 12.9.3</a></span> <![CDATA[ ]]></td>
                                                </tr>
                                                <tr valign="middle">
                                                    <td align="center" colspan="4"><b>Diagnostic Options</b>
                                                    </td>
                                                </tr>
                                                <tr valign="middle">
                                                    <td>--diag_error=<i>id</i></td>
                                                    <td />
                                                    <td>Categorizes the diagnostic identified by <i>id</i> as an error</td>
                                                    <td><span class="crossreference"><a href="#STDZ0796452" class="selected">Section 12.13</a></span>
                                                    </td>
                                                </tr>
                                                <tr valign="middle">
                                                    <td>--diag_remark=<i>id</i></td>
                                                    <td />
                                                    <td>Categorizes the diagnostic identified by <i>id</i> as a remark</td>
                                                    <td><span class="crossreference"><a href="#STDZ0796452" class="selected">Section 12.13</a></span>
                                                    </td>
                                                </tr>
                                                <tr valign="middle">
                                                    <td>--diag_suppress=<i>id</i></td>
                                                    <td />
                                                    <td>Suppresses the diagnostic identified by <i>id</i></td>
                                                    <td><span class="crossreference"><a href="#STDZ0796452" class="selected">Section 12.13</a></span>
                                                    </td>
                                                </tr>
                                                <tr valign="middle">
                                                    <td>--diag_warning=<i>id</i></td>
                                                    <td />
                                                    <td>Categorizes the diagnostic identified by <i>id</i> as a warning</td>
                                                    <td><span class="crossreference"><a href="#STDZ0796452" class="selected">Section 12.13</a></span>
                                                    </td>
                                                </tr>
                                                <tr valign="middle">
                                                    <td>--display_error_number</td>
                                                    <td />
                                                    <td>Displays a diagnostic's identifiers along with its text</td>
                                                    <td><span class="crossreference"><a href="#STDZ0796452" class="selected">Section 12.13</a></span>
                                                    </td>
                                                </tr>
                                                <tr valign="middle">
                                                    <td>--issue_remarks</td>
                                                    <td />
                                                    <td>Issues remarks (nonserious warnings)</td>
                                                    <td><span class="crossreference"><a href="#STDZ0796452" class="selected">Section 12.13</a></span>
                                                    </td>
                                                </tr>
                                                <tr valign="middle">
                                                    <td>--no_warnings</td>
                                                    <td />
                                                    <td>Suppresses warning diagnostics (errors are still issued)</td>
                                                    <td><span class="crossreference"><a href="#STDZ0796452" class="selected">Section 12.13</a></span>
                                                    </td>
                                                </tr>
                                                <tr valign="middle">
                                                    <td>--set_error_limit=<i>count</i></td>
                                                    <td />
                                                    <td>Sets the error limit to <i>count</i>. The linker abandons linking after this number of errors. (The default is 100.)</td>
                                                    <td><span class="crossreference"><a href="#STDZ0796452" class="selected">Section 12.13</a></span>
                                                    </td>
                                                </tr>
                                                <tr valign="middle">
                                                    <td align="center" colspan="4"><b>Output Options</b>
                                                    </td>
                                                </tr>
                                                <tr valign="middle">
                                                    <td>--array</td>
                                                    <td />
                                                    <td>Select array output format</td>
                                                    <td><span class="crossreference"><a href="#t365188-3" class="selected">Section 12.10</a></span>
                                                    </td>
                                                </tr>
                                                <tr valign="middle">
                                                    <td>--ascii</td>
                                                    <td>-a</td>
                                                    <td>Select ASCII-Hex</td>
                                                    <td><span class="crossreference"><a href="#STDZ079753" class="selected">Section 12.14.1</a></span>
                                                    </td>
                                                </tr>
                                                <tr valign="middle">
                                                    <td>--intel</td>
                                                    <td>-i</td>
                                                    <td>Select Intel</td>
                                                    <td><span class="crossreference"><a href="#STDZ0792937" class="selected">Section 12.14.2</a></span>
                                                    </td>
                                                </tr>
                                                <tr valign="middle">
                                                    <td>--motorola=1</td>
                                                    <td> -m1</td>
                                                    <td>Select Motorola-S1</td>
                                                    <td><span class="crossreference"><a href="#STDZ0796026" class="selected">Section 12.14.3</a></span> <![CDATA[ ]]></td>
                                                </tr>
                                                <tr valign="middle">
                                                    <td>--motorola=2</td>
                                                    <td>-m2</td>
                                                    <td>Select Motorola-S2</td>
                                                    <td><span class="crossreference"><a href="#STDZ0796026" class="selected">Section 12.14.3</a></span>
                                                    </td>
                                                </tr>
                                                <tr valign="middle">
                                                    <td>--motorola=3</td>
                                                    <td>-m3</td>
                                                    <td>Select Motorola-S3<span> (default -m option)</span></td>
                                                    <td><span class="crossreference"><a href="#STDZ0796026" class="selected">Section 12.14.3</a></span>
                                                    </td>
                                                </tr>
                                                <tr valign="middle">
                                                    <td>--tektronix</td>
                                                    <td>-x</td>
                                                    <td>Select Tektronix (default format when no output option is specified)</td>
                                                    <td><span class="crossreference"><a href="#STDZ0794050" class="selected">Section 12.14.4</a></span> <![CDATA[ ]]></td>
                                                </tr>
                                                <tr valign="middle">
                                                    <td>--ti_tagged</td>
                                                    <td>-t</td>
                                                    <td>Select TI-Tagged</td>
                                                    <td><span class="crossreference"><a href="#STDZ0799951" class="selected">Section 12.14.5</a></span> <![CDATA[ ]]></td>
                                                </tr>
                                                <tr valign="middle">
                                                    <td>--ti_txt</td>
                                                    <td />
                                                    <td>Select TI-Txt</td>
                                                    <td><span class="crossreference"><a href="#STDZ0795656" class="selected">Section 12.14.6</a></span>
                                                    </td>
                                                </tr>
                                                <tr valign="middle">
                                                    <td align="center" colspan="4"><b>Load Image Options</b>
                                                    </td>
                                                </tr>
                                                <tr valign="middle">
                                                    <td>--load_image</td>
                                                    <td />
                                                    <td>Select load image</td>
                                                    <td><span class="crossreference"><a href="#STDZ0793404" class="selected">Section 12.6</a></span>
                                                    </td>
                                                </tr>
                                                <tr valign="middle">
                                                    <td>--section_name_prefix=<i>string</i></td>
                                                    <td />
                                                    <td>Specify the section name prefix for load image object files</td>
                                                    <td><span class="crossreference"><a href="#STDZ0793404" class="selected">Section 12.6</a></span>
                                                    </td>
                                                </tr>
                                            </tbody>
                                        </table>
                                    </div>
                                </div>
                                <div class="subsection">
                                    <h4 id="STDZ079298"><a name="12.2.2_Invoking_the_Hex_Conversion_Utility_With_a_Command_File" data-mc-generated-bookmark="TOC"></a><span class="section-label">12.2.2 </span>Invoking the Hex Conversion Utility With a Command File</h4>
                                    <p> A command file is useful if you plan to invoke the utility more than once with the same input files and options. It is also useful if you want to use the ROMS and SECTIONS hex conversion utility directives to customize the conversion process.</p>
                                    <p>Command files are ASCII files that contain one or more of the following:</p>
                                    <ul>
                                        <li value="1"><b>Options and filenames.</b> These are specified in a command file in exactly the same manner as on the command line.</li>
                                        <li value="2"><b>ROMS directive.</b> The ROMS directive defines the physical memory configuration of your system as a list of address-range parameters. (See <span class="crossreference"><a href="#STDZ0799222" class="selected">Section 12.4</a></span>.)</li>
                                        <li value="3"><b>SECTIONS directive. </b>The hex conversion utility SECTIONS directive specifies which sections from the object file are selected. (See <span class="crossreference"><a href="#STDZ0793829" class="selected">Section 12.5</a></span>.)</li>
                                        <li value="4"><b>Comments. </b>You can add comments to your command file by using the /* and */ delimiters. For example:</li><code>    /* This is a comment. */</code>
                                    </ul>
                                    <p>To invoke the utility and use the options you defined in a command file, enter:</p>
                                    <p><b> <span>armhex</span> <![CDATA[ ]]></b><i>command_filename</i>
                                    </p>
                                    <p> You can also specify other options and files on the command line. For example, you could invoke the utility by using both a command file and command line options:</p><code>armhex firmware.cmd --map=firmware.mxp</code>
                                    <p>The order in which these options and filenames appear is not important. The utility reads all input from the command line and all information from the command file before starting the conversion process. However, if you are using the -q option,<i> it must appear as the first option on the command line or in a command file.</i></p>
                                    <p> The <b>--help</b> option displays the syntax for invoking the compiler and lists available options. If the --help option is followed by another option or phrase, detailed information about the option or phrase is displayed. For example, to see information about options associated with generating a boot table use --help boot.</p>
                                    <p> The <b>--quiet</b> option suppresses the hex conversion utility's normal banner and progress information.</p>
                                    <ul>
                                        <li value="1">Assume that a command file named firmware.cmd contains these lines:</li><code>    firmware.out /* input file */
 --ti-tagged /* TI-Tagged */
 --outfile=firm.lsb /* output file */
 --outfile=firm.msb /* output file */</code>
                                        <p>You can invoke the hex conversion utility by entering:</p><code> armhex firmware.cmd</code>
                                        <li value="2">This example shows how to convert a file called appl.out into eight hex files in Intel format. Each output file is one byte wide and 4K bytes long.</li><code>    appl.out /* input file */
 --intel /* Intel format */
 --map=appl.mxp /* map file */

 ROMS
 {
 ROW1: origin=0x00000000 len=0x4000 romwidth=8
 files={ appl.u0 appl.u1 app1.u2 appl.u3 }
 ROW2: origin=0x00004000 len=0x4000 romwidth=8
 files={ app1.u4 appl.u5 appl.u6 appl.u7 }
 }

 SECTIONS
 { .text, .data, .cinit, .sect1, .vectors, .const:
 }</code>
                                    </ul>
                                </div>
                            </div>
                            <div class="subsection">
                                <h3 id="STDZ0793021"><a name="12.3_Understanding_Memory_Widths" data-mc-generated-bookmark="TOC"></a><span class="section-label">12.3 </span>Understanding Memory Widths</h3>
                                <p>The hex conversion utility makes your memory architecture more flexible by allowing you to specify memory and ROM widths. To use the hex conversion utility, you must understand how the utility treats word widths. Three widths are important in the conversion process:</p>
                                <ul>
                                    <li value="1">Target width</li>
                                    <li value="2">Memory width</li>
                                    <li value="3">ROM width</li>
                                </ul>
                                <p>The terms target word, memory word, and ROM word refer to a word of such a width.</p>
                                <p><span class="crossreference"><a href="#STDZ0797456" class="selected">Figure 12-2</a></span> illustrates the separate and distinct phases of the hex conversion utility's process flow.</p>
                                <div class="figure"><span class="caption" id="STDZ0797456"><span class="figure-label">Figure 12-2 </span>Hex Conversion Utility Process Flow</span> <img alt="hexprocflow_pnu118.gif" itemprop="image" src="ods/images/SPNU118U/hexprocflow_pnu118.gif" title="Hex Conversion Utility Process&#xA;    Flow" /> </div>
                                <div class="subsection">
                                    <h4 id="STDZ0790732"><a name="12.3.1_Target_Width" data-mc-generated-bookmark="TOC"></a><span class="section-label">12.3.1 </span>Target Width</h4>
                                    <p> Target width is the unit size (in bits) of the target processor's word. The width is fixed for each target and cannot be changed. The <span>ARM</span> targets have a width of <span>32 bits</span>.</p>
                                </div>
                                <div class="subsection">
                                    <h4 id="STDZ0796400"><a name="12.3.2_Specifying_the_Memory_Width" data-mc-generated-bookmark="TOC"></a><span class="section-label">12.3.2 </span>Specifying the Memory Width</h4>
                                    <p> Memory width is the physical width (in bits) of the memory system. Usually, the memory system is physically the same width as the target processor width: a <span>16-bit</span> processor has a <span>32-bit</span> memory architecture. However, some applications require target words to be broken into multiple, consecutive, and narrower memory words. </p>
                                    <p>By default, the hex conversion utility sets memory width to the target width (in this case, <span>32 bits</span>).</p>
                                    <p>You can change the memory width (except for TI-TXT format) by:</p>
                                    <ul>
                                        <li value="1"> Using the<b> --memwidth</b> option. This changes the memory width value for the entire file.</li>
                                        <li value="2"> Setting the<b> memwidth</b> parameter of the ROMS directive. This changes the memory width value for the address range specified in the ROMS directive and overrides the --memwidth option for that range. See <span class="crossreference"><a href="#STDZ0799222" class="selected">Section 12.4</a></span>.</li>
                                    </ul>
                                    <p>For both methods, use a value that is a power of 2 greater than or equal to 8.</p>
                                    <p>You should change the memory width default value of <span>16</span> only when you need to break single target words into consecutive, narrower memory words. </p><span class="note"><p class="note_title">NOTE</p><b>TI-TXT Format is 8 Bits Wide</b><p>You cannot change the memory width of the TI-TXT format. The TI-TXT hex format supports an 8-bit memory width only.</p></span>
                                    <p><span class="crossreference"><a href="#STDZ0792921" class="selected">Figure 12-3</a></span> demonstrates how the memory width is related to object file data.</p>
                                </div>
                                <div class="figure"><span class="caption" id="STDZ0792921"><span class="figure-label">Figure 12-3 </span>Object File Data and Memory Widths</span> <img alt="datamemwidth_pnu118.png" itemprop="image" src="ods/images/SPNU118U/datamemwidth_pnu118.png" title="Object File Data and Memory&#xA;    Widths" /> </div>
                                <div class="subsection">
                                    <h4 id="STDZ0798652"><a name="12.3.3_Partitioning_Data_Into_Output_Files" data-mc-generated-bookmark="TOC"></a><span class="section-label">12.3.3 </span>Partitioning Data Into Output Files</h4>
                                    <p>ROM width determines how the hex conversion utility partitions the data into output files. ROM width specifies the physical width (in bits) of each ROM device and corresponding output file (usually one byte or eight bits). After the object file data is mapped to the memory words, the memory words are broken into one or more output files. The number of output files is determined by the following formulas:</p>
                                    <ul>
                                        <li value="1">If memory width ≥ ROM width:</li>
                                        <p>number of files = memory width ÷ ROM width</p>
                                        <li value="2">If memory width &lt; ROM width:</li>
                                        <p>number of files = 1</p>
                                    </ul>
                                    <p>For example, for a memory width of <span>32</span>, you could specify a ROM width value of <span>32</span> and get a single output file containing <span>32-bit</span> words. Or you can use a ROM width value of <span>16</span> to get two files, each containing <span>16</span> bits of each word.</p>
                                    <p>The default ROM width that the hex conversion utility uses depends on the output format:</p>
                                    <ul>
                                        <li value="1">All hex formats except TI-Tagged are configured as lists of 8-bit bytes; the default ROM width for these formats is 8 bits.</li>
                                        <li value="2">TI-Tagged is a 16-bit format; the default ROM width for TI-Tagged is 16 bits.</li>
                                    </ul><span class="note"><p class="note_title">NOTE</p><b>The TI-Tagged Format is 16 Bits Wide</b><p>You cannot change the ROM width of the TI-Tagged format. The TI-Tagged format supports a 16-bit ROM width only.</p></span><span class="note"><p class="note_title">NOTE</p><b>TI-TXT Format is 8 Bits Wide</b><p>You cannot change the ROM width of the TI-TXT format. The TI-TXT hex format supports only an 8-bit ROM width.</p></span>
                                    <p>You can change ROM width (except for TI-Tagged and TI-TXT formats) by:</p>
                                    <ul>
                                        <li id="ID3n9Xp2e5mmad" value="1"> Using the <b>--romwidth</b> option. This option changes the ROM width value for the entire object file.</li>
                                        <li value="2"> Setting the <b>romwidth</b> parameter of the ROMS directive. This parameter changes the ROM width value for a specific ROM address range and overrides the --romwidth option for that range. See <span class="crossreference"><a href="#STDZ0799222" class="selected">Section 12.4</a></span>.</li>
                                    </ul>
                                    <p>For both methods, use a value that is a power of 2 greater than or equal to 8.</p>
                                    <p>If you select a ROM width that is wider than the natural size of the output format, the utility simply writes multibyte fields into the file. The --romwidth option is ignored for the TI-TXT and TI-Tagged formats.</p>
                                    <p><span class="crossreference"><a href="#STDZ0797745" class="selected">Figure 12-4</a></span> illustrates how the object file data, memory, and ROM widths are related to one another.</p>
                                    <p>Memory width and ROM width are used only for grouping the object file data; they do not represent values. Thus, the byte ordering of the object file data is maintained throughout the conversion process. To refer to the partitions within a memory word, the bits of the memory word are always numbered from right to left as follows:</p>
                                    <div class="figure">
                                        <img alt="memwidth_tdz079.gif" itemprop="image" src="ods/images/SPNU118U/memwidth_tdz079.gif" title="" /> </div>
                                    <div class="figure">
                                    </div>
                                    <div class="figure">
                                    </div>
                                    <div class="figure"><span class="caption" id="STDZ0797745"><span class="figure-label">Figure 12-4 </span>Data, Memory, and ROM Widths</span> <img alt="datamemrom_pnu118.png" itemprop="image" src="ods/images/SPNU118U/datamemrom_pnu118_628x907.png" title="Data, Memory, and ROM&#xA;    Widths" style="width: 628;height: 907;" /> </div>
                                </div>
                            </div>
                            <div class="subsection">
                                <h3 id="STDZ0799222"><a name="12.4_The_ROMS_Directive" data-mc-generated-bookmark="TOC"></a><span class="section-label">12.4 </span>The ROMS Directive</h3>
                                <p> The ROMS directive specifies the physical memory configuration of your system as a list of address-range parameters.</p>
                                <p>Each address range produces one set of files containing the hex conversion utility output data that corresponds to that address range. Each file can be used to program one single ROM device.</p>
                                <p>The ROMS directive is similar to the MEMORY directive of the <span>ARM</span> linker: both define the memory map of the target address space. Each line entry in the ROMS directive defines a specific address range. The general syntax is:</p>
                                <div class="subsection">
                                    <table class="tabbedtext">
                                        <colgroup>
                                            <col align="left" />
                                            <col align="left" />
                                            <col align="left" />
                                            <col align="left" />
                                        </colgroup>
                                        <tbody>
                                            <tr>
                                                <td colspan="2"> <b>ROMS</b><br /><b>{</b> <![CDATA[ ]]></td>
                                                <td />
                                                <td />
                                            </tr>
                                            <tr>
                                                <td />
                                                <td />
                                                <td> <i>romname</i><b>:</b> <![CDATA[ ]]></td>
                                                <td>[<b>origin</b>=<i>value</i>,] [<b>length</b>=<i>value</i>,] [<b>romwidth</b>=<i>value</i>,]<br /> [<b>memwidth</b>=<i>value</i>,] [<b>fill</b>=<i>value</i>]<br /> [<b>files</b>=<b>{</b><i>filename</i><sub>1</sub>, <i>filename</i><sub>2</sub>, ...<b>}</b>]</td>
                                            </tr>
                                            <tr>
                                                <td />
                                                <td />
                                                <td> <i>romname</i><b>:</b> <![CDATA[ ]]></td>
                                                <td>[<b>origin</b>=<i>value</i>,] [<b>length</b>=<i>value</i>,] [<b>romwidth</b>=<i>value</i>,]<br /> [<b>memwidth</b>=<i>value</i>,] [<b>fill</b>=<i>value</i>]<br /> [<b>files</b>=<b>{</b><i>filename</i><sub>1</sub>, <i>filename</i><sub>2</sub>, ...<b>}</b>]</td>
                                            </tr>
                                            <tr>
                                                <td />
                                                <td>...</td>
                                                <td />
                                                <td />
                                            </tr>
                                            <tr>
                                                <td> <b>}</b> <![CDATA[ ]]></td>
                                                <td />
                                                <td />
                                                <td />
                                            </tr>
                                        </tbody>
                                    </table>
                                </div>
                                <div class="subsection">
                                    <table class="tabbedtext">
                                        <colgroup>
                                            <col align="left" />
                                            <col align="left" />
                                        </colgroup>
                                        <tbody>
                                            <tr>
                                                <td class="noBorderRight noBorderBottom" valign="top"> <b>ROMS</b> <![CDATA[ ]]></td>
                                                <td class="noBorderRight noBorderBottom" valign="top">begins the directive definition.</td>
                                            </tr>
                                            <tr>
                                                <td class="noBorderRight noBorderBottom" valign="top"> <i>romname</i> <![CDATA[ ]]></td>
                                                <td class="noBorderRight noBorderBottom" valign="top">identifies a memory range. The name of the memory range can be one to eight characters in length. The name has no significance to the program; it simply identifies the range, except when the output is for a load image in which case it denotes the section name. (Duplicate memory range names are allowed.)</td>
                                            </tr>
                                            <tr>
                                                <td class="noBorderRight noBorderBottom" valign="top"> <b>origin</b> <![CDATA[ ]]></td>
                                                <td class="noBorderRight noBorderBottom" valign="top">specifies the starting address of a memory range. It can be entered as origin, org, or o. The associated value must be a decimal, octal, or hexadecimal constant. If you omit the origin value, the origin defaults to 0. The following table summarizes the notation you can use to specify a decimal, octal, or hexadecimal constant:</td>
                                            </tr>
                                        </tbody>
                                    </table>
                                </div>
                                <div class="subsection">
                                    <table class="gentable">
                                        <colgroup>
                                            <col />
                                            <col />
                                            <col />
                                        </colgroup>
                                        <thead class="tbl_hdr_gray">
                                            <tr>
                                                <th align="left" class="noBorderRight" valign="top">Constant</th>
                                                <th align="left" class="noBorderRight" valign="top">Notation</th>
                                                <th align="left" class="noBorderRight" valign="top">Example</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            <tr>
                                                <td align="left" class="noBorderRight noBorderBottom" valign="top">Hexadecimal</td>
                                                <td align="left" class="noBorderRight noBorderBottom" valign="top">0x prefix or h suffix</td>
                                                <td align="left" class="noBorderRight noBorderBottom" valign="top">0x77 or 077h</td>
                                            </tr>
                                            <tr>
                                                <td align="left" class="noBorderRight noBorderBottom" valign="top">Octal</td>
                                                <td align="left" class="noBorderRight noBorderBottom" valign="top">0 prefix</td>
                                                <td align="left" class="noBorderRight noBorderBottom" valign="top">077</td>
                                            </tr>
                                            <tr>
                                                <td align="left" class="noBorderRight noBorderBottom" valign="top">Decimal</td>
                                                <td align="left" class="noBorderRight noBorderBottom" valign="top">No prefix or suffix</td>
                                                <td align="left" class="noBorderRight noBorderBottom" valign="top">77</td>
                                            </tr>
                                        </tbody>
                                    </table>
                                </div>
                                <div class="subsection">
                                    <table class="tabbedtext">
                                        <colgroup>
                                            <col align="left" />
                                            <col align="left" />
                                        </colgroup>
                                        <tbody>
                                            <tr>
                                                <td class="noBorderRight noBorderBottom" valign="top"> <b>length</b> <![CDATA[ ]]></td>
                                                <td class="noBorderRight noBorderBottom" valign="top">specifies the length of a memory range as the physical length of the ROM device. It can be entered as length, len, or l. The value must be a decimal, octal, or hexadecimal constant. If you omit the length, it defaults to the length of the entire address space.</td>
                                            </tr>
                                            <tr>
                                                <td class="noBorderRight noBorderBottom" valign="top"> <b>romwidth</b> <![CDATA[ ]]></td>
                                                <td class="noBorderRight noBorderBottom" valign="top">specifies the physical ROM width of the range in bits (see <span class="crossreference"><a href="#STDZ0798652" class="selected">Section 12.3.3</a></span>). Any value you specify here overrides the --romwidth option. The value must be a decimal, octal, or hexadecimal constant that is a power of 2 greater than or equal to 8.</td>
                                            </tr>
                                            <tr>
                                                <td class="noBorderRight noBorderBottom" valign="top"> <b>memwidth</b> <![CDATA[ ]]></td>
                                                <td class="noBorderRight noBorderBottom" valign="top">specifies the memory width of the range in bits (see <span class="crossreference"><a href="#STDZ0796400" class="selected">Section 12.3.2</a></span>). Any value you specify here overrides the --memwidth option. The value must be a decimal, octal, or hexadecimal constant that is a power of 2 greater than or equal to 8. <i>When using the memwidth parameter, you must also specify the paddr parameter for each section in the SECTIONS directive. </i>(See <span class="crossreference"><a href="#STDZ0793829" class="selected">Section 12.5</a></span>.)</td>
                                            </tr>
                                            <tr>
                                                <td class="noBorderRight noBorderBottom" valign="top"> <b>fill</b> <![CDATA[ ]]></td>
                                                <td class="noBorderRight noBorderBottom" valign="top">specifies a fill value to use for the range. In image mode, the hex conversion utility uses this value to fill any holes between sections in a range. A hole is an area between the input sections that comprises an output section that contains no actual code or data. The fill value must be a decimal, octal, or hexadecimal constant with a width equal to the target width. Any value you specify here overrides the --fill option. When using fill, you must also use the --image command line option. (See <span class="crossreference"><a href="#STDZ0799675" class="selected">Section 12.9.2</a></span>.)</td>
                                            </tr>
                                            <tr>
                                                <td class="noBorderRight noBorderBottom" valign="top"> <b>files</b> <![CDATA[ ]]></td>
                                                <td class="noBorderRight noBorderBottom" valign="top">identifies the names of the output files that correspond to this range. Enclose the list of names in curly braces and order them from <i>least significant </i>to<i> most significant</i> output file, where the bits of the memory word are numbered from right to left. The number of file names must equal the number of output files that the range generates. To calculate the number of output files, see <span class="crossreference"><a href="#STDZ0798652" class="selected">Section 12.3.3</a></span>. The utility warns you if you list too many or too few filenames.</td>
                                            </tr>
                                        </tbody>
                                    </table>
                                </div>
                                <p>Unless you are using the --image option, all of the parameters that define a range are optional; the commas and equal signs are also optional. A range with no origin or length defines the entire address space. In image mode, an origin and length are required for all ranges.</p>
                                <p>Ranges must not overlap and must be listed in order of ascending address.</p>
                                <div class="subsection">
                                    <h4 id="STDZ0790733"><a name="12.4.1_When_to_Use_the_ROMS_Directive" data-mc-generated-bookmark="TOC"></a><span class="section-label">12.4.1 </span>When to Use the ROMS Directive</h4>
                                    <p>If you do not use a ROMS directive, the utility defines a single default range that includes the entire address space. This is equivalent to a ROMS directive with a single range without origin or length.</p>
                                    <p>Use the ROMS directive when you want to:</p>
                                    <ul>
                                        <li value="1"><b>Program large amounts of data into fixed-size ROMs</b>. When you specify memory ranges corresponding to the length of your ROMs, the utility automatically breaks the output into blocks that fit into the ROMs.</li>
                                        <li value="2"><b>Restrict output to certain segments</b>. You can also use the ROMS directive to restrict the conversion to a certain segment or segments of the target address space. The utility does not convert the data that falls outside of the ranges defined by the ROMS directive. Sections can span range boundaries; the utility splits them at the boundary into multiple ranges. If a section falls completely outside any of the ranges you define, the utility does not convert that section and issues no messages or warnings. Thus, you can exclude sections without listing them by name with the SECTIONS directive. However, if a section falls partially in a range and partially in unconfigured memory, the utility issues a warning and converts only the part within the range.</li>
                                        <li value="3"><b>Use image mode.</b> When you use the --image option, you must use a ROMS directive. Each range is filled completely so that each output file in a range contains data for the whole range. Holes before, between, or after sections are filled with the fill value from the ROMS directive, with the value specified with the --fill option, or with the default value of 0.</li>
                                    </ul>
                                </div>
                                <div class="subsection">
                                    <h4 id="STDZ0790734"><a name="12.4.2_An_Example_of_the_ROMS_Directive" data-mc-generated-bookmark="TOC"></a><span class="section-label">12.4.2 </span>An Example of the ROMS Directive</h4>
                                    <p> The ROMS directive in <span class="crossreference"><a href="#STDZ0791039" class="selected">Example 12-1</a></span> shows how 16K bytes of 16-bit memory could be partitioned for two 8K-byte 8-bit EPROMs. <span class="crossreference"><a href="#STDZ0791587" class="selected">Figure 12-5</a></span> illustrates the input and output files.</p>
                                    <div class="example">
                                        <h4 id="STDZ0791039"><a name="Example_12-1_A_ROMS_Directive_Example" data-mc-generated-bookmark="TOC"></a><span class="example-label">Example 12-1 </span>A ROMS Directive Example</h4><code>infile.out
--image
--memwidth 16

ROMS
{
 EPROM1: org = 0x00004000, len = 0x2000, romwidth = 8
 files = { rom4000.b0, rom4000.b1}
 EPROM2: org = 0x00006000, len = 0x2000, romwidth = 8, 
 fill = 0xFF00FF00,
 files = { rom6000.b0, rom6000.b1}
}</code>
                                    </div>
                                    <div class="figure"><span class="caption" id="STDZ0791587"><span class="figure-label">Figure 12-5 </span>The infile.out File Partitioned Into Four Output Files</span> <img alt="partition_pru186.png" itemprop="image" src="ods/images/SPNU118U/partition_pru186.png" title="The infile.out File&#xA;    Partitioned Into Four Output Files" /> </div>
                                    <p>The map file (specified with the --map option) is advantageous when you use the ROMS directive with multiple ranges. The map file shows each range, its parameters, names of associated output files, and a list of contents (section names and fill values) broken down by address. <span class="crossreference"><a href="#STDZ0794650" class="selected">Example 12-2</a></span> is a segment of the map file resulting from the example in <span class="crossreference"><a href="#STDZ0791039" class="selected">Example 12-1</a></span>. </p>
                                    <div class="example">
                                        <h4 id="STDZ0794650"><a name="Example_12-2_Map_File_Output_From_Example_12-1_Showing_Memory_Ranges" data-mc-generated-bookmark="TOC"></a><span class="example-label">Example 12-2 </span>Map File Output From <span class="crossreference"><a href="#STDZ0791039" class="selected">Example 12-1</a></span> Showing Memory Ranges</h4><code>-----------------------------------------------------
00004000..00005fff Page=0 Width=8 "EPROM1"-----------------------------------------------------
 OUTPUT FILES: rom4000.b0 [b0..b7]
 rom4000.b1 [b8..b15]
 CONTENTS: 00004000..0000487f .text
 00004880..00005b7f FILL = 00000000
 00005b80..00005fff .data
-----------------------------------------------------
00006000..00007fff Page=0 Width=8 "EPROM2"-----------------------------------------------------
 OUTPUT FILES: rom6000.b0 [b0..b7]
 rom6000.b1 [b8..b15]
 CONTENTS: 00006000..0000633f .data
 00006340..000066ff FILL = ff00ff00
 00006700..00007c7f .table
 00007c80..00007fff FILL = ff00ff00
</code>
                                    </div>
                                    <p>EPROM1 defines the address range from <span>0x00004000 through 0x00005FFF</span> with the following sections:</p>
                                    <div class="subsection">
                                        <table class="gentable">
                                            <colgroup>
                                                <col />
                                                <col />
                                                <col />
                                            </colgroup>
                                            <thead class="tbl_hdr_gray">
                                                <tr>
                                                    <th align="left" class="noBorderRight" valign="top" />
                                                    <th align="left" class="noBorderRight" valign="top">This section ...</th>
                                                    <th align="left" class="noBorderRight" valign="top">Has this range ...</th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                <tr>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top" />
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">.text</td>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">0x00004000 through 0x0000487F</td>
                                                </tr>
                                                <tr>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top" />
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">.data</td>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">0x00005B80 through 0x00005FFF</td>
                                                </tr>
                                            </tbody>
                                        </table>
                                    </div>
                                    <p>The rest of the range is filled with 0h (the default fill value), converted into two output files:</p>
                                    <ul>
                                        <li value="1">rom4000.b0 contains bits 0 through 7</li>
                                        <li value="2">rom4000.b1 contains bits 8 through 15</li>
                                    </ul>
                                    <p>EPROM2 defines the address range from <span>0x00006000 through 0x00007FFF</span> with the following sections:</p>
                                    <div class="subsection">
                                        <table class="gentable">
                                            <colgroup>
                                                <col />
                                                <col />
                                                <col />
                                            </colgroup>
                                            <thead class="tbl_hdr_gray">
                                                <tr>
                                                    <th align="left" class="noBorderRight" valign="top" />
                                                    <th align="left" class="noBorderRight" valign="middle">This section ...</th>
                                                    <th align="left" class="noBorderRight" valign="middle">Has this range ...</th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                <tr>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top" />
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">.data</td>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">0x00006000 through 0x0000633F</td>
                                                </tr>
                                                <tr>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top" />
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">.table</td>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">0x00006700 through 0x00007C7F</td>
                                                </tr>
                                            </tbody>
                                        </table>
                                    </div>
                                    <p>The rest of the range is filled with <span>0xFF00FF00</span> (from the specified fill value). The data from this range is converted into two output files:</p>
                                    <ul>
                                        <li value="1">rom6000.b0 contains bits 0 through 7</li>
                                        <li value="2">rom6000.b1 contains bits 8 through 15</li>
                                    </ul>
                                </div>
                            </div>
                            <div class="subsection">
                                <h3 id="STDZ0793829"><a name="12.5_The_SECTIONS_Directive" data-mc-generated-bookmark="TOC"></a><span class="section-label">12.5 </span>The SECTIONS Directive</h3>
                                <p> You can convert specific sections of the object file by name with the hex conversion utility SECTIONS directive. You can also specify those sections that you want to locate in ROM at a different address than the <i>load</i> address specified in the linker command file. If you:</p>
                                <ul>
                                    <li value="1">Use a SECTIONS directive, the utility converts only the sections that you list in the directive and ignores all other sections in the object file.</li>
                                    <li value="2">Do not use a SECTIONS directive, the utility converts all initialized sections that fall within the configured memory.</li>
                                </ul>
                                <p>Uninitialized sections are <i>never</i> converted, whether or not you specify them in a SECTIONS directive.</p><span class="note"><p class="note_title">NOTE</p><b>Sections Generated by the C/C++ Compiler</b><p>The <span>ARM</span> C/C++ compiler automatically generates these sections:</p><ul><li value="1"><b>Initialized sections:</b> .text, <span>.const</span>, <span>.cinit, and .switch</span></li><li value="2"><b>Uninitialized sections:</b><span>.bss</span>, .stack, and <span>.sysmem</span></li></ul></span>
                                <p>Use the SECTIONS directive in a command file. (See <span class="crossreference"><a href="#STDZ079298" class="selected">Section 12.2.2</a></span>.) The general syntax is:</p>
                                <div class="subsection">
                                    <table class="tabbedtext">
                                        <colgroup>
                                            <col align="left" />
                                            <col align="left" />
                                        </colgroup>
                                        <tbody>
                                            <tr>
                                                <td colspan="2"> <b>SECTIONS</b><br /><b>{</b> <![CDATA[ ]]></td>
                                            </tr>
                                            <tr>
                                                <td />
                                                <td><i>oname</i>(<i>sname</i>)[<b>:</b>] [<b>paddr</b>=<i>value</i>] <br /><i>oname</i>(<i>sname</i>)[<b>:</b>] [<b>paddr</b>= <span> <b>boot</b>]<br /><i>oname</i>(<i>sname</i>)[<b>:</b>] [<b>boot</b>]</span><br /> ...<br /><b>}</b></td>
                                            </tr>
                                        </tbody>
                                    </table>
                                </div>
                                <div class="subsection">
                                    <table class="tabbedtext">
                                        <colgroup>
                                            <col align="left" />
                                            <col align="left" />
                                        </colgroup>
                                        <tbody>
                                            <tr>
                                                <td class="noBorderRight noBorderBottom" valign="top"> <b>SECTIONS</b> <![CDATA[ ]]></td>
                                                <td align="left" class="noBorderRight noBorderBottom" valign="top">begins the directive definition.</td>
                                            </tr>
                                            <tr>
                                                <td class="noBorderRight noBorderBottom" valign="top"><i>oname</i>
                                                </td>
                                                <td class="noBorderRight noBorderBottom" valign="top">identifies the object filename the section is located within. The filename is optional when only a single input file is given, but required otherwise.</td>
                                            </tr>
                                            <tr>
                                                <td class="noBorderRight noBorderBottom" valign="top"> <i>sname</i></td>
                                                <td class="noBorderRight noBorderBottom" valign="top">identifies a section in the input file. If you specify a section that does not exist, the utility issues a warning and ignores the name.</td>
                                            </tr>
                                            <tr>
                                                <td class="noBorderRight noBorderBottom" valign="top"> <b>paddr</b>=<i>value</i> <![CDATA[ ]]></td>
                                                <td class="noBorderRight noBorderBottom" valign="top">specifies the physical ROM address at which this section should be located. This value overrides the section load address given by the linker. This value must be a decimal, octal, or hexadecimal constant. <span>It can also be the word <b>boot </b>(to indicate a boot table section for use with a boot loader). </span><i>If your file contains multiple sections, and if one section uses a paddr parameter, then all sections must use a paddr parameter.</i> <![CDATA[ ]]></td>
                                            </tr>
                                            <tr>
                                                <td class="noBorderRight noBorderBottom" valign="top"> <b>boot</b></td>
                                                <td class="noBorderRight noBorderBottom" valign="top">configures a section for loading by a boot loader. This is equivalent to using <b>paddr=boot</b>. Boot sections have a physical address determined by the location of the boot table. The origin of the boot table is specified with the --bootorg option.</td>
                                            </tr>
                                        </tbody>
                                    </table>
                                </div>
                                <p>For more similarity with the linker's SECTIONS directive, you can use colons after the section names (in place of the equal sign on the boot keyboard). For example, the following statements are equivalent:</p><code>SECTIONS { .text: .data: boot }</code><code>SECTIONS { .text: .data = boot }</code>
                                <p>In the example below, the object file contains six initialized sections: .text, .data, .const, .vectors, .coeff, and .tables. Suppose you want only .text and .data to be converted. Use a SECTIONS directive to specify this:</p><code>SECTIONS { .text: .data: }</code>
                                <p>To configure both of these sections for boot loading, add the boot keyword:</p><code>SECTIONS { .text = boot .data = boot }</code>
                            </div>
                            <div class="subsection">
                                <h3 id="STDZ0793404"><a name="12.6_The_Load_Image_Format_(--load_image_Option)" data-mc-generated-bookmark="TOC"></a><span class="section-label">12.6 </span>The Load Image Format (--load_image Option)</h3>
                                <p>A load image is an object file which contains the load addresses and initialized sections of one or more executable files. The load image object file can be used for ROM masking or can be relinked in a subsequent link step. </p>
                                <div class="subsection">
                                    <h4 id="STDZ079593"><a name="12.6.1_Load_Image_Section_Formation" data-mc-generated-bookmark="TOC"></a><span class="section-label">12.6.1 </span>Load Image Section Formation</h4>
                                    <p>The load image sections are formed by collecting the initialized sections from the input executables. There are two ways the load image sections are formed:</p>
                                    <ul>
                                        <li value="1"><b>Using the ROMS Directive</b>. Each memory range that is given in the ROMS directive denotes a load image section. The romname is the section name. The origin and length parameters are required. The memwidth, romwidth, and files parameters are invalid and are ignored.</li>
                                        <p>When using the ROMS directive and the load_image option, the --image option is required.</p>
                                        <li value="2"><b>Default Load Image Section Formation</b>. If no ROMS directive is given, the load image sections are formed by combining contiguous initialized sections in the input executables. Sections with gaps smaller than the target word size are considered contiguous. </li>
                                        <p>The default section names are image_1, image_2, ... If another prefix is desired, the --section_name_prefix=<i>prefix</i> option can be used.</p>
                                    </ul>
                                </div>
                                <div class="subsection">
                                    <h4 id="STDZ0793961"><a name="12.6.2_Load_Image_Characteristics" data-mc-generated-bookmark="TOC"></a><span class="section-label">12.6.2 </span>Load Image Characteristics</h4>
                                    <p>All load image sections are initialized data sections. In the absence of a ROMS directive, the load/run address of the load image section is the load address of the first input section in the load image section. If the SECTIONS directive was used and a different load address was given using the paddr parameter, this address will be used.</p>
                                    <p>The load image format always creates a single load image object file. The format of the load image object file is determined based on the input files. The file is not marked executable and does not contain an entry point. The default load image object file name is ti_load_image.obj. This can be changed using the --outfile option. Only one --outfile option is valid when creating a load image, all other occurrences are ignored. </p>
                                </div><span class="note"><p class="note_title">NOTE</p><b>Concerning Load Image Format</b><p>These options are invalid when creating a load image:</p><ul><li value="1">--memwidth</li><li value="2">--romwidth</li><li value="3">--zero</li><li value="4">--byte</li></ul><p>If a boot table is being created, either using the SECTIONS directive or the --boot option, the ROMS directive must be used. </p></span>
                            </div>
                            <div class="subsection">
                                <h3 id="STDZ0794913"><a name="12.7_Excluding_a_Specified_Section" data-mc-generated-bookmark="TOC"></a><span class="section-label">12.7 </span>Excluding a Specified Section</h3>
                                <p>The --exclude <i>section_name</i> option can be used to inform the hex utility to ignore the specified section. If a SECTIONS directive is used, it overrides the --exclude option.</p>
                                <p>For example, if a SECTIONS directive containing the section name <i>mysect</i> is used and an --exclude <i>mysect</i> is specified, the SECTIONS directive takes precedence and <i>mysect</i> is not excluded.</p>
                                <p>The --exclude option has a limited wildcard capability. The * character can be placed at the beginning or end of the name specifier to indicate a suffix or prefix, respectively. For example, --exclude sect* disqualifies all sections that begin with the characters sect.</p>
                                <p>If you specify the --exclude option on the command line with the * wildcard, use quotes around the section name and wildcard. For example, --exclude"sect*". Using quotes prevents the * from being interpreted by the hex conversion utility. If --exclude is in a command file, do not use quotes.</p>
                                <p>If multiple object files are given, the object file in which the section to be excluded can be given in the form oname(sname). If the object filename is not provided, all sections matching the section name are excluded. Wildcards cannot be used for the filename, but can appear within the parentheses.</p>
                            </div>
                            <div class="subsection">
                                <h3 id="STDZ0791687"><a name="12.8_Assigning_Output_Filenames" data-mc-generated-bookmark="TOC"></a><span class="section-label">12.8 </span>Assigning Output Filenames</h3>
                                <p> When the hex conversion utility translates your object file into a data format, it partitions the data into one or more output files. When multiple files are formed by splitting memory words into ROM words, <i>filenames are always assigned in order from least to most significant</i>, where bits in the memory words are numbered from right to left. This is true, regardless of target or endian ordering.</p>
                                <p>The hex conversion utility follows this sequence when assigning output filenames:</p>
                                <ol>
                                    <li value="1"><b>It looks for the ROMS directive. </b>If a file is associated with a range in the ROMS directive and you have included a list of files (files = {. . .}) on that range, the utility takes the filename from the list.</li>
                                    <p>For example, assume that the target data is <span>32-bit words being converted to four</span> files, each eight bits wide. To name the output files using the ROMS directive, you could specify:</p><code>    ROMS
 {
 RANGE1: romwidth=8, files={ xyz.b0 xyz.b1 xyz.b2 xyz.b3 }
 }</code>
                                    <p>The utility creates the output files by writing the least significant bits to xyz.b0 and the most significant bits to <span>xyz.b3</span>.</p>
                                    <li value="2"><b>It looks for the --outfile options. </b>You can specify names for the output files by using the --outfile option. If no filenames are listed in the ROMS directive and you use --outfile options, the utility takes the filename from the list of --outfile options. The following line has the same effect as the example above using the ROMS directive: </li><code>    --outfile=xyz.b0 --outfile=xyz.b1 --outfile=xyz.b2 --outfile=xyz.b3</code>
                                    <p>If both the ROMS directive and --outfile options are used together, the ROMS directive overrides the --outfile options.</p>
                                    <li value="3"><b>It assigns a default filename.</b> If you specify no filenames or fewer names than output files, the utility assigns a default filename. A default filename consists of the base name from the input file plus a 2- to 3-character extension. The extension has three parts:<ol style="list-style-type: lower-alpha;"><li value="1">A format character, based on the output format (see <span class="crossreference"><a href="#STDZ0792390" class="selected">Section 12.14</a></span>):</li><div class="subsection"><table class="tabbedtext"><colgroup><col align="left" /><col align="left" /><col align="left" /></colgroup><tbody><tr><td /><td> <b>a</b> <![CDATA[ ]]></td><td>for ASCII-Hex</td></tr><tr><td /><td> <b>i</b> <![CDATA[ ]]></td><td>for Intel</td></tr><tr><td /><td> <b>m</b> <![CDATA[ ]]></td><td>for Motorola-S</td></tr><tr><td /><td> <b>t</b> <![CDATA[ ]]></td><td>for TI-Tagged</td></tr><tr><td /><td> <b>x</b> <![CDATA[ ]]></td><td>for Tektronix</td></tr></tbody></table></div><li value="2">The range number in the ROMS directive. Ranges are numbered starting with 0. If there is no ROMS directive, or only one range, the utility omits this character.</li><li value="3">The file number in the set of files for the range, starting with 0 for the least significant file.</li></ol></li>
                                    <p>For example, assume a.out is for a <span>32-bit</span> target processor and you are creating Intel format output. With no output filenames specified, the utility produces <span>four </span>output files named a.i0, a.i1, a.i2, a.i3.</p>
                                    <p>If you include the following ROMS directive when you invoke the hex conversion utility, you would have <span>eight </span> output files:</p><code>    ROMS
 {
 range1: o = 0x00001000 l = 0x1000
 range2: o = 0x00002000 l = 0x1000
 }</code>
                                </ol>
                                <div class="subsection">
                                    <table class="gentable">
                                        <colgroup>
                                            <col />
                                            <col />
                                        </colgroup>
                                        <thead class="tbl_hdr_gray">
                                            <tr class="noBorderBottom">
                                                <th align="left" class="noBorderRight" valign="middle">These output files ...</th>
                                                <th align="left" class="noBorderRight" valign="middle">Contain data in these locations ...</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            <tr class="noBorderBottom">
                                                <td align="left" class="noBorderRight noBorderBottom" valign="top">a.i00, a.i01, a.i02, a.i03</td>
                                                <td align="left" class="noBorderRight noBorderBottom" valign="top">0x00001000 through 0x00001FFF</td>
                                            </tr>
                                            <tr>
                                                <td align="left" class="noBorderRight noBorderBottom" valign="top">a.i10, a.i11, a.i12, a.i13</td>
                                                <td align="left" class="noBorderRight noBorderBottom" valign="top">0x00002000 through 0x00002FFF</td>
                                            </tr>
                                        </tbody>
                                    </table>
                                </div>
                            </div>
                            <div class="subsection">
                                <h3 id="STDZ0791810"><a name="12.9_Image_Mode_and_the_--fill_Option" data-mc-generated-bookmark="TOC"></a><span class="section-label">12.9 </span>Image Mode and the --fill Option</h3>
                                <p> This section points out the advantages of operating in image mode and describes how to produce output files with a precise, continuous image of a target memory range.</p>
                                <div class="subsection">
                                    <h4 id="STDZ0792553"><a name="12.9.1_Generating_a_Memory_Image" data-mc-generated-bookmark="TOC"></a><span class="section-label">12.9.1 </span>Generating a Memory Image</h4>
                                    <p>With the --image option, the utility generates a memory image by completely filling all of the mapped ranges specified in the ROMS directive.</p>
                                    <p>An object file consists of blocks of memory (sections) with assigned memory locations. Typically, all sections are not adjacent: there are holes between sections in the address space for which there is no data. When such a file is converted <i>without</i> the use of image mode, the hex conversion utility bridges these holes by using the address records in the output file to skip ahead to the start of the next section. In other words, there may be discontinuities in the output file addresses. Some EPROM programmers do not support address discontinuities.</p>
                                    <p>In image mode, there are no discontinuities<i>. </i>Each output file contains a continuous stream of data that corresponds exactly to an address range in target memory. Any holes before, between, or after sections are filled with a fill value that you supply.</p>
                                    <p>An output file converted by using image mode still has address records, because many of the hexadecimal formats require an address on each line. However, in image mode, these addresses are always contiguous.</p><span class="note"><p class="note_title">NOTE</p><b>Defining the Ranges of Target Memory</b><p>If you use image mode, you must also use a ROMS directive. In image mode, each output file corresponds directly to a range of target memory. You must define the ranges. If you do not supply the ranges of target memory, the utility tries to build a memory image of the entire target processor address space. This is potentially a huge amount of output data. To prevent this situation, the utility requires you to explicitly restrict the address space with the ROMS directive.</p></span>
                                </div>
                                <div class="subsection">
                                    <h4 id="STDZ0799675"><a name="12.9.2_Specifying_a_Fill_Value" data-mc-generated-bookmark="TOC"></a><span class="section-label">12.9.2 </span>Specifying a Fill Value</h4>
                                    <p> The --fill option specifies a value for filling the holes between sections. The fill value must be specified as an integer constant following the --fill option. The width of the constant is assumed to be that of a word on the target processor. For example, specifying --fill=<span>0xFFFF results in a fill pattern of 0x0000FFFF</span>. The constant value is not sign extended.</p>
                                    <p>The hex conversion utility uses a default fill value of 0 if you do not specify a value with the fill option. <i>The --fill option is valid only when you use --image</i>; otherwise, it is ignored.</p>
                                </div>
                                <div class="subsection">
                                    <h4 id="STDZ0790735"><a name="12.9.3_Steps_to_Follow_in_Using_Image_Mode" data-mc-generated-bookmark="TOC"></a><span class="section-label">12.9.3 </span>Steps to Follow in Using Image Mode</h4>
                                    <div class="subsection">
                                        <table class="tabbedtext">
                                            <colgroup>
                                                <col />
                                                <col />
                                            </colgroup>
                                            <tbody>
                                                <tr valign="top">
                                                    <td class="noBorderRight noBorderBottom" valign="top"> <b>Step 1:</b></td>
                                                    <td class="noBorderRight noBorderBottom" valign="top"> Define the ranges of target memory with a ROMS directive. See <span class="crossreference"><a href="#STDZ0799222" class="selected">Section 12.4</a></span>.</td>
                                                </tr>
                                                <tr valign="top">
                                                    <td class="noBorderRight noBorderBottom" valign="top"> <b>Step 2:</b></td>
                                                    <td class="noBorderRight noBorderBottom" valign="top">Invoke the hex conversion utility with the --image option. You can optionally use the --zero option to reset the address origin to 0 for each output file. If you do not specify a fill value with the ROMS directive and you want a value other than the default of 0, use the --fill option.</td>
                                                </tr>
                                            </tbody>
                                        </table>
                                    </div>
                                </div>
                            </div>
                            <div class="subsection">
                                <h3 id="t365188-3"><a name="12.10_Array_Output_Format" data-mc-generated-bookmark="TOC"></a><span class="section-label">12.10 </span>Array Output Format</h3>
                                <p>The --array option causes the output to be generated in C array format. In this format, data contained in initialized sections of an executable file are defined as C arrays. Output arrays may be compiled along with a host program and used to initialize the target at runtime.</p>
                                <p>Arrays are formed by collecting the initialized sections from the input executable. There are two ways arrays are formed: </p>
                                <ul>
                                    <li id="t365188-1" value="1"><b>With the ROMS directive.</b> Each memory range that is given in the ROMS directive denotes an array. The <i>romname</i> is used as the array name. The <i>origin</i> and <i>length</i> parameters of the ROM directive are required. The <i>memwidth</i>, <i>romwidth</i>, and <i>files</i> parameters are invalid and are ignored. </li>
                                    <li id="t365188-2" value="2"><b>No ROMS directive (default).</b> If no ROMS directive is given, arrays are formed by combining initialized sections within each page, beginning with the first initialized section. Arrays will reflect any gaps that exist between sections. </li>
                                    <p>The default The --array:name_prefix option can be used to override the default prefix for array names. For example, use --array:name_prefix=myarray to cause the </p>
                                </ul>
                                <p>The data type for array elements is uint8_t..</p>
                            </div>
                            <div class="subsection">
                                <h3 id="spnu1184064"><a name="12.11_Building_a_Table_for_an_On-Chip_Boot_Loader" data-mc-generated-bookmark="TOC"></a><span class="section-label">12.11 </span>Building a Table for an On-Chip Boot Loader</h3>
                                <p>The ARM hex utility provides the ability to create a boot table for use with an on-chip boot loader. The supported boot formats are intended for use on C28x devices with ARM cores. The boot table is stored in memory or loaded from a device peripheral to initialize code or data.</p>
                                <p>See <span class="crossreference"><a href="program-loading-and-running.html#SLAU1313538">Section 3.1.2</a></span> for a general discussion of bootstrap loading.</p>
                                <div class="subsection">
                                    <h4 id="spnu1185166"><a name="12.11.1_Description_of_the_Boot_Table" data-mc-generated-bookmark="TOC"></a><span class="section-label">12.11.1 </span>Description of the Boot Table</h4>
                                    <p>The input for a boot loader is the boot table. The boot table contains records that instruct the on-chip loader to copy blocks of data contained in the table to specified destination addresses. The table can be stored in memory (such as EPROM) or read in through a device peripheral (such as a serial or communications port).</p>
                                    <p>The hex conversion utility automatically builds the boot table for the boot loader. Using the utility, you specify the sections you want the boot loader to initialize and the table location. The hex conversion utility builds a complete image of the table according to the format specified and converts it into hexadecimal in the output files. Then, you can burn the table into ROM or load it by other means.</p>
                                </div>
                                <div class="subsection">
                                    <h4 id="spnu1189877"><a name="12.11.2_The_Boot_Table_Format" data-mc-generated-bookmark="TOC"></a><span class="section-label">12.11.2 </span>The Boot Table Format</h4>
                                    <p>The boot table format is simple. Typically, there is a header record containing a key value that indicates memory width, entry point, and values for control registers. Each subsequent block has a header containing the size and destination address of the block followed by data for the block. Multiple blocks can be entered. The table ends with a header containing size zero.</p>
                                </div>
                                <div class="subsection">
                                    <h4 id="spnu1185260"><a name="12.11.3_How_to_Build_the_Boot_Table" data-mc-generated-bookmark="TOC"></a><span class="section-label">12.11.3 </span>How to Build the Boot Table</h4>
                                    <p><span class="crossreference"><a href="#spnu1182372" class="selected">Table 12-2</a></span> summarizes the hex conversion utility options available for the boot loader.</p>
                                    <div class="subsection">
                                        <p class="table" id="spnu1182372"><span class="table-label">Table 12-2 </span>Boot-Loader Options </p>
                                        <table class="gentable">
                                            <colgroup>
                                                <col align="left" />
                                                <col align="left" />
                                            </colgroup>
                                            <thead class="tbl_hdr_gray">
                                                <tr class="noBorderBottom">
                                                    <th align="left" class="noBorderRight" valign="top">Option</th>
                                                    <th align="left" class="noBorderRight" valign="top">Description</th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                <tr>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">--boot</td>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">Convert all sections into bootable form (use instead of a SECTIONS directive).</td>
                                                </tr>
                                                <tr>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">--bootorg=<i>value</i> <![CDATA[ ]]></td>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">Specify the source address of the boot-loader table.</td>
                                                </tr>
                                                <tr>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">--entrypoint=<i>value</i> <![CDATA[ ]]></td>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">Specify the entry point at which to begin execution after boot loading. The <i>value </i>can be an address or a global symbol.</td>
                                                </tr>
                                                <tr>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">--gpio8</td>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">Specify the source of the boot-loader table as the GP I/O port, 8-bit mode</td>
                                                </tr>
                                                <tr>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">--gpio16</td>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">Specify the source of the boot-loader table as the GP I/O port, 16-bit mode</td>
                                                </tr>
                                                <tr>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">--lospcp=<i>value</i> <![CDATA[ ]]></td>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">Specify the initial value for the LOSPCP register. The value is used only for the spi8 boot table format and is ignored for all other formats. A value greater than 0x7F is truncated to 0x7F.</td>
                                                </tr>
                                                <tr>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">--spi8</td>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">Specify the source of the boot-loader table as the SPI-A port, 8-bit mode</td>
                                                </tr>
                                                <tr>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">--spibrr=<i>value</i> <![CDATA[ ]]></td>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">Specify the initial value for the SPIBRR register. The value is used only for the spi8 boot table format and is ignored for all other formats. A value greater than 0x7F is truncated to 0x7F.</td>
                                                </tr>
                                            </tbody>
                                        </table>
                                    </div>
                                    <div class="subsection">
                                        <h4 id="spnu1188714"><a name="12.11.3.1_Building_the_Boot_Table" data-mc-generated-bookmark="TOC"></a><span class="section-label">12.11.3.1 </span>Building the Boot Table</h4>
                                        <p>To build the boot table, follow these steps:</p>
                                        <div class="subsection">
                                            <table class="tabbedtext">
                                                <colgroup>
                                                    <col />
                                                    <col />
                                                </colgroup>
                                                <tbody>
                                                    <tr valign="top">
                                                        <td class="noBorderRight noBorderBottom" valign="top">Step 1:</td>
                                                        <td class="noBorderRight noBorderBottom" valign="top"><b>Link the file.</b> Each block of the boot table data corresponds to an initialized section in the object file. Uninitialized sections are not converted by the hex conversion utility (see <span class="crossreference"><a href="#STDZ0793829" class="selected">Section 12.5</a></span>).</td>
                                                    </tr>
                                                    <tr valign="top">
                                                        <td class="noBorderRight noBorderBottom" valign="top" />
                                                        <td class="noBorderRight noBorderBottom" valign="top">When you select a section for placement in a boot-loader table, the hex conversion utility places the section's <i>load address </i>in the destination address field for the block in the boot table. The section content is then treated as raw data for that block. <i>The hex conversion utility does not use the section run address.</i> When linking, you need not worry about the ROM address or the construction of the boot table; the hex conversion utility handles this.</td>
                                                    </tr>
                                                    <tr valign="top">
                                                        <td class="noBorderRight noBorderBottom" valign="top">Step 2:</td>
                                                        <td class="noBorderRight noBorderBottom" valign="top"><b>Identify the bootable sections.</b> You can use the --boot option to tell the hex conversion utility to configure all sections for boot loading. Or, you can use a SECTIONS directive to select specific sections to be configured (see <span class="crossreference"><a href="#STDZ0793829" class="selected">Section 12.5</a></span>). If you use a SECTIONS directive, the --boot option is ignored.</td>
                                                    </tr>
                                                    <tr valign="top">
                                                        <td class="noBorderRight noBorderBottom" valign="top">Step 3:</td>
                                                        <td class="noBorderRight noBorderBottom" valign="top"><b>Set the boot table format.</b> Specify the --gpio8, --gpio16, or --spi8 options to set the source format of the boot table. You do not need to specify the memwidth and romwidth as the utility will set these formats automatically. If --memwidth and --romwidth are used after a format option, they override the default for the format.</td>
                                                    </tr>
                                                    <tr valign="top">
                                                        <td class="noBorderRight noBorderBottom" valign="top">Step 4:</td>
                                                        <td class="noBorderRight noBorderBottom" valign="top"><b>Set the ROM address of the boot table.</b> Use the --bootorg option to set the source address of the complete table.</td>
                                                    </tr>
                                                    <tr valign="top">
                                                        <td class="noBorderRight noBorderBottom" valign="top">Step 5:</td>
                                                        <td class="noBorderRight noBorderBottom" valign="top"><b>Set boot-loader-specific options.</b> Set entry point and control register values as needed. </td>
                                                    </tr>
                                                    <tr valign="top">
                                                        <td class="noBorderRight noBorderBottom" valign="top"> Step 6:</td>
                                                        <td class="noBorderRight noBorderBottom" valign="top"><b>Describe your system memory configuration.</b> See <span class="crossreference"><a href="#STDZ0793021" class="selected">Section 12.3</a></span> and <span class="crossreference"><a href="#STDZ0799222" class="selected">Section 12.4</a></span>.</td>
                                                    </tr>
                                                </tbody>
                                            </table>
                                        </div>
                                    </div>
                                    <div class="subsection">
                                        <h4 id="spnu1181871"><a name="12.11.3.2_Leaving_Room_for_the_Boot_Table" data-mc-generated-bookmark="TOC"></a><span class="section-label">12.11.3.2 </span>Leaving Room for the Boot Table</h4>
                                        <p>The complete boot table is similar to a single section containing all of the header records and data for the boot loader. The address of this section is the boot table origin. As part of the normal conversion process, the hex conversion utility converts the boot table to hexadecimal format and maps it into the output files like any other section.</p>
                                        <p>Be sure to leave room in your system memory for the boot table, especially when you are using the ROMS directive. The boot table cannot overlap other nonboot sections or unconfigured memory. Usually, this is not a problem; typically, a portion of memory in your system is reserved for the boot table. Simply configure this memory as one or more ranges in the ROMS directive, and use the --bootorg option to specify the starting address.</p>
                                    </div>
                                </div>
                                <div class="subsection">
                                    <h4 id="spnu1187284"><a name="12.11.4_Booting_From_a_Device_Peripheral" data-mc-generated-bookmark="TOC"></a><span class="section-label">12.11.4 </span>Booting From a Device Peripheral</h4>
                                    <p>You can choose the port to boot from by using the --gpio8, --gpio16, or --spi8 boot table format option.</p>
                                    <p>The initial value for the LOSPCP register can be specified with the --lospcp option. The initial value for the SPIBRR register can be specified with the --spibrr option. Only the --spi8 format uses these control register values in the boot table.</p>
                                    <p>If the register values are not specified for the --spi8 format, the hex conversion utility uses the default values 0x02 for LOSPCP and 0x7F for SPIBRR. When the boot table format options are specified and the ROMS directive is not specified, the ASCII format hex utility output does not produce the address record.</p>
                                </div>
                                <div class="subsection">
                                    <h4 id="spnu1181354"><a name="12.11.5_Setting_the_Entry_Point_for_the_Boot_Table" data-mc-generated-bookmark="TOC"></a><span class="section-label">12.11.5 </span>Setting the Entry Point for the Boot Table</h4>
                                    <p>After completing the boot load process, execution starts at the default entry point specified by the linker and contained in the object file. By using the --entrypoint option with the hex conversion utility, you can set the entry point to a different address.</p>
                                    <p>For example, if you want your program to start running at address 0x0123 after loading, specify --entrypoint=0x0123 on the command line or in a command file. You can determine the --entrypoint address by looking at the map file that the linker generates.</p><span class="note"><p class="note_title">NOTE</p><b>Valid Entry Points</b><p>The value can be a constant, or it can be a symbol that is externally defined (for example, with a .global) in the assembly source.</p></span>
                                </div>
                                <div class="subsection">
                                    <h4 id="spnu1189044"><a name="12.11.6_Using_the_ARM_Boot_Loader" data-mc-generated-bookmark="TOC"></a><span class="section-label">12.11.6 </span>Using the ARM Boot Loader</h4>
                                    <p>This subsection explains how to use the hex conversion utility with the boot loader for C28x devices with ARM cores. The boot loader accepts the formats listed in <span class="crossreference"><a href="#spnu1183558" class="selected">Table 12-3</a></span>.</p>
                                    <div class="subsection">
                                        <p class="table" id="spnu1183558"><span class="table-label">Table 12-3 </span>Boot Table Source Formats </p>
                                        <table class="gentable">
                                            <colgroup>
                                                <col />
                                                <col />
                                            </colgroup>
                                            <thead class="tbl_hdr_gray">
                                                <tr>
                                                    <th>Format</th>
                                                    <th>Option</th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                <tr>
                                                    <td>Parallel boot GP I/O 8 bit</td>
                                                    <td>--gpio8</td>
                                                </tr>
                                                <tr>
                                                    <td>Parallel boot GP I/O 16 bit</td>
                                                    <td>--gpio16</td>
                                                </tr>
                                                <tr>
                                                    <td>8-bit SPI boot</td>
                                                    <td>--spi8</td>
                                                </tr>
                                            </tbody>
                                        </table>
                                    </div>
                                    <p>The ARM on C28x devices with ARM cores can boot through the SPI-A 8-bit, GP I/O 8-bit, or GP I/I 16-bit interface. The format of the boot table is shown in <span class="crossreference"><a href="#spnu118368" class="selected">Table 12-4</a></span>.</p>
                                    <div class="subsection">
                                        <p class="table" id="spnu118368"><span class="table-label">Table 12-4 </span>Boot Table Format </p>
                                        <table class="gentable">
                                            <colgroup>
                                                <col />
                                                <col />
                                                <col />
                                            </colgroup>
                                            <thead class="tbl_hdr_gray">
                                                <tr>
                                                    <th>Description</th>
                                                    <th>Bytes</th>
                                                    <th>Content</th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                <tr>
                                                    <td>Boot table header</td>
                                                    <td>1-2</td>
                                                    <td>Key value (0x10AA or 0x08AA)</td>
                                                </tr>
                                                <tr>
                                                    <td />
                                                    <td>3-18</td>
                                                    <td>Register initialization value or reserved for future use</td>
                                                </tr>
                                                <tr>
                                                    <td />
                                                    <td>19-22</td>
                                                    <td>Entry point</td>
                                                </tr>
                                                <tr>
                                                    <td>Block header</td>
                                                    <td>23-24</td>
                                                    <td>Block size in number of bytes (nl)</td>
                                                </tr>
                                                <tr>
                                                    <td />
                                                    <td>25-28</td>
                                                    <td>Destination address of the block</td>
                                                </tr>
                                                <tr>
                                                    <td>Block data</td>
                                                    <td>29-30</td>
                                                    <td>Raw data for the block (nl bytes)</td>
                                                </tr>
                                                <tr>
                                                    <td>Block header</td>
                                                    <td>31 + nl</td>
                                                    <td>Block size in number of bytes</td>
                                                </tr>
                                                <tr>
                                                    <td />
                                                    <td>.</td>
                                                    <td>Destination address of the block</td>
                                                </tr>
                                                <tr>
                                                    <td>Block data</td>
                                                    <td>.</td>
                                                    <td>Raw data for the block</td>
                                                </tr>
                                                <tr>
                                                    <td>Additional block headers and data, as required</td>
                                                    <td>...</td>
                                                    <td>Content as appropriate</td>
                                                </tr>
                                                <tr>
                                                    <td>Block header with size 0</td>
                                                    <td />
                                                    <td>0x0000; indicates the end of the boot table.</td>
                                                </tr>
                                            </tbody>
                                        </table>
                                    </div>
                                    <p>The ARM on C28x devices with ARM cores can boot through either the serial 8-bit or parallel interface with either 8- or 16-bit data. The format is the same for any combination: the boot table consists of a field containing the destination address, a field containing the length, and a block containing the data. You can boot only one section. If you are booting from an 8-bit channel, 8-bit bytes are stored in the table with MSBs first; the hex conversion utility automatically builds the table in the correct format. Use the following options to specify the boot table source:</p>
                                    <ul>
                                        <li value="1">To boot from a SPI-A port, specify --spi8 when invoking the utility. Do not specify --memwidth or --romwidth. Use --lospcp to set the initial value for the LOSPCP register and --spibrr to set the initial value for the SPIBRR register. If the register values are not specified for the --spi8 format, the hex conversion utility uses the default value 0x02 for LOSPCP and 0x7F for SPIBRR.</li>
                                        <li value="2">To load from a general-purpose parallel I/O port, invoke the utility with --gpio8 or --gpio16. Do not specify --memwidth or --romwidth.</li>
                                    </ul>
                                    <p>The command file in <span class="crossreference"><a href="#spnu118607" class="selected">Example 12-3</a></span> allows you to boot the .text and .cinit sections of test.out from a 16-bit-wide EPROM at location 0x3FFC00. The map file test.map is also generated. </p>
                                    <div class="example">
                                        <h4 id="spnu118607"><a name="Example_12-3_Sample_Command_File_for_Booting_From_8-Bit_SPI_Boot" data-mc-generated-bookmark="TOC"></a><span class="example-label">Example 12-3 </span>Sample Command File for Booting From 8-Bit SPI Boot</h4><code>/*---------------------------------------------------------------------------*/
/* Hex converter command file. */
/*---------------------------------------------------------------------------*/
test.out /* Input file */
--ascii /* Select ASCII format */
--map=test.map /* Specify the map file */
--outfile=test_spi8.hex /* Hex utility out file */
--boot /* Consider all the input sections as boot sections */
--spi8 /* Specify the SPI 8-bit boot format */
--lospcp=0x3F /* Set the initial value for the LOSPCP as 0x3F */
 /* The -spibrr option is not specified to show that */
 /* the hex utility uses the default value (0x7F) */
--entrypoint=0x3F0000 /* Set the entry point */</code>
                                    </div>
                                    <p>The command file in <span class="crossreference"><a href="#spnu118607" class="selected">Example 12-3</a></span> generates the out file in <span class="crossreference"><a href="#spnu118273" class="selected">Figure 12-6</a></span>. The control register values are coded in the boot table header and that header has the address that is specified with the --entrypoint option.</p>
                                    <div class="figure"><span class="caption" id="spnu118273"><span class="figure-label">Figure 12-6 </span>Sample Hex Converter Out File for Booting From 8-Bit SPI Boot</span> <img alt="hexout8spi_pnu118.png" itemprop="image" src="ods/images/SPNU118U/hexout8spi_pnu118.png" title="Sample Hex Converter Out File&#xA;    for Booting From 8-Bit SPI Boot" /> </div>
                                    <p>The command file in <span class="crossreference"><a href="#spnu1182266" class="selected">Example 12-4</a></span> allows you to boot the .text and .cinit sections of test.out from the 16-bit parallel GP I/O port. The map file test.map is also generated.</p>
                                    <div class="example">
                                        <h4 id="spnu1182266"><a name="Example_12-4_Sample_Command_File_for_ARM_16-Bit_Parallel_Boot_GP_I_O" data-mc-generated-bookmark="TOC"></a><span class="example-label">Example 12-4 </span>Sample Command File for ARM 16-Bit Parallel Boot GP I/O</h4><code>/*---------------------------------------------------------------------*/
/* Hex converter command file. */
/*---------------------------------------------------------------------*/
test.out /* Input file */
--ascii /* Select ASCII format */
--map=test.map /* Specify the map file */
--outfile=test_gpio16.hex /* Hex utility out file */
--gpio16 /* Specify the 16-bit GP I/O boot format */

SECTIONS
{
 .text: paddr=BOOT
 .cinit: paddr=BOOT
}</code>
                                    </div>
                                    <p>The command file in <span class="crossreference"><a href="#spnu1182266" class="selected">Example 12-4</a></span> generates the out file in <span class="crossreference"><a href="#spnu1189943" class="selected">Figure 12-7</a></span>.</p>
                                    <div class="figure"><span class="caption" id="spnu1189943"><span class="figure-label">Figure 12-7 </span>Sample Hex Converter Out File for ARM 16-Bit Parallel Boot GP I/O</span> <img alt="hexout16gpio_pnu118.png" itemprop="image" src="ods/images/SPNU118U/hexout16gpio_pnu118.png" title="Sample Hex Converter Out&#xA;    File for ARM 16-Bit Parallel Boot GP I/O" /> </div>
                                </div>
                            </div>
                            <div class="subsection">
                                <h3 id="STDZ0791353"><a name="12.12_Controlling_the_ROM_Device_Address" data-mc-generated-bookmark="TOC"></a><span class="section-label">12.12 </span>Controlling the ROM Device Address</h3>
                                <p> The hex conversion utility output address field corresponds to the ROM device address. The EPROM programmer burns the data into the location specified by the hex conversion utility output file address field. The hex conversion utility offers some mechanisms to control the starting address in ROM of each section. However, many EPROM programmers offer direct control of the location in ROM in which the data is burned.</p>
                                <div class="subsection">
                                    <p>The address field of the hex-conversion utility output file is controlled by the following items, which are listed from low to high priority:</p>
                                    <ol>
                                        <li value="1"><b>The linker command file.</b> By default, the address field of the hex conversion utility output file is the load address (as given in the linker command file).</li>
                                        <li value="2"><b>The paddr parameter of the SECTIONS directive. </b>When the paddr parameter is specified for a section, the hex conversion utility bypasses the section load address and places the section in the address specified by paddr. </li>
                                        <li value="3"><b>The --zero option. </b>When you use the --zero option, the utility resets the address origin to 0 for each output file. Since each file starts at 0 and counts upward, any address records represent offsets from the beginning of the file (the address within the ROM) rather than actual target addresses of the data.</li>
                                        <p>You must use the --zero option in conjunction with the --image option to force the starting address in each output file to be zero. If you specify the --zero option without the --image option, the utility issues a warning and ignores the --zero option.</p>
                                        <li id="STDZ0796623" value="4"><b>The --byte option. </b>Some EPROM programmers may require the output file address field to contain a byte count rather than a word count. If you use the −byte option, the output file address increments once for each byte. For example, if the starting address is 0h, the first line contains eight words, and you use no −byte option, the second line would start at address 8 (8h). If the starting address is 0h, the first line contains eight words, and you use the −byte option, the second line would start at address 16 (010h). The data in both examples are the same; −byte affects only the calculation of the output file address field, not the actual target processor address of the converted data.</li>
                                        <p>The --byte option causes the address records in an output file to refer to byte locations within the file, whether the target processor is byte-addressable or not.</p>
                                    </ol>
                                </div>
                            </div>
                            <div class="subsection">
                                <h3 id="STDZ0796452"><a name="12.13_Control_Hex_Conversion_Utility_Diagnostics" data-mc-generated-bookmark="TOC"></a><span class="section-label">12.13 </span>Control Hex Conversion Utility Diagnostics</h3>
                                <p>The hex conversion utility uses certain C/C++ compiler options to control hex-converter-generated diagnostics. </p>
                                <div class="subsection">
                                    <table class="tabbedtext">
                                        <colgroup>
                                            <col />
                                            <col />
                                        </colgroup>
                                        <tbody>
                                            <tr>
                                                <td align="left" class="noBorderRight noBorderBottom" valign="top"> <b>--diag_error</b>=<i>id</i></td>
                                                <td align="left" class="noBorderRight noBorderBottom" valign="top">Categorizes the diagnostic identified by <i>id</i> as an error. To determine the numeric identifier of a diagnostic message, use the --display_error_number option first in a separate link. Then use --diag_error=<i>id</i> to recategorize the diagnostic as an error. You can only alter the severity of discretionary diagnostics.</td>
                                            </tr>
                                            <tr>
                                                <td align="left" class="noBorderRight noBorderBottom" valign="top"> <b>--diag_remark</b>=<i>id</i></td>
                                                <td align="left" class="noBorderRight noBorderBottom" valign="top">Categorizes the diagnostic identified by <i>id</i> as a remark. To determine the numeric identifier of a diagnostic message, use the --display_error_number option first in a separate link. Then use --diag_remark=<i>id</i> to recategorize the diagnostic as a remark. You can only alter the severity of discretionary diagnostics.</td>
                                            </tr>
                                            <tr>
                                                <td align="left" class="noBorderRight noBorderBottom" valign="top"> <b>--diag_suppress</b>=<i>id</i></td>
                                                <td align="left" class="noBorderRight noBorderBottom" valign="top">Suppresses the diagnostic identified by <i>id</i>. To determine the numeric identifier of a diagnostic message, use the --display_error_number option first in a separate link. Then use --diag_suppress=<i>id</i> to suppress the diagnostic. You can only suppress discretionary diagnostics.</td>
                                            </tr>
                                            <tr>
                                                <td align="left" class="noBorderRight noBorderBottom" valign="top"> <b>--diag_warning</b>=<i>id</i></td>
                                                <td align="left" class="noBorderRight noBorderBottom" valign="top">Categorizes the diagnostic identified by <i>id</i> as a warning. To determine the numeric identifier of a diagnostic message, use the --display_error_number option first in a separate link. Then use --diag_warning=<i>id</i> to recategorize the diagnostic as a warning. You can only alter the severity of discretionary diagnostics.</td>
                                            </tr>
                                            <tr>
                                                <td align="left" class="noBorderRight noBorderBottom" valign="top"> <b>--display_error_number</b></td>
                                                <td align="left" class="noBorderRight noBorderBottom" valign="top">Displays a diagnostic's numeric identifier along with its text. Use this option in determining which arguments you need to supply to the diagnostic suppression options (--diag_suppress, --diag_error, --diag_remark, and --diag_warning). This option also indicates whether a diagnostic is discretionary. A discretionary diagnostic is one whose severity can be overridden. A discretionary diagnostic includes the suffix -D; otherwise, no suffix is present. See the <i> <span>ARM Optimizing C/C++ Compiler User's Guide</span></i> for more information on understanding diagnostic messages.</td>
                                            </tr>
                                            <tr>
                                                <td align="left" class="noBorderRight noBorderBottom" valign="top"> <b>--issue_remarks</b></td>
                                                <td align="left" class="noBorderRight noBorderBottom" valign="top">Issues remarks (nonserious warnings), which are suppressed by default.</td>
                                            </tr>
                                            <tr>
                                                <td align="left" class="noBorderRight noBorderBottom" valign="top"> <b>--no_warnings</b></td>
                                                <td align="left" class="noBorderRight noBorderBottom" valign="top">Suppresses warning diagnostics (errors are still issued).</td>
                                            </tr>
                                            <tr>
                                                <td align="left" class="noBorderRight noBorderBottom" valign="top"> <b>--set_error_limit</b>=<i>count</i></td>
                                                <td align="left" class="noBorderRight noBorderBottom" valign="top">Sets the error limit to <i>count</i>, which can be any decimal value. The linker abandons linking after this number of errors. (The default is 100.)</td>
                                            </tr>
                                            <tr>
                                                <td align="left" class="noBorderRight noBorderBottom" valign="top"> <b>--verbose_diagnostics</b></td>
                                                <td align="left" class="noBorderRight noBorderBottom" valign="top">Provides verbose diagnostics that display the original source with line-wrap and indicate the position of the error in the source line</td>
                                            </tr>
                                        </tbody>
                                    </table>
                                </div>
                            </div>
                            <div class="subsection">
                                <h3 id="STDZ0792390"><a name="12.14_Description_of_the_Object_Formats" data-mc-generated-bookmark="TOC"></a><span class="section-label">12.14 </span>Description of the Object Formats</h3>
                                <p>The hex conversion utility has options that identify each format. <span class="crossreference"><a href="#STDZ0794552" class="selected">Table 12-5</a></span> specifies the format options. They are described in the following sections.</p>
                                <ul>
                                    <li id="IDaimtx" value="1">You should use only one of these options on the command line. If you use more than one option, the last one you list overrides the others.</li>
                                    <li value="2">The default format is Tektronix (--tektronix option).</li>
                                </ul>
                                <div class="subsection">
                                    <p class="table" id="STDZ0794552"><span class="table-label">Table 12-5 </span>Options for Specifying Hex Conversion Formats </p>
                                    <table class="gentable">
                                        <colgroup>
                                            <col />
                                            <col />
                                            <col />
                                            <col />
                                            <col />
                                        </colgroup>
                                        <thead class="tbl_hdr_gray">
                                            <tr>
                                                <th align="left" class="noBorderRight" valign="bottom">Option</th>
                                                <th align="left" class="noBorderRight" valign="bottom">Alias</th>
                                                <th align="left" class="noBorderRight" valign="bottom">Format</th>
                                                <th align="center" class="noBorderRight" valign="bottom">Address Bits</th>
                                                <th align="center" class="noBorderRight" valign="bottom">Default Width</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            <tr>
                                                <td align="left" class="noBorderRight noBorderBottom" valign="top">--ascii</td>
                                                <td align="left" class="noBorderRight noBorderBottom" valign="top">-a</td>
                                                <td align="left" class="noBorderRight noBorderBottom" valign="top">ASCII-Hex</td>
                                                <td align="center" class="noBorderRight noBorderBottom" valign="top">16</td>
                                                <td align="center" class="noBorderRight noBorderBottom" valign="top">8</td>
                                            </tr>
                                            <tr>
                                                <td align="left" class="noBorderRight noBorderBottom" valign="top">--intel</td>
                                                <td align="left" class="noBorderRight noBorderBottom" valign="top">-i</td>
                                                <td align="left" class="noBorderRight noBorderBottom" valign="top">Intel</td>
                                                <td align="center" class="noBorderRight noBorderBottom" valign="top">32</td>
                                                <td align="center" class="noBorderRight noBorderBottom" valign="top">8</td>
                                            </tr>
                                            <tr>
                                                <td align="left" class="noBorderRight noBorderBottom" valign="top">--motorola=1</td>
                                                <td align="left" class="noBorderRight noBorderBottom" valign="top">-m1</td>
                                                <td align="left" class="noBorderRight noBorderBottom" valign="top">Motorola-S1</td>
                                                <td align="center" class="noBorderRight noBorderBottom" valign="top">16</td>
                                                <td align="center" class="noBorderRight noBorderBottom" valign="top">8</td>
                                            </tr>
                                            <tr>
                                                <td align="left" class="noBorderRight noBorderBottom" valign="top">--motorola=2</td>
                                                <td align="left" class="noBorderRight noBorderBottom" valign="top">-m2</td>
                                                <td align="left" class="noBorderRight noBorderBottom" valign="top">Motorola-S2</td>
                                                <td align="center" class="noBorderRight noBorderBottom" valign="top">24</td>
                                                <td align="center" class="noBorderRight noBorderBottom" valign="top">8</td>
                                            </tr>
                                            <tr>
                                                <td align="left" class="noBorderRight noBorderBottom" valign="top">--motorola=3</td>
                                                <td align="left" class="noBorderRight noBorderBottom" valign="top">-m3</td>
                                                <td align="left" class="noBorderRight noBorderBottom" valign="top">Motorola-S3</td>
                                                <td align="center" class="noBorderRight noBorderBottom" valign="top">32</td>
                                                <td align="center" class="noBorderRight noBorderBottom" valign="top">8</td>
                                            </tr>
                                            <tr>
                                                <td align="left" class="noBorderRight noBorderBottom" valign="top">--ti-tagged</td>
                                                <td align="left" class="noBorderRight noBorderBottom" valign="top">-t</td>
                                                <td align="left" class="noBorderRight noBorderBottom" valign="top">TI-Tagged</td>
                                                <td align="center" class="noBorderRight noBorderBottom" valign="top">16</td>
                                                <td align="center" class="noBorderRight noBorderBottom" valign="top">16</td>
                                            </tr>
                                            <tr>
                                                <td align="left" class="noBorderRight noBorderBottom" valign="top">--ti_txt</td>
                                                <td align="left" class="noBorderRight noBorderBottom" valign="top" />
                                                <td align="left" class="noBorderRight noBorderBottom" valign="top">TI_TXT</td>
                                                <td align="center" class="noBorderRight noBorderBottom" valign="top">8</td>
                                                <td align="center" class="noBorderRight noBorderBottom" valign="top">8</td>
                                            </tr>
                                            <tr>
                                                <td align="left" class="noBorderRight noBorderBottom" valign="top">--tektronix</td>
                                                <td align="left" class="noBorderRight noBorderBottom" valign="top">-x</td>
                                                <td align="left" class="noBorderRight noBorderBottom" valign="top">Tektronix</td>
                                                <td align="center" class="noBorderRight noBorderBottom" valign="top">32</td>
                                                <td align="center" class="noBorderRight noBorderBottom" valign="top">8</td>
                                            </tr>
                                        </tbody>
                                    </table>
                                </div>
                                <p><b>Address bits</b> determine how many bits of the address information the format supports. Formats with 16-bit addresses support addresses up to 64K only. The utility truncates target addresses to fit in the number of available bits.</p>
                                <p> The <b>default width</b> determines the default output width of the format. You can change the default width by using the --romwidth option or by using the romwidth parameter in the ROMS directive. You cannot change the default width of the TI-Tagged format, which supports a 16-bit width only.</p>
                                <div class="subsection">
                                    <h4 id="STDZ079753"><a name="12.14.1_ASCII-Hex_Object_Format_(--ascii_Option)" data-mc-generated-bookmark="TOC"></a><span class="section-label">12.14.1 </span>ASCII-Hex Object Format (--ascii Option)</h4>
                                    <p> The ASCII-Hex object format supports <span>16</span>-bit addresses. The format consists of a byte stream with bytes separated by spaces. <span class="crossreference"><a href="#STDZ079741" class="selected">Figure 12-8</a></span> illustrates the ASCII-Hex format.</p>
                                    <div class="figure"><span class="caption" id="STDZ079741"><span class="figure-label">Figure 12-8 </span>ASCII-Hex Object Format</span> <img alt="ascii_hex_tdz079.gif" itemprop="image" src="ods/images/SPNU118U/ascii_hex_tdz079.gif" title="ASCII-Hex Object&#xA;    Format" /> </div>
                                    <p>The file begins with an ASCII STX character (ctrl-B, 02h) and ends with an ASCII ETX character (ctrl-C, 03h). Address records are indicated with $AXXXXXXX, in which XXXXXXXX is a 8-digit (16-bit) hexadecimal address. The address records are present only in the following situations:</p>
                                    <ul>
                                        <li value="1">When discontinuities occur</li>
                                        <li value="2">When the byte stream does not begin at address 0</li>
                                    </ul>
                                    <p>You can avoid all discontinuities and any address records by using the --image and --zero options. This creates output that is simply a list of byte values.</p>
                                </div>
                                <div class="subsection">
                                    <h4 id="STDZ0792937"><a name="12.14.2_Intel_MCS-86_Object_Format_(--intel_Option)" data-mc-generated-bookmark="TOC"></a><span class="section-label">12.14.2 </span>Intel MCS-86 Object Format (--intel Option)</h4>
                                    <p> The Intel object format supports 16-bit addresses and 32-bit extended addresses. Intel format consists of a 9-character (4-field) prefix (which defines the start of record, byte count, load address, and record type), the data, and a 2-character checksum suffix.</p>
                                    <p>The 9-character prefix represents three record types:</p>
                                    <div class="subsection">
                                        <table class="gentable">
                                            <colgroup>
                                                <col />
                                                <col />
                                            </colgroup>
                                            <thead class="tbl_hdr_gray">
                                                <tr>
                                                    <th align="center" class="noBorderRight" valign="bottom">Record Type</th>
                                                    <th align="left" class="noBorderRight" valign="bottom">Description</th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                <tr>
                                                    <td align="center" class="noBorderRight noBorderBottom" valign="middle">00</td>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="middle">Data record</td>
                                                </tr>
                                                <tr>
                                                    <td align="center" class="noBorderRight noBorderBottom" valign="top">01</td>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="middle">End-of-file record</td>
                                                </tr>
                                                <tr>
                                                    <td align="center" class="noBorderRight noBorderBottom" valign="top">04</td>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">Extended linear address record</td>
                                                </tr>
                                            </tbody>
                                        </table>
                                    </div>
                                    <p>Record type00, the data record, begins with a colon ( : ) and is followed by the byte count, the address of the first data byte, the record type (00), and the checksum. The address is the least significant 16 bits of a 32-bit address; this value is concatenated with the value from the most recent 04 (extended linear address) record to create a full 32-bit address. The checksum is the 2s complement (in binary form) of the preceding bytes in the record, including byte count, address, and data bytes.</p>
                                    <p>Record type 01, the end-of-file record, also begins with a colon ( : ), followed by the byte count, the address, the record type (01), and the checksum.</p>
                                    <p>Record type 04, the extended linear address record, specifies the upper 16 address bits. It begins with a colon ( : ), followed by the byte count, a dummy address of 0h, the record type (04), the most significant 16 bits of the address, and the checksum. The subsequent address fields in the data records contain the least significant bytes of the address.</p>
                                    <p><span class="crossreference"><a href="#STDZ0794635" class="selected">Figure 12-9</a></span> illustrates the Intel hexadecimal object format.</p>
                                    <div class="figure"><span class="caption" id="STDZ0794635"><span class="figure-label">Figure 12-9 </span>Intel Hexadecimal Object Format</span> <img alt="intel_hex_tdz079.gif" itemprop="image" src="ods/images/SPNU118U/intel_hex_tdz079.gif" title="Intel Hexadecimal Object&#xA;    Format" /> </div>
                                </div>
                                <div class="subsection">
                                    <h4 id="STDZ0796026"><a name="12.14.3_Motorola_Exorciser_Object_Format_(--motorola_Option)" data-mc-generated-bookmark="TOC"></a><span class="section-label">12.14.3 </span>Motorola Exorciser Object Format (--motorola Option)</h4>
                                    <p> The Motorola S1, S2, and S3 formats support 16-bit, 24-bit, and 32-bit addresses, respectively. The formats consist of a start-of-file (header) record, data records, and an end-of-file (termination) record. Each record consists of five fields: record type, byte count, address, data, and checksum. The three record types are:</p>
                                    <div class="subsection">
                                        <table class="gentable">
                                            <colgroup>
                                                <col />
                                                <col />
                                            </colgroup>
                                            <thead class="tbl_hdr_gray">
                                                <tr>
                                                    <th align="center" class="noBorderRight" valign="bottom">Record Type</th>
                                                    <th align="left" class="noBorderRight" valign="bottom">Description</th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                <tr>
                                                    <td align="center" class="noBorderRight noBorderBottom" valign="middle">S0</td>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="middle">Header record</td>
                                                </tr>
                                                <tr>
                                                    <td align="center" class="noBorderRight noBorderBottom" valign="middle">S1</td>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="middle">Code/data record for 16-bit addresses (S1 format)</td>
                                                </tr>
                                                <tr>
                                                    <td align="center" class="noBorderRight noBorderBottom" valign="middle">S2</td>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="middle">Code/data record for 24-bit addresses (S2 format)</td>
                                                </tr>
                                                <tr>
                                                    <td align="center" class="noBorderRight noBorderBottom" valign="top">S3</td>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="middle">Code/data record for 32-bit addresses (S3 format)</td>
                                                </tr>
                                                <tr>
                                                    <td align="center" class="noBorderRight noBorderBottom" valign="top">S7</td>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">Termination record for 32-bit addresses (S3 format)</td>
                                                </tr>
                                                <tr>
                                                    <td align="center" class="noBorderRight noBorderBottom" valign="top">S8</td>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">Termination record for 24-bit addresses (S2 format)</td>
                                                </tr>
                                                <tr>
                                                    <td align="center" class="noBorderRight noBorderBottom" valign="top">S9</td>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">Termination record for 16-bit addresses (S1 format)</td>
                                                </tr>
                                            </tbody>
                                        </table>
                                    </div>
                                    <p>The byte count is the character pair count in the record, excluding the type and byte count itself.</p>
                                    <p>The checksum is the least significant byte of the 1s complement of the sum of the values represented by the pairs of characters making up the byte count, address, and the code/data fields.</p>
                                    <p><span class="crossreference"><a href="#STDZ0798871" class="selected">Figure 12-10</a></span> illustrates the Motorola-S object format.</p>
                                    <div class="figure"><span class="caption" id="STDZ0798871"><span class="figure-label">Figure 12-10 </span>Motorola-S Format</span> <img alt="motor_hex_tdz079.gif" itemprop="image" src="ods/images/SPNU118U/motor_hex_tdz079.gif" title="Motorola-S Format" /> </div>
                                </div>
                                <div class="subsection">
                                    <h4 id="STDZ0794050"><a name="12.14.4_Extended_Tektronix_Object_Format_(--tektronix_Option)" data-mc-generated-bookmark="TOC"></a><span class="section-label">12.14.4 </span>Extended Tektronix Object Format (--tektronix Option)</h4>
                                    <p> The Tektronix object format supports 32-bit addresses and has two types of records:</p>
                                    <div class="subsection">
                                        <table class="tabbedtext">
                                            <colgroup>
                                                <col align="left" />
                                                <col />
                                            </colgroup>
                                            <tbody>
                                                <tr>
                                                    <td class="noBorderRight noBorderBottom" valign="top"> <b>Data records</b> <![CDATA[ ]]></td>
                                                    <td class="noBorderRight noBorderBottom" valign="top">contains the header field, the load address, and the object code.</td>
                                                </tr>
                                                <tr>
                                                    <td class="noBorderRight noBorderBottom" valign="top"> <b>Termination records</b> <![CDATA[ ]]></td>
                                                    <td class="noBorderRight noBorderBottom" valign="top">signifies the end of a module.</td>
                                                </tr>
                                            </tbody>
                                        </table>
                                    </div>
                                    <p>The header field in the data record contains the following information:</p>
                                    <div class="subsection">
                                        <table class="gentable">
                                            <colgroup>
                                                <col />
                                                <col />
                                                <col />
                                            </colgroup>
                                            <thead class="tbl_hdr_gray">
                                                <tr>
                                                    <th align="left" class="noBorderRight" valign="bottom">Item</th>
                                                    <th align="center" class="noBorderRight" valign="bottom">Number of ASCII Characters</th>
                                                    <th align="left" class="noBorderRight" valign="bottom">Description</th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                <tr>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="middle">%</td>
                                                    <td align="center" class="noBorderRight noBorderBottom" valign="middle">1</td>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="middle">Data type is Tektronix format</td>
                                                </tr>
                                                <tr>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">Block length</td>
                                                    <td align="center" class="noBorderRight noBorderBottom" valign="middle">2</td>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="middle">Number of characters in the record, minus the %</td>
                                                </tr>
                                                <tr>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">Block type</td>
                                                    <td align="center" class="noBorderRight noBorderBottom" valign="top">1</td>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">6 = data record<br /> 8 = termination record</td>
                                                </tr>
                                                <tr>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">Checksum</td>
                                                    <td align="center" class="noBorderRight noBorderBottom" valign="top">2</td>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">A 2-digit hex sum modulo 256 of all values in the record except the % and the checksum itself.</td>
                                                </tr>
                                            </tbody>
                                        </table>
                                    </div>
                                    <p>The load address in the data record specifies where the object code will be located. The first digit specifies the address length; this is always 8. The remaining characters of the data record contain the object code, two characters per byte.</p>
                                    <p><span class="crossreference"><a href="#STDZ0798720" class="selected">Figure 12-11</a></span> illustrates the Tektronix object format.</p>
                                    <div class="figure"><span class="caption" id="STDZ0798720"><span class="figure-label">Figure 12-11 </span>Extended Tektronix Object Format</span> <img alt="tektronix_tdz079.gif" itemprop="image" src="ods/images/SPNU118U/tektronix_tdz079.gif" title="Extended Tektronix Object&#xA;    Format" /> </div>
                                </div>
                                <div class="subsection">
                                    <h4 id="STDZ0799951"><a name="12.14.5_Texas_Instruments_SDSMAC_(TI-Tagged)_Object_Format_(--ti_tagged_Option)" data-mc-generated-bookmark="TOC"></a><span class="section-label">12.14.5 </span>Texas Instruments SDSMAC (TI-Tagged) Object Format (--ti_tagged Option)</h4>
                                    <p> The Texas Instruments SDSMAC (TI-Tagged) object format supports 16-bit addresses, including start-of-file record, data records, and end-of-file record. Each data records consists of a series of small fields and is signified by a tag character:</p>
                                    <div class="subsection">
                                        <table class="gentable">
                                            <colgroup>
                                                <col />
                                                <col />
                                            </colgroup>
                                            <thead class="tbl_hdr_gray">
                                                <tr>
                                                    <th align="center" class="noBorderRight" valign="bottom">Tag Character</th>
                                                    <th align="left" class="noBorderRight" valign="bottom">Description</th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                <tr>
                                                    <td align="center" class="noBorderRight noBorderBottom" valign="top">K</td>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="middle">Followed by the program identifier</td>
                                                </tr>
                                                <tr>
                                                    <td align="center" class="noBorderRight noBorderBottom" valign="top">7</td>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="middle">Followed by a checksum</td>
                                                </tr>
                                                <tr>
                                                    <td align="center" class="noBorderRight noBorderBottom" valign="top">8</td>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">Followed by a dummy checksum (ignored)</td>
                                                </tr>
                                                <tr>
                                                    <td align="center" class="noBorderRight noBorderBottom" valign="top">9</td>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">Followed by a 16-bit load address</td>
                                                </tr>
                                                <tr>
                                                    <td align="center" class="noBorderRight noBorderBottom" valign="top">B</td>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">Followed by a data word (four characters)</td>
                                                </tr>
                                                <tr>
                                                    <td align="center" class="noBorderRight noBorderBottom" valign="top">F</td>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">Identifies the end of a data record</td>
                                                </tr>
                                                <tr>
                                                    <td align="center" class="noBorderRight noBorderBottom" valign="top">*</td>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">Followed by a data byte (two characters)</td>
                                                </tr>
                                            </tbody>
                                        </table>
                                    </div>
                                    <p><span class="crossreference"><a href="#STDZ0791453" class="selected">Figure 12-12</a></span> illustrates the tag characters and fields in TI-Tagged object format.</p>
                                    <div class="figure"><span class="caption" id="STDZ0791453"><span class="figure-label">Figure 12-12 </span>TI-Tagged Object Format</span> <img alt="ti_tagged_tdz079.gif" itemprop="image" src="ods/images/SPNU118U/ti_tagged_tdz079_752x245.gif" title="TI-Tagged Object&#xA;    Format" style="width: 752;height: 245;" /> </div>
                                    <p>If any data fields appear before the first address, the first field is assigned address 0000h. Address fields may be expressed but not required for any data byte. The checksum field, preceded by the tag character 7, is the 2s complement of the sum of the 8-bit ASCII values of characters, beginning with the first tag character and ending with the checksum tag character (7 or 8). The end-of-file record is a colon ( : ).</p>
                                </div>
                                <div class="subsection">
                                    <h4 id="STDZ0795656"><a name="12.14.6_TI-TXT_Hex_Format_(--ti_txt_Option)" data-mc-generated-bookmark="TOC"></a><span class="section-label">12.14.6 </span>TI-TXT Hex Format (--ti_txt Option)</h4>
                                    <p>The TI-TXT hex format supports 16-bit hexadecimal data. It consists of section start addresses, data byte, and an end-of-file character. These restrictions apply:</p>
                                    <ul>
                                        <li value="1">The number of sections is unlimited.</li>
                                        <li value="2">Each hexadecimal start address must be even.</li>
                                        <li value="3">Each line must have 16 data bytes, except the last line of a section. </li>
                                        <li value="4">Data bytes are separated by a single space.</li>
                                        <li value="5">The end-of-file termination tag q is mandatory.</li>
                                    </ul>
                                    <p>The data record contains the following information:</p>
                                    <div class="subsection">
                                        <table class="gentable">
                                            <colgroup>
                                                <col />
                                                <col />
                                            </colgroup>
                                            <thead class="tbl_hdr_gray">
                                                <tr>
                                                    <th align="center" class="noBorderRight" valign="bottom">Item</th>
                                                    <th align="left" class="noBorderRight" valign="bottom">Description</th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                <tr>
                                                    <td align="center" class="noBorderRight noBorderBottom" valign="top">@ADDR</td>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="middle">Hexadecimal start address of a section</td>
                                                </tr>
                                                <tr>
                                                    <td align="center" class="noBorderRight noBorderBottom" valign="top">DATAn</td>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="middle">Hexadecimal data byte</td>
                                                </tr>
                                                <tr>
                                                    <td align="center" class="noBorderRight noBorderBottom" valign="top">q</td>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">End-of-file termination character</td>
                                                </tr>
                                            </tbody>
                                        </table>
                                    </div>
                                    <div class="figure"><span class="caption" id="STDZ079img6710"><span class="figure-label">Figure 12-13 </span>TI-TXT Object Format</span> <img alt="ti_txt_tdz079.gif" itemprop="image" src="ods/images/SPNU118U/ti_txt_tdz079.gif" title="TI-TXT Object&#xA;    Format" /> </div>
                                    <div class="example">
                                        <h4 id="STDZ0798998"><a name="Example_12-5_TI-TXT_Object_Format" data-mc-generated-bookmark="TOC"></a><span class="example-label">Example 12-5 </span>TI-TXT Object Format</h4><code>@F000
31 40 00 03 B2 40 80 5A 20 01 D2 D3 22 00 D2 E3
21 00 3F 40 E8 FD 1F 83 FE 23 F9 3F
@FFFE
00 F0
Q</code>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div><a href="../Resources/MasterPages/..SPNU118U_HTML/abstract.html">Back to Top</a>
                    <p /><a href="http://www.go-dsp.com/forms/techdoc/doc_feedback.htm?litnum=SPNU118U&amp;partnum=ARM">Submit Documentation Feedback</a>
                    <p>Copyright© 2018, Texas Instruments Incorporated. An <a href="includes/important_notice.html">IMPORTANT NOTICE</a> for this document addresses availability, warranty, changes, use in safety-critical applications, intellectual property matters and other important disclaimers.</p>
                </div>
            </div>
        </div>
    </body>
</html>