/*
    Copyright (c) 2015-2020, Texas Instruments Incorporated
    All rights reserved.

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:

    *   Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.
        notice, this list of conditions and the following disclaimer in the
        documentation and/or other materials provided with the distribution.
    *   Neither the name of Texas Instruments Incorporated nor the names of
        its contributors may be used to endorse or promote products derived
        from this software without specific prior written permission.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
    AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
    THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
    CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
    EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
    OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
    WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
    OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
*/
/**
* `TiCcxml` handles ccxml file discovery, fixup and generation.
*    All methods are static.
*
* Example:
*
*      import { TiCcxml } from './ti-core-backplane/lib;
*/
import { TiUtils } from '../../ti-core-assets/lib/TiUtils';
import { TiFiles } from '../../ti-core-assets/lib/TiFiles';
import { TiConsole } from '../../ti-core-assets/lib/TiConsole';
import { TiXmlHttp } from './TiXmlHttp';
export default class TiCcxml {
    /**
     * helper function that can be called to generate a device object for the specified device
     *
     * @param deviceName - the device id to generate the object for
     * @param supportedDevicesList - an object containing either the target_setup.json file from TICloudAgent
     *   (if available) or the local target_setup.json file.
     * @result object containing the following properties: id, xmlFile, connectionIndices
     */
    static getDeviceObjForDevice(deviceName, supportedDevicesList) {
        let deviceObj = null;
        if (supportedDevicesList && deviceName) {
            const deviceNameUpperCase = deviceName.toUpperCase();
            let index = 0;
            while (supportedDevicesList.devices.length > index) {
                deviceObj = supportedDevicesList.devices[index];
                if (deviceObj.id.toLowerCase() === deviceNameUpperCase.toLowerCase()) {
                    break;
                }
                index++;
            }
        }
        return deviceObj;
    }
    /**
     *  helper function that can be called to generate a connection object for a
     *  UARTConnection without having to specify a device name
     *
     *  @param supportedDevicesList - an object containing either the target_setup.json file from TICloudAgent
     *   (if available) or the local target_setup.json file.
     *  @result object containing the following properties: connectionType, id, xmlFile
     */
    static getUartConnectionObj(supportedDevicesList) {
        let result = null;
        if (supportedDevicesList) {
            let index = 0;
            while (supportedDevicesList.connections.length > index) {
                const connectionObj = supportedDevicesList.connections[index];
                if (connectionObj.id.toLowerCase().indexOf('uart') >= 0) {
                    result = connectionObj;
                    break;
                }
                else {
                    index++;
                }
            }
        }
        return result;
    }
    /**
     * getDeviceCcxmlFile returns the ccxml file that corresponds to the configuration specified by the
     * deviceObj and connectionObj parameters. These parameters are typically from the target_setup.json file
     * provided by the TICloudAgent, but can be generated by calling other APIs in TiCcxml
     *
     * @param deviceObj - object with the following properties: id, xmlFile, connectionIndices
     * @param connectionObj - object with the following properties: connectionType, id, xmlFile
     * @result promise that resolves to a string containing the ccxml file contents
     */
    static async getDeviceCcxmlFile(deviceObj, connectionObj, folderPath = 'target') {
        let deviceNameUpperCase = deviceObj.id.toUpperCase();
        const spaceIndex = deviceNameUpperCase.indexOf(' ');
        if (spaceIndex >= 0) {
            //skip e.g. Tiva family name and use just the part number
            deviceNameUpperCase = deviceNameUpperCase.substring(spaceIndex).trim();
        }
        let ccxmlFileContents = '';
        /* if the user has uploaded their own .ccxml file, use that file instead of the string from the model / programloader
          or from the cloud agent */
        const userCcxmlFileContents = await TiCcxml.getUserCcxmlFile(false, folderPath);
        if (userCcxmlFileContents) {
            if (userCcxmlFileContents.length === 0) {
                throw new Error('invalid user ccxml file returned from getUserCcxmlFile');
            }
            else {
                const fixedCcxmlFileContents = await TiCcxml.fixUpCcxmlFileContents(userCcxmlFileContents, deviceObj, connectionObj, true);
                return fixedCcxmlFileContents;
            }
        }
        else {
            try {
                let url = `/ticloudagent/getConfig/${TiUtils.OS}/${connectionObj.xmlFile}/${deviceObj.xmlFile}`;
                if (!TiUtils.isCloud || TiUtils.isCCS) {
                    url = `${window.location.protocol}//dev.ti.com${url}`;
                }
                ccxmlFileContents = await TiXmlHttp.httpGetIfOnline(url, 'text');
                if ((!ccxmlFileContents) || (ccxmlFileContents && ccxmlFileContents.length && ccxmlFileContents.length === 0)) {
                    throw new Error(`invalid ccxml file returned from ${url}`);
                }
                else {
                    const fixedCcxmlFileContents = await TiCcxml.fixUpCcxmlFileContents(ccxmlFileContents, deviceObj, connectionObj, false);
                    return fixedCcxmlFileContents;
                }
            }
            catch (error) {
                if (error) {
                    TiConsole.error(TiCcxml.SERVICE_NAME, `ti-core-backplane.getDeviceCcxmlFile: error = ${error}`);
                }
                const localCcxmlFileLookupList = await TiCcxml.getLocalCcxmlFileLookupList();
                if (localCcxmlFileLookupList.devices[deviceNameUpperCase] !== undefined) {
                    const ccxmlName = localCcxmlFileLookupList.devices[deviceNameUpperCase].ccxml;
                    const xmlDeviceName = localCcxmlFileLookupList.devices[deviceNameUpperCase].xmlDeviceName;
                    ccxmlFileContents = localCcxmlFileLookupList[ccxmlName].join('\n');
                    ccxmlFileContents = ccxmlFileContents.replace(/%DEVICE%/g, xmlDeviceName);
                }
                // Note: supported_devices.json only works with default connection types.
                // Cannot call _fixUpCcxmlFileContents to fix up these files to support other connection types such as uart_connection.
                return ccxmlFileContents;
            }
        }
    }
    /**
     * Saves a ccxml string to a file in the target folder with the name <deviceName>.ccxml
     *
     * @result a promise that resolves when the file has been written or is rejected in case of an error
     */
    static saveCcxmlFile(deviceName, ccxmlString, folderPath = 'target') {
        const fileName = deviceName + '.ccxml';
        const filePath = TiUtils.path.join(folderPath, fileName);
        return TiFiles.writeTextFile(filePath, ccxmlString);
    }
    /**
     *  This function is typically only called for desktop versions of the designer or application.
     *
     *  @result a promise that resolves to the local supported_devices.json file contents
     */
    static async getLocalCcxmlFileLookupList() {
        const localCcxmlFileLookupList = await TiFiles.readJsonFile(TiCcxml.SUPPORTED_DEVICES_JSON_PATH);
        return localCcxmlFileLookupList;
    }
    /**
     * Generates a ccxml file for a specified deviceName and connectionId, where
     * the deviceName matches the id of a device object in the supported devices list
     * and connectionId is the xmlFile property of a connection object in the target_setup.json file.
     * (The supported devices list is accessed online via the dev.ti.com/ticloudagent/getConfig API)
     *
     * @param deviceName - name of the device (e.g. MSP432P401R)
     * @param connectionId - name of the connection's xmlFile (e.g. TIMSP430-USB)
     * @result a promise
     */
    static async generateCcxmlFile(deviceName, connectionId) {
        const resultObj = await TiCcxml.getCcxmlFilePlusObjects(deviceName, connectionId, undefined, undefined);
        if ((resultObj) && (resultObj.strCcxml)) {
            return resultObj.strCcxml;
        }
        else {
            throw new Error('No ccxml file generated.');
        }
    }
    /**
     * getCcxmlFilePlusObjects takes a device name and connection Id and returns the associated objects for the specified
     * device and connection as well as the ccxml string to use for that device and connection
     *
     * @param deviceName - name of the target device (e.g. MSP432P401R)
     * @param connectionId - connection xmlFile (from the target_setup.json file - e.g. Texas Instruments XDS110 USB Debug Probe)
     * @param defaultCcxmlString - optional, if defined, this will be used if on the desktop instead of going online to get the ccxml string.
     * @param forceUseOfDefaultCcxmlString - optional, typically used for testing.  Use defaultCcxmlString even if online
     * @returns  promise that resolves to an object containing deviceObj, connectionObj and strCcxml properties
     */
    static async getCcxmlFilePlusObjects(deviceName, connectionId, defaultCcxmlString, forceUseOfDefaultCcxmlString) {
        const deviceNameUpperCase = deviceName.toUpperCase();
        let connectionIdFixed = await TiCcxml.fixConnectionId(connectionId);
        let connectionIdUpperCase = null;
        let deviceObj = null;
        let connectionObj = null;
        let ccxmlString = defaultCcxmlString;
        // Check if the user has provided a target_config.ccxml file in the target folder, and use
        // that if it exists and !forceUseOfDefaultCcxmlString, else use the defaultCcxmlString
        try {
            const userCcxmlString = await TiCcxml.getUserCcxmlFile(false);
            if ((userCcxmlString) && (userCcxmlString.length > 0) && (!forceUseOfDefaultCcxmlString)) {
                defaultCcxmlString = userCcxmlString;
                forceUseOfDefaultCcxmlString = true;
            }
            if ((ccxmlString && (!TiUtils.isCloud || TiUtils.isCCS || TiUtils.isMobile)) ||
                (forceUseOfDefaultCcxmlString && defaultCcxmlString)) {
                if (forceUseOfDefaultCcxmlString) {
                    ccxmlString = defaultCcxmlString;
                }
                if (!ccxmlString) {
                    ccxmlString = '';
                }
                const connectionTagIndex = ccxmlString.indexOf('<instance');
                if (connectionTagIndex > 0) {
                    let connectionTag = ccxmlString.substring(connectionTagIndex);
                    connectionTag = connectionTag.substring(0, connectionTag.indexOf('/>'));
                    connectionIdFixed = connectionTag.substring(connectionTag.indexOf('xml="') + 'xml="'.length);
                    connectionIdFixed = connectionIdFixed.substring(0, connectionIdFixed.indexOf('.xml"'));
                }
                let connectionType = '';
                let connectionIndex = 0;
                let connectionDisplayStr = '';
                switch (connectionIdFixed) {
                    case 'uart_connection':
                        connectionType = 'uartconnection';
                        connectionDisplayStr = 'UARTConnection';
                        connectionIndex = 0;
                        break;
                    case 'TIXDS100usb_Connection':
                        connectionType = 'tixds100';
                        connectionDisplayStr = 'Texas Instruments XDS100v1 USB Debug Probe';
                        connectionIndex = 1;
                        break;
                    case 'TIXDS110_Connection':
                        connectionType = 'tixds110';
                        connectionDisplayStr = 'Texas Instruments XDS110 USB Debug Probe';
                        connectionIndex = 2;
                        break;
                    case 'TIXDS100v3_Dot7_Connection':
                        connectionType = 'tixds100v2';
                        connectionDisplayStr = 'Texas Instruments XDS100v3 USB Debug Probe';
                        connectionIndex = 3;
                        break;
                    case 'DataSnapshotViewer': // not supported, but included for ease in checking against local target_setup.json file
                        connectionType = 'datasnapshotviewer';
                        connectionDisplayStr = 'Data Snapshot Viewer';
                        connectionIndex = 4;
                        break;
                    case 'TIXDS560_Rev_D_Connection':
                        connectionType = 'tixds560';
                        connectionDisplayStr = 'Texas Instruments XDS560 Debug Probe, 20-pin Rev-D Cable';
                        connectionIndex = 5;
                        break;
                    case 'TIXDS560_Connection':
                        connectionType = 'tixds560';
                        connectionDisplayStr = 'Texas Instruments XDS560 Debug Probe';
                        connectionIndex = 6;
                        break;
                    case 'TIXDS2XXUSB_onboard_Connection':
                        connectionType = 'tixds200';
                        connectionDisplayStr = 'Texas Instruments XDS2xx USB Onboard Debug Probe';
                        connectionIndex = 7;
                        break;
                    case 'Stellaris_ICDI_Connection':
                        connectionType = 'lm_icdi';
                        connectionDisplayStr = 'Stellaris In-Circuit Debug Interface';
                        connectionIndex = 8;
                        break;
                    case 'TIMSP430-USB2':
                        connectionType = 'msp430';
                        connectionDisplayStr = 'TI MSP430 USB2';
                        connectionIndex = 9;
                        break;
                    case 'TIMSP430-USB3':
                        connectionType = 'msp430';
                        connectionDisplayStr = 'TI MSP430 USB3';
                        connectionIndex = 10;
                        break;
                    case 'TIXDS100v2_Connection':
                        connectionType = 'tixds100v2';
                        connectionDisplayStr = 'Texas Instruments XDS100v2 USB Debug Probe';
                        connectionIndex = 11;
                        break;
                    case 'TIXDS2XXUSB_Connection':
                        connectionType = 'tixds200';
                        connectionDisplayStr = 'Texas Instruments XDS2xx USB Debug Probe';
                        connectionIndex = 12;
                        break;
                    case 'TIMSP430-USB':
                        connectionType = 'msp430';
                        connectionDisplayStr = 'TI MSP430 USB1';
                        connectionIndex = 13;
                        break;
                    case 'TIXDS560_Rev_BD_Dot7_Connection':
                        connectionType = 'tixds560';
                        connectionDisplayStr = 'Texas Instruments XDS560 Debug Probe, 2-Pin cJTAG with External Converter';
                        connectionIndex = 14;
                        break;
                    default:
                        // eslint-disable-next-line no-case-declarations
                        const msg = `Error parsing defaultCcxmlString: connectionId=${connectionId} does not appear to be valid!`;
                        TiConsole.error(TiCcxml.SERVICE_NAME, `ti-core-backplane.getCcxmlFilePlusObjects:${msg}`);
                        throw msg;
                }
                connectionObj = {
                    connectionType: connectionType,
                    id: connectionDisplayStr,
                    xmlFile: connectionId
                };
                const platformTagIndex = ccxmlString.indexOf('<platform');
                let deviceXml = undefined;
                if (platformTagIndex > 0) {
                    deviceXml = ccxmlString.substring(platformTagIndex);
                    deviceXml = deviceXml.substring(deviceXml.indexOf('xml="') + 'xml="'.length);
                    deviceXml = deviceXml.substring(0, deviceXml.indexOf('.xml"'));
                }
                else {
                    const msg1 = `Badly formed ccxml string: ${ccxmlString}`;
                    TiConsole.error(TiCcxml.SERVICE_NAME, `ti-core-backplane.getCcxmlFilePlusObjectsmsg:${msg1}`);
                    throw msg1;
                }
                deviceObj = {
                    id: deviceName,
                    xmlFile: deviceXml,
                    connectionIndices: [connectionIndex]
                };
                const fixedCcxmlString = await TiCcxml.fixUpCcxmlFileContents(ccxmlString, deviceObj, connectionObj, true);
                const resultObj = {
                    deviceObj: deviceObj,
                    connectionObj: connectionObj,
                    strCcxml: fixedCcxmlString
                };
                return resultObj;
            }
            else {
                const supportedDevicesObj = await TiCcxml.getSupportedDevicesList();
                if (!supportedDevicesObj) {
                    throw new Error('Could not get supported devices list');
                }
                for (let i = 0; i < supportedDevicesObj.devices.length; i++) {
                    const device = supportedDevicesObj.devices[i];
                    if (device.id.toUpperCase() === deviceNameUpperCase) {
                        deviceObj = device;
                        break;
                    }
                }
                if (connectionId) {
                    connectionIdUpperCase = await TiCcxml.fixConnectionId(connectionId);
                    connectionIdUpperCase = connectionIdUpperCase.toUpperCase();
                    if (supportedDevicesObj.connections) {
                        for (let j = 0; j < supportedDevicesObj.connections.length; j++) {
                            const connection = supportedDevicesObj.connections[j];
                            if ((!connectionIdUpperCase) || (connection.xmlFile.toUpperCase() === connectionIdUpperCase)) {
                                connectionObj = connection;
                                break;
                            }
                        }
                    }
                }
                if (!connectionObj) {
                    connectionObj = TiCcxml.getDefaultConnectionObjForDevice(deviceName, supportedDevicesObj);
                    if (connectionObj) {
                        connectionId = connectionObj.xmlFile;
                        connectionIdUpperCase = connectionId.toUpperCase();
                    }
                }
                if (!deviceObj) {
                    throw new Error(`Device ${deviceNameUpperCase} is not supported`);
                }
                if (!connectionObj) {
                    throw new Error(`Connection ${connectionId} is not supported`);
                }
                const strCcxml = await TiCcxml.getDeviceCcxmlFile(deviceObj, connectionObj);
                const result = {
                    deviceObj: deviceObj,
                    connectionObj: connectionObj,
                    strCcxml: strCcxml
                };
                return result;
            }
        }
        catch (error) {
            TiConsole.error(TiCcxml.SERVICE_NAME, 'ti-behavior.ccxml.generateCcxmlFile: error=' + error);
            throw new Error(`Error generating ccxmlFile: ${error}`);
        }
        ;
    }
    /**
     * returns the target_setup.json object, either from the TICloudAgent if online or from the local
     * target_setup.json file if not.
     */
    static async getSupportedDevicesList() {
        let location = `/ticloudagent/getConfigInfo?os=${TiUtils.OS}`;
        if (!TiUtils.isCloud || TiUtils.isCCS) {
            location = `${window.location.protocol}//dev.ti.com${location}`;
        }
        let result = null;
        try {
            const fileContents = await TiXmlHttp.httpGetIfOnline(location, 'text');
            try {
                result = JSON.parse(fileContents);
            }
            catch (ex) {
                TiConsole.error(TiCcxml.SERVICE_NAME, `TiCcxml.getSupportedDevicesList: exception=${ex}`);
            }
        }
        catch (error) {
            TiConsole.info(TiCcxml.SERVICE_NAME, `TiCcxml.getSupportedDevicesList: failed with error = ${error}`);
            TiConsole.info(TiCcxml.SERVICE_NAME, 'TiCcxml.getSupportedDevicesList: falling back to local targetSetupLIst...');
            result = await TiCcxml.getLocalTargetSetupList();
        }
        ;
        return result;
    }
    /**
     * if the user has added a custom ccxml file to the target folder, this function will return it
     *
     * @param isMonitor true to request monitor_config ccxml file, false to request target_config ccxml file.
     * @param folderPath (optional) relative path to the folder the .ccxml file is in (default = target)
     * @return async contents of the ccxml file if there is one, else resolves to null
     */
    static async getUserCcxmlFile(isMonitor, folderPath = 'target') {
        const fileName = isMonitor ? 'monitor_config.ccxml' : 'target_config.ccxml';
        const filePath = TiUtils.path.join(folderPath, fileName);
        try {
            const contents = await TiFiles.readTextFile(filePath);
            TiConsole.debug(TiCcxml.SERVICE_NAME, `getUserCcxmlFile: found file named ${filePath}`);
            return contents;
        }
        catch (error) {
            TiConsole.debug(TiCcxml.SERVICE_NAME, `getUserCcxmlFile: did not find file named ${filePath}: error=${error}`);
            return null;
        }
    }
    /**
     * Legacy Gallery apps may use the connectionObj.id value (i.e. the selectedDevice.connectionDisplayStr value)
     * as the connectionId instead of the connectionObj.xmlFile property value.
     * This method checks for connectionId values that match any of the legacy display string
     * values and converts them into the appropriate xmlFile string.
     *
     * @param connectionId value to check and fix if needed
     * @result the fixed up connectionId value
     */
    static async fixConnectionId(connectionId) {
        let result = connectionId;
        // for legacy Gallery apps that use the connection display string as connectionId, convert
        // connection Id into corresponding xmlFile name
        if (connectionId) {
            switch (connectionId) {
                case 'UARTConnection':
                    result = 'uart_connection';
                    break;
                case 'Texas Instruments XDS100v1 USB Debug Probe': // for legacy Gallery apps that use the connection display string as connectionId
                    result = 'TIXDS100usb_Connection';
                    break;
                case 'Texas Instruments XDS110 USB Debug Probe': // for legacy Gallery apps that use the connection display string as connectionId
                    result = 'TIXDS110_Connection';
                    break;
                case 'Texas Instruments XDS100v3 USB Debug Probe':
                    result = 'TIXDS100v3_Dot7_Connection';
                    break;
                case 'Data Snapshot Viewer':
                    result = 'DataSnapshotViewer';
                    break;
                case 'Texas Instruments XDS560 Debug Probe, 20-pin Rev-D Cable':
                    result = 'TIXDS560_Rev_D_Connection';
                    break;
                case 'Texas Instruments XDS560 Debug Probe':
                    result = 'TIXDS560_Connection';
                    break;
                case 'Texas Instruments XDS2xx USB Onboard Debug Probe':
                    result = 'TIXDS2XXUSB_onboard_Connection';
                    break;
                case 'Stellaris In-Circuit Debug Interface':
                    result = 'Stellaris_ICDI_Connection';
                    break;
                case 'TI MSP430 USB1':
                    result = 'TIMSP430-USB';
                    break;
                case 'TI MSP430 USB2':
                    result = 'TIMSP430-USB2';
                    break;
                case 'TI MSP430 USB3':
                    result = 'TIMSP430-USB3';
                    break;
                case 'Texas Instruments XDS100v2 USB Debug Probe':
                    result = 'TIXDS100v2_Connection';
                    break;
                case 'Texas Instruments XDS2xx USB Debug Probe':
                    result = 'TIXDS2XXUSB_Connection';
                    break;
                case 'Texas Instruments XDS560 Debug Probe, 2-Pin cJTAG with External Converter':
                    result = 'TIXDS560_Rev_BD_Dot7_Connection';
                    break;
            }
        }
        return result;
    }
    /**
     * This function is typically only called for desktop versions of the designer or application
     *
     * @result a promise that resolves to the local target_setup.json file contents
     */
    static async getLocalTargetSetupList() {
        if (!TiCcxml.localTargetSetupList) {
            try {
                TiCcxml.localTargetSetupList = await TiFiles.readJsonFile(TiCcxml.TARGET_SETUP_JSON_PATH);
            }
            catch (ex) {
                TiConsole.log(TiCcxml.SERVICE_NAME, `TiCcxml.getLocalTargetSetupList: Exception reading ${TiCcxml.TARGET_SETUP_JSON_PATH}: ${ex}`);
            }
            const os = TiUtils.OS;
            const env = global;
            // In order to avoid having to have separate OS-specific fallback files,
            // this local file has a special property named notSupportedOnOSX to indicate
            // devices in the list which are not to be listed as supported if the OS is OSX.
            if ((TiCcxml.localTargetSetupList) && (os === env.TICloudAgent.OS.OSX)) {
                let i = 0;
                while (i < TiCcxml.localTargetSetupList.devices.length) {
                    if (TiCcxml.localTargetSetupList.devices[i].notSupportedOnOSX) {
                        TiCcxml.localTargetSetupList.devices.splice(i, 1);
                    }
                    else {
                        i++;
                    }
                }
            }
        }
        return TiCcxml.localTargetSetupList;
    }
    /**
     * gets the default (i.e. preferred) connection object to use for the specified device.
     *
     * @param deviceName: string containing the name of the device
     * @param supportedDevicesList: the object returned by the getSupportedDevicesList method
     * @return the default connection object to use for the specified device.
     */
    static getDefaultConnectionObjForDevice(deviceName, supportedDevicesList) {
        let result = null;
        if (!supportedDevicesList)
            return result;
        let keyword = 'UART';
        let deviceNameUpperCase = '';
        if (deviceName) {
            deviceNameUpperCase = deviceName.toUpperCase();
        }
        if (deviceNameUpperCase.indexOf('MSP430') >= 0) {
            keyword = 'MSP430 USB1';
        }
        else if (deviceNameUpperCase.indexOf('RF430') >= 0) {
            keyword = 'MSP430 USB1';
        }
        else if (deviceNameUpperCase.indexOf('MSP432') >= 0) {
            keyword = 'XDS110';
        }
        else if (deviceNameUpperCase.indexOf('TMS320F28') >= 0) {
            keyword = 'XDS100v2';
        }
        else if ((deviceNameUpperCase.indexOf('TM4C') >= 0) || (deviceNameUpperCase.indexOf('CC3200') >= 0)) {
            keyword = 'Stellaris';
        }
        else if (deviceNameUpperCase.indexOf('CC1310') >= 0) {
            keyword = 'XDS100v3';
        }
        else if (deviceNameUpperCase.indexOf('CC2650') >= 0) {
            keyword = 'XDS110';
        }
        // Special case: use UART for MSP430F2617 device for motor control applications as default
        if (deviceNameUpperCase.indexOf('MSP430F2617') >= 0) {
            keyword = 'UART';
        }
        const deviceObj = TiCcxml.getDeviceObjForDevice(deviceName, supportedDevicesList);
        let deviceConnectionIndices = [];
        if (deviceObj) {
            deviceConnectionIndices = deviceObj.connectionIndices;
        }
        if ((deviceObj) && (deviceObj.defaultConnectionIndex !== undefined)) {
            result = supportedDevicesList.connections[deviceObj.defaultConnectionIndex];
        }
        else {
            let index = 0;
            let connectionIndex = 0;
            while (supportedDevicesList.connections && supportedDevicesList.connections.length > index) {
                const connectionObj = supportedDevicesList.connections[index];
                if (connectionObj.id.toLowerCase().indexOf(keyword.toLowerCase()) >= 0) {
                    result = connectionObj;
                    connectionIndex = index;
                    break;
                }
                else {
                    index++;
                }
            }
            if ((deviceConnectionIndices && deviceConnectionIndices.length > 0) && (deviceConnectionIndices.indexOf(connectionIndex) < 0)) {
                connectionIndex = deviceConnectionIndices[0];
                if (connectionIndex && connectionIndex >= 0) {
                    result = supportedDevicesList.connections[connectionIndex];
                }
            }
        }
        return result;
    }
    /**
     * This procedure is responsible for fixing any pending bugs in the TICloudAgent that have not yet been fixed.
     * Currently this is fixing the following JIRAs:
     * GC-793,  TICLD-2064, TICLD-1808
     *
     * @param ccxmlFileContents - the ccxml file returned from the server (or, if offline, from the supported_devices.json file
     * @param deviceObj - the device object from the target_setup.json file for the selected device
     * @param connectionObj - the connection object from the target_setup.json file for the selected device
     * @param isUserCcxmlFile - optional - if true, a user-provided ccxml file is being used
     * @return  a promise that resolves to the fixed-up ccxml file contents
     */
    static fixUpCcxmlFileContents(ccxmlFileContents, deviceObj, connectionObj, isUserCcxmlFile) {
        if (!connectionObj)
            return Promise.reject('Invalid connection object');
        if (!ccxmlFileContents)
            return Promise.reject('no ccxml file contents');
        let deviceNameUpperCase = '';
        switch (connectionObj.xmlFile) {
            case 'TIXDS110_Connection':
                switch (deviceObj.id) {
                    // Temporary workaround for GC-1409 until GC-1405 is implemented
                    case 'TMS320F280049C':
                        if (!isUserCcxmlFile && (ccxmlFileContents.indexOf('id="SWD Mode Settings"')) < 0) {
                            const splitIndex = ccxmlFileContents.indexOf('<platform XML_version="1.2"');
                            const ccxmlStrPart1 = ccxmlFileContents.substring(0, splitIndex);
                            const ccxmlStrPart2 = ccxmlFileContents.substring(splitIndex);
                            const ccxmlStrInsert = '<property id="SWD Mode Settings" desc="JTAG / SWD / cJTAG Mode" Type="choicelist" Value="4"/>\n             ';
                            ccxmlFileContents = ccxmlStrPart1 + ccxmlStrInsert + ccxmlStrPart2;
                        }
                        break;
                }
                break;
            case 'uart_connection':
                // only fix up the ccxml file if it doesn't include a <cpu tag
                if (ccxmlFileContents.indexOf('<cpu') < 0) {
                    // Split the ccxml file after the <instance ... tag for the device, i.e. before the </platform> tag
                    const splitIndex = ccxmlFileContents.indexOf('</platform>');
                    if (splitIndex > 0) {
                        const ccxmlStrPart1 = ccxmlFileContents.substring(0, splitIndex);
                        const ccxmlStrPart2 = ccxmlFileContents.substring(splitIndex);
                        let ccxmlStrInsert = '';
                        // the id used for the <instance tag must be used for the device tag or the ccxml file will not parse properly
                        let instanceId = deviceObj.xmlFile;
                        const instanceIdIndex = ccxmlStrPart1.lastIndexOf('id="');
                        if (instanceIdIndex >= 0) {
                            instanceId = ccxmlStrPart1.substring(instanceIdIndex + 'id="'.length);
                            instanceId = instanceId.substring(0, instanceId.indexOf('"'));
                        }
                        deviceNameUpperCase = deviceObj.id.toUpperCase();
                        if ((deviceNameUpperCase.indexOf('MSP430') >= 0) || (deviceNameUpperCase.indexOf('RF430') >= 0) || (deviceNameUpperCase.indexOf('CC43') >= 0)) {
                            ccxmlStrInsert = '<device HW_revision="1.0" XML_version="1.2" description="%DEVICE%" id="' + instanceId + '" partnum="%DEVICE%">\n' +
                                '<cpu HW_revision="1.0" XML_version="1.2" description="MSP430 CPU" id="MSP430" isa="MSP430">\n' +
                                '<property Type="stringfield" Value="%SERIALPORT%" id="COM Port"/>\n' +
                                '<property Type="stringfield" Value="%BAUDRATE%" id="Baud Rate"/>\n' +
                                '</cpu>\n' +
                                '</device>\n';
                        }
                        else if ((deviceNameUpperCase.indexOf('MSP432') >= 0) || (deviceNameUpperCase.indexOf('TM4C') >= 0)) {
                            ccxmlStrInsert = '<device HW_revision="1" XML_version="1.2" description="ARM Cortex-M4F MCU" id="' + instanceId + '" partnum="%DEVICE%">\n' +
                                '<router HW_revision="1.0" XML_version="1.2" description="CS_DAP Router" id="CS_DAP_0" isa="CS_DAP">\n' +
                                '<subpath id="subpath_0">\n' +
                                '<cpu HW_revision="1.0" XML_version="1.2" description="Cortex M4 CPU" id="CORTEX_M4_0" isa="CORTEX_M4">\n' +
                                '<property Type="stringfield" Value="%SERIALPORT%" id="COM Port"/>\n' +
                                '<property Type="stringfield" Value="%BAUDRATE%" id="Baud Rate"/>\n' +
                                '</cpu>\n' +
                                '</subpath>\n' +
                                '</router>\n' +
                                '</device>\n';
                        }
                        else if (deviceNameUpperCase.indexOf('TMS320F28') >= 0) {
                            ccxmlStrInsert = '<device HW_revision="1" XML_version="1.2" description="" id="' + instanceId + '" partnum="%DEVICE%">\n' +
                                '<router HW_revision="1.0" XML_version="1.2" description="ICEPick_C router" id="IcePick_C_0" isa="ICEPICK_C">\n' +
                                '<subpath id="Subpath_0">\n' +
                                '<cpu HW_revision="1.0" XML_version="1.2" description="C28xx CPU" id="C28xx_CPU1" isa="TMS320C28XX">\n' +
                                '<property Type="stringfield" Value="%SERIALPORT%" id="COM Port"/>\n' +
                                '<property Type="stringfield" Value="%BAUDRATE%" id="Baud Rate"/>\n' +
                                '</cpu>\n' +
                                '</subpath>\n' +
                                '</router>\n' +
                                '</device>\n';
                        }
                        else if (deviceNameUpperCase.indexOf('TMS320C28') >= 0) {
                            ccxmlStrInsert = '<device HW_revision="1" XML_version="1.2" description="" id="' + instanceId + '" partnum="%DEVICE%">\n' +
                                '<cpu HW_revision="1.0" XML_version="1.2" description="CPU" id="C2800" isa="TMS320C28XX">\n' +
                                '<property Type="stringfield" Value="%SERIALPORT%" id="COM Port"/>\n' +
                                '<property Type="stringfield" Value="%BAUDRATE%" id="Baud Rate"/>\n' +
                                '</cpu>\n' +
                                '</device>\n';
                        }
                        else if ((deviceNameUpperCase.indexOf('CC13') >= 0) || (deviceNameUpperCase.indexOf('CC26') >= 0)) {
                            ccxmlStrInsert = '<device HW_revision="1" XML_version="1.2" description="SimpleLink(TM) %DEVICE% wireless MCU" id="' + instanceId + '" partnum="%DEVICE%">\n' +
                                '<router HW_revision="1.0" XML_version="1.2" description="ICEPick_C Router" id="IcePick_C_0" isa="ICEPICK_C">\n' +
                                '<subpath id="subpath_0">\n' +
                                '<router HW_revision="1.0" XML_version="1.2" description="CS_DAP Router" id="CS_DAP_0" isa="CS_DAP">\n' +
                                '<subpath id="subpath_1">\n' +
                                '<cpu HW_revision="1.0" XML_version="1.2" description="Cortex_M3 CPU" id="Cortex_M3_0" isa="Cortex_M3">\n' +
                                '<property Type="stringfield" Value="%SERIALPORT%" id="COM Port"/>\n' +
                                '<property Type="stringfield" Value="%BAUDRATE%" id="Baud Rate"/>\n' +
                                '</cpu>\n' +
                                '</subpath>\n' +
                                '</router>\n' +
                                '</subpath>\n' +
                                '</router>\n' +
                                '</device>\n';
                        }
                        else if (deviceNameUpperCase.indexOf('F28M') >= 0) {
                            ccxmlStrInsert = '<device HW_revision="1" XML_version="1.2" description="" id="' + instanceId + '" partnum="%DEVICE%">\n' +
                                '<router HW_revision="1.0" XML_version="1.2" description="ICEPick_C router" id="IcePick_C_0" isa="ICEPICK_C">\n' +
                                '<subpath id="C28x">\n' +
                                '<property Type="numericfield" Value="0x11" desc="Port Number_0" id="Port Number"/>\n' +
                                '<cpu HW_revision="1.0" XML_version="1.2" description="C28xx CPU" id="C28xx_0" isa="TMS320C28XX">\n' +
                                '<property Type="stringfield" Value="%SERIALPORT%" id="COM Port"/>\n' +
                                '<property Type="stringfield" Value="%BAUDRATE%" id="Baud Rate"/>\n' +
                                '</cpu>\n' +
                                '</subpath>\n' +
                                '</router>\n' +
                                '</device>\n';
                        }
                        if (ccxmlStrInsert.length > 0) {
                            ccxmlStrInsert = ccxmlStrInsert.replace(/%DEVICE%/g, deviceObj.xmlFile);
                            // NOTE: serial port still needs to be resolved by ti-service-targetaccess...
                            ccxmlFileContents = ccxmlStrPart1 + ccxmlStrInsert + ccxmlStrPart2;
                        }
                    }
                }
                break;
        }
        return Promise.resolve(ccxmlFileContents);
    }
}
TiCcxml.SERVICE_NAME = 'TiCcxml';
TiCcxml.SUPPORTED_DEVICES_JSON_PATH = '/components/@ti/ti-service-backplane/deviceinfo/supported_devices.json';
TiCcxml.TARGET_SETUP_JSON_PATH = '/components/@ti/ti-service-backplane/deviceinfo/target_setup.json';
export { TiCcxml };
//# sourceMappingURL=TiCcxml.js.map