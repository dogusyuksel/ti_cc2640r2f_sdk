import { DelimitedTextCodec } from '../ti-codec-delimited-text/lib/DelimitedTextCodec'; //^ti-codec-delimited-text\ti-codec-delimited-text.tsx,31^
/**
 * `ti-codec-delimited-text` is a non visual component for encoding/decoding text packets that use a specific
 * character string as a delimiter, for example a carriage return.  Optionally, if the packet contains delimiter
 * characters, you can provide and escape string to
 *
 *  Example:
 *
 *     <ti-codec-delimited-text id="cr" delimiter="&#10;"></ti-codec-delimited-text>
 *
 * @customElement ti-codec-delimited-text
 * @polymer
 * @label Delimited Text Codec
 * @group Transports, Models, and Codecs
 * @archetype <ti-codec-delimited-text id="cr"></ti-codec-delimited-text>
 */
export class TiCodecDelimitedText {
    constructor() {
        this.impl = undefined; //^ti-codec-delimited-text\ti-codec-delimited-text.tsx,56^
        /**
         * This character sequence is used to delimit packets of data.  Whenever this codec encounters
         * this sequence of characters, all the data accumlated up until this point is passed along to
         * the next codec in the chain as an entire packet.  This property is optional and if not
         * presentm the default delimiter used is the carrage return.
         *
         * @type {boolean}
         * @order 30
         */
        this.delimiter = undefined; //^ti-codec-delimited-text\ti-codec-delimited-text.tsx,67^
        /**
         * This character sequence is used to escape the delimiter sequence when it occurs inside the packet data.
         * During encoding, any delimiter sequence will have on escapeChar inserted before it to indicated that
         * it is part of the packet an not a real delimiter.  Also any escapeChar that occurs in the packet of data to
         * encode, is also escaped.  So two escape sequenes in a row represent a single escape sequence in the data.
         * When data is decoded, the opposite occurs.  This property is optional, and if omitted, there is no
         * escape sequencing used at all, and it is assumed that delimiters will not occur in the packet data.
         *
         * @type {boolean}
         * @order 33
         */
        this.escapeChar = undefined; //^ti-codec-delimited-text\ti-codec-delimited-text.tsx,80^
        // #region ti-target-configuration/ti-codec-base-props.tsx:
        // -----------Autogenerated - do not edit--------------
        /**
         * A flag indicating that this model, transport, or codec is not necessary for connecting
         * to the target, and any failure should not prevent connection.
         *
         * @type {boolean}
         * @order 77
         */
        this.optional = false; //^ti-codec-delimited-text\ti-codec-delimited-text.tsx,91^
        /**
         * The optional identifier of a target device that is associated with this model, transport or codec.
         * Specifying a target device idicates that this is necessary and/or optional for this connecting
         * to the specified device.  The absence of a target device indicates this is necessary and/or optional
         * for any device.
         *
         * @type {string}
         * @order 80
         */
        this.deviceId = undefined; //^ti-codec-delimited-text\ti-codec-delimited-text.tsx,102^
    }
    // #endregion
    connectedCallback() {
        this.impl = new DelimitedTextCodec(this.el); //^ti-codec-delimited-text\ti-codec-delimited-text.tsx,108^
    }
    ; //^ti-codec-delimited-text\ti-codec-delimited-text.tsx,109^
    static get is() { return "ti-codec-delimited-text"; }
    static get encapsulation() { return "shadow"; }
    static get properties() { return {
        "delimiter": {
            "type": "string",
            "mutable": false,
            "complexType": {
                "original": "string",
                "resolved": "string",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [{
                        "text": "{boolean}",
                        "name": "type"
                    }, {
                        "text": "30",
                        "name": "order"
                    }],
                "text": "This character sequence is used to delimit packets of data.  Whenever this codec encounters\nthis sequence of characters, all the data accumlated up until this point is passed along to\nthe next codec in the chain as an entire packet.  This property is optional and if not\npresentm the default delimiter used is the carrage return."
            },
            "attribute": "delimiter",
            "reflect": false,
            "defaultValue": "undefined"
        },
        "escapeChar": {
            "type": "string",
            "mutable": false,
            "complexType": {
                "original": "string",
                "resolved": "string",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [{
                        "text": "{boolean}",
                        "name": "type"
                    }, {
                        "text": "33",
                        "name": "order"
                    }],
                "text": "This character sequence is used to escape the delimiter sequence when it occurs inside the packet data.\nDuring encoding, any delimiter sequence will have on escapeChar inserted before it to indicated that\nit is part of the packet an not a real delimiter.  Also any escapeChar that occurs in the packet of data to\nencode, is also escaped.  So two escape sequenes in a row represent a single escape sequence in the data.\nWhen data is decoded, the opposite occurs.  This property is optional, and if omitted, there is no\nescape sequencing used at all, and it is assumed that delimiters will not occur in the packet data."
            },
            "attribute": "escape-char",
            "reflect": false,
            "defaultValue": "undefined"
        },
        "optional": {
            "type": "boolean",
            "mutable": false,
            "complexType": {
                "original": "boolean",
                "resolved": "boolean",
                "references": {}
            },
            "required": false,
            "optional": false,
            "docs": {
                "tags": [{
                        "text": "{boolean}",
                        "name": "type"
                    }, {
                        "text": "77",
                        "name": "order"
                    }],
                "text": "A flag indicating that this model, transport, or codec is not necessary for connecting\nto the target, and any failure should not prevent connection."
            },
            "attribute": "optional",
            "reflect": false,
            "defaultValue": "false"
        },
        "deviceId": {
            "type": "string",
            "mutable": false,
            "complexType": {
                "original": "string",
                "resolved": "string",
                "references": {}
            },
            "required": false,
            "optional": true,
            "docs": {
                "tags": [{
                        "text": "{string}",
                        "name": "type"
                    }, {
                        "text": "80",
                        "name": "order"
                    }],
                "text": "The optional identifier of a target device that is associated with this model, transport or codec.\nSpecifying a target device idicates that this is necessary and/or optional for this connecting\nto the specified device.  The absence of a target device indicates this is necessary and/or optional\nfor any device."
            },
            "attribute": "device-id",
            "reflect": false,
            "defaultValue": "undefined"
        }
    }; }
    static get elementRef() { return "el"; }
}
; //^ti-codec-delimited-text\ti-codec-delimited-text.tsx,110^
