<?xml version="1.0" encoding="utf-8"?>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd" lang="en-us" xml:lang="en-us" data-mc-search-type="Stem" data-mc-help-system-file-name="index.xml" data-mc-path-to-help-system="../../" data-mc-target-type="WebHelp2" data-mc-runtime-file-type="Topic" data-mc-preload-images="false" data-mc-in-preview-mode="false" data-mc-toc-path="">
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <meta charset="utf-8" />
        <meta name="description" content="" />
        <meta name="author" content="" />
        <title>2 Introduction to Object Modules</title>
        <link href="../../Skins/Default/Stylesheets/Slideshow.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../Skins/Default/Stylesheets/TextEffects.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../Skins/Default/Stylesheets/Topic.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../Skins/Default/Stylesheets/Components/Styles.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../Skins/Default/Stylesheets/Components/Tablet.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../Skins/Default/Stylesheets/Components/Mobile.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../Resources/Stylesheets/headerfooter.css" rel="stylesheet" />
        <script src="../../Resources/Scripts/custom.modernizr.js">
        </script>
        <script src="../../Resources/Scripts/jquery.min.js">
        </script>
        <script src="../../Resources/Scripts/require.min.js">
        </script>
        <script src="../../Resources/Scripts/require.config.js">
        </script>
        <script src="../../Resources/Scripts/foundation.min.js">
        </script>
        <script src="../../Resources/Scripts/plugins.min.js">
        </script>
        <script src="../../Resources/Scripts/MadCapAll.js">
        </script>
    </head>
    <body>
        <div class="content">
            <div id="contentBody">
                <div class="row collapse">
                    <div class="sideContent">
                        <div class="clearfix">
                        </div>
                    </div>
                    <div id="loadContentArea">
                        <div class="c12 docHeader">
                            <div class="c4 docTitle">
                                <p>
                                    <strong>MSP430 Assembly
							Language Tools
			v18.1.0.LTS User's Guide</strong>
                                    <br />
                                    <span id="litnumber">SLAU131R</span> - REVISED JANUARY 2018</p>
                            </div>
                        </div>
                    </div>
                    <div class="odsHeader">
                        <p class="pdf">
                            <a class="downloadPDF" href="http://www.ti.com/litv/SLAU131R" target="_new">Download PDF</a>
                        </p>
                    </div>
                    <div id="loadContentArea1">
                        <div class="subsection">
                            <h2 id="STDZ0690623">
                                <a MadCap:generatedBookmark="TOC" name="2_Introduction_to_Object_Modules">
                                </a>
                                <span class="section-label">2 </span>Introduction to Object Modules</h2>
                            <div class="subsection">
                                <p>The assembler creates object modules from assembly code, and the linker creates executable object files from object modules. These executable object files can be executed by <span>an MSP430</span> device. </p>
                                <p>Object modules make modular programming easier because they encourage you to think in terms of <i>blocks</i> of code and data when you write an assembly language program. These blocks are known as sections. Both the assembler and the linker provide directives that allow you to create and manipulate sections.</p>
                                <p>This chapter focuses on the concept and use of sections in assembly language programs. </p>
                            </div>
                            <div class="subsection">
                                <h3 id="STDZ06981611_msp">
                                    <a MadCap:generatedBookmark="TOC" name="2.1_Object_File_Format_Specifications">
                                    </a>
                                    <span class="section-label">2.1 </span>Object File Format Specifications</h3>
                                <p>The object files created by the assembler and linker conform to the ELF (Executable and Linking Format) binary format, which is used by the Embedded Application Binary Interface (EABI). See the <i>MSP430 Optimizing C/C++ Compiler User's Guide</i> (<a href="http://www.ti.com/lit/pdf/SLAU132" target="_blank">SLAU132</a>) and <i>The MSP430 Embedded Application Binary Interface Application Report</i> (<a href="http://www.ti.com/lit/pdf/SLAA534" target="_blank">SLAA534</a>) for information on the EABI ABI.</p>
                                <p>COFF object files are not supported in v15.6.0.STS and later versions of the TI Code Generation Tools. If you would like to produce COFF output files, please use v4.4 of the MSP430 Code Generation Tools and refer to <a href="http://www.ti.com/lit/pdf/slau131J" target="_blank">SLAU131J</a> for documentation.</p>
                                <p>The ELF object files generated by the assembler and linker conform to the December 17, 2003 snapshot of the <a href="http://sco.com/developers/gabi/" target="_blank">System V generic ABI (or gABI)</a>.</p>
                            </div>
                            <div class="subsection">
                                <h3 id="SPRU1869925">
                                    <a MadCap:generatedBookmark="TOC" name="2.2_Executable_Object_Files">
                                    </a>
                                    <span class="section-label">2.2 </span>Executable Object Files</h3>
                                <p>
                                    <span>The linker produces executable object modules.</span> An executable object module has the same format as object files that are used as linker input. The sections in an executable object module, however, have been combined and placed in target memory, and the relocations are all resolved.</p>
                                <p>To run a program, the data in the executable object module must be transferred, or loaded, into target system memory. See <span class="crossreference"><a href="program-loading-and-running.html#SLAU1311006">Section 3</a></span> for details about loading and running programs.</p>
                            </div>
                            <div class="subsection">
                                <h3 id="STDZ0691509">
                                    <a MadCap:generatedBookmark="TOC" name="2.3_Introduction_to_Sections">
                                    </a>
                                    <span class="section-label">2.3 </span>Introduction to Sections</h3>
                                <p>The smallest unit of an object file is a <i>section</i>. A section is a block of code or data that occupies contiguous space in the memory map. Each section of an object file is separate and distinct.</p>
                                <p>ELF format executable object files contain <i>segments</i>. An ELF segment is a meta-section. It represents a contiguous region of target memory. It is a collection of <i>sections</i> that have the same property, such as writeable or readable. An ELF loader needs the segment information, but does not need the section information. The ELF standard allows the linker to omit ELF section information entirely from the executable object file.</p>
                                <p>Object files usually contain three default sections:</p>
                                <div class="subsection">
                                    <table class="tabbedtext">
                                        <colgroup>
                                            <col align="left" />
                                            <col align="left" />
                                        </colgroup>
                                        <tbody>
                                            <tr>
                                                <td align="left" class="noBorderRight noBorderBottom"> <b>.text section</b> <![CDATA[ ]]></td>
                                                <td align="left" class="noBorderRight noBorderBottom"> contains executable code <sup>Some targets allow content other than text, such as constants, in .text sections.</sup></td>
                                                <div class="footnote" id="STDZ069156">
                                                    <span class="section-label">1. </span>Some targets allow content other than text, such as constants, in .text sections.</div>
                                            </tr>
                                            <tr>
                                                <td align="left" class="noBorderRight noBorderBottom"> <b>.data section</b> <![CDATA[ ]]></td>
                                                <td align="left" class="noBorderRight noBorderBottom">usually contains initialized data</td>
                                            </tr>
                                            <tr>
                                                <td align="left" class="noBorderRight noBorderBottom"> <b><span>.bss</span> section</b> <![CDATA[ ]]></td>
                                                <td align="left" class="noBorderRight noBorderBottom">usually reserves space for uninitialized variables</td>
                                            </tr>
                                        </tbody>
                                    </table>
                                </div>
                                <p>The assembler and linker allow you to create, name, and link other kinds of sections. The .text, .data, and <span>.bss</span> sections are archetypes for how sections are handled.</p>
                                <p>There are two basic types of sections:</p>
                                <div class="subsection">
                                    <table class="tabbedtext">
                                        <colgroup>
                                            <col align="left" />
                                            <col align="left" />
                                        </colgroup>
                                        <tbody>
                                            <tr>
                                                <td align="left" class="noBorderRight noBorderBottom"> <b>Initialized sections</b> <![CDATA[ ]]></td>
                                                <td align="left" class="noBorderRight noBorderBottom">contain data or code. The .text and .data sections are initialized; user-named sections created with the .sect <span>and .intvec </span>assembler directive<span>s</span> are also initialized.</td>
                                            </tr>
                                            <tr>
                                                <td align="left" class="noBorderRight noBorderBottom"> <b>Uninitialized sections</b> <![CDATA[ ]]></td>
                                                <td align="left" class="noBorderRight noBorderBottom">reserve space in the memory map for uninitialized data. The <span>.bss</span> section is uninitialized; user-named sections created with the .usect assembler directive are also uninitialized.</td>
                                            </tr>
                                        </tbody>
                                    </table>
                                </div>
                                <p>Several assembler directives allow you to associate various portions of code and data with the appropriate sections. The assembler builds these sections during the assembly process, creating an object file organized as shown in <span class="crossreference"><a href="#STDZ0695822">Figure 2-1</a></span>.</p>
                                <p> One of the linker's functions is to relocate sections into the target system's memory map; this function is called <i>placement</i>. Because most systems contain several types of memory, using sections can help you use target memory more efficiently. All sections are independently relocatable; you can place any section into any allocated block of target memory. For example, you can define a section that contains an initialization routine and then allocate the routine in a portion of the memory map that contains ROM. For information on section placement, see the "Specifying Where to Allocate Sections in Memory" section of the <i><span>MSP430 Optimizing C/C++ Compiler User's Guide</span>.</i></p>
                                <p>
                                    <span class="crossreference">
                                        <a href="#STDZ0695822">Figure 2-1</a>
                                    </span> shows the relationship between sections in an object file and a hypothetical target memory.</p>
                                <div class="figure">
                                    <span class="caption" id="STDZ0695822">
                                        <span class="figure-label">Figure 2-1 </span>Partitioning Memory Into Logical Blocks</span> <img alt="memblocks_tdz069.gif" itemprop="image" src="ods/images/SLAU131R/memblocks_tdz069.gif" title="Partitioning Memory Into&#xA;    Logical Blocks" /> </div>
                                <div class="subsection">
                                    <h4 id="SLAU1316707">
                                        <a MadCap:generatedBookmark="TOC" name="2.3.1_Special_Section_Names">
                                        </a>
                                        <span class="section-label">2.3.1 </span>Special Section Names</h4>
                                    <p>You can use the .sect and .usect directives to create any section name you like, but certain sections are treated in a special manner by the linker and the compiler's run-time support library. If you create a section with the same name as a special section, you should take care to follow the rules for that special section.</p>
                                    <p>A few common special sections are:</p>
                                    <ul>
                                        <li value="1"> .text -- Used for program code. </li>
                                        <li value="2">
                                            <span>.bss</span> -- Used for uninitialized objects (global variables). </li>
                                        <li value="3">.data -- Used for initialized non-const objects (global variables). </li>
                                        <li value="4">
                                            <span>.const</span> -- Used for initialized const objects (string constants, variables declared const).</li>
                                        <li value="5"> .cinit -- Used to initialize C global variables at startup.</li>
                                        <li value="6"> .stack -- Used for the function call stack.</li>
                                        <li value="7">
                                            <span>.sysmem</span> - Used for the dynamic memory allocation pool.</li>
                                    </ul>
                                    <p>For more information on sections, see the "Specifying Where to Allocate Sections in Memory" section of the <i><span>MSP430 Optimizing C/C++ Compiler User's Guide</span>.</i></p>
                                </div>
                            </div>
                            <div class="subsection">
                                <h3 id="STDZ0693935">
                                    <a MadCap:generatedBookmark="TOC" name="2.4_How_the_Assembler_Handles_Sections">
                                    </a>
                                    <span class="section-label">2.4 </span>How the Assembler Handles Sections</h3>
                                <p>The assembler identifies the portions of an assembly language program that belong in a given section. The assembler has the following directives that support this function:</p>
                                <ul>
                                    <li value="1">.bss</li>
                                    <li value="2">.data </li>
                                    <li value="3">.intvec</li>
                                    <li value="4">.sect</li>
                                    <li value="5">.text</li>
                                    <li value="6">.usect </li>
                                </ul>
                                <p>The <span>.bss and .usect directives create</span><i>uninitialized sections</i>; the .text, .data, and .sect directives create <i>initialized sections</i>.</p>
                                <p>You can create subsections of any section to give you tighter control of the memory map. Subsections are created using the .sect and .usect directives. Subsections are identified with the base section name and a subsection name separated by a colon; see <span class="crossreference"><a href="#STDZ0693587">Section 2.4.6</a></span>.</p>
                                <span class="note">
                                    <p class="note_title">NOTE</p>
                                    <b>Default Sections Directive</b>
                                    <p>If you do not use any of the sections directives, the assembler assembles everything into the .text section.</p>
                                </span>
                                <div class="subsection">
                                    <h4 id="STDZ069137">
                                        <a MadCap:generatedBookmark="TOC" name="2.4.1_Uninitialized_Sections">
                                        </a>
                                        <span class="section-label">2.4.1 </span>Uninitialized Sections</h4>
                                    <p>Uninitialized sections reserve space in <span>MSP430</span> memory; they are usually placed in RAM. These sections have no actual contents in the object file; they simply reserve memory. A program can use this space at run time for creating and storing variables.</p>
                                    <p>Uninitialized data areas are built by using the following assembler directives.</p>
                                    <ul>
                                        <li value="1">The .bss directive reserves space in the .bss section.</li>
                                        <li value="2">The .usect directive reserves space in a specific uninitialized user-named section.</li>
                                    </ul>
                                    <p>Each time you invoke the <span>.bss or </span>.usect directive, the assembler reserves additional space in the <span>.bss or the</span> user-named section. The syntax is:</p>
                                    <div class="subsection">
                                        <table class="tabbedtext">
                                            <colgroup>
                                                <col />
                                                <col />
                                            </colgroup>
                                            <tbody>
                                                <tr>
                                                    <td class="noBorderRight noBorderBottom" />
                                                    <td class="noBorderRight noBorderBottom"> <b>.bss </b><i>symbol</i><b>,</b><span> <i>size in bytes</i>[<b>, </b><i>alignment </i>]</span></td>
                                                </tr>
                                                <tr>
                                                    <td class="noBorderRight noBorderBottom"> <i>symbol</i> <![CDATA[ ]]></td>
                                                    <td class="noBorderRight noBorderBottom"> <b>.usect "</b><i>section name</i><b>",</b><span> <i>size in bytes</i>[<b>, </b><i>alignment </i>]</span></td>
                                                </tr>
                                            </tbody>
                                        </table>
                                    </div>
                                    <div class="subsection">
                                        <table class="tabbedtext">
                                            <colgroup>
                                                <col align="left" />
                                                <col align="left" />
                                            </colgroup>
                                            <tbody>
                                                <tr>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top"> <i>symbol</i> <![CDATA[ ]]></td>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">points to the first <span>byte</span> reserved by this invocation of the <span>.bss or </span>.usect directive. The <i>symbol</i> corresponds to the name of the variable that you are reserving space for. It can be referenced by any other section and can also be declared as a global symbol (with the .global directive).</td>
                                                </tr>
                                                <tr>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top"> <i>size in bytes</i> <![CDATA[ ]]></td>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">is an absolute expression (see <span class="crossreference"><a href="assembler-description.html#STDZ0716698">Section 4.9</a></span>).<ul><li value="1">The .bss directive reserves <i>size in bytes</i> bytes in the .bss section. You must specify a size; there is no default value.</li><li value="2"> The .usect directive reserves <i>size in bytes</i> bytes in <i>section name</i>. You must specify a size; there is no default value.</li></ul></td>
                                                </tr>
                                                <tr>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top"> <i>alignment</i> <![CDATA[ ]]></td>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">is an optional parameter. It specifies the minimum alignment in bytes required by the space allocated. The default value is byte aligned; this option is represented by the value 1. The value must be a power of 2. The maximum alignment is 32K.</td>
                                                </tr>
                                                <tr>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top"> <i>section name</i> <![CDATA[ ]]></td>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">specifies the user-named section in which to reserve space. See <span class="crossreference"><a href="#STDZ0699738">Section 2.4.3</a></span>.</td>
                                                </tr>
                                            </tbody>
                                        </table>
                                    </div>
                                    <p>Initialized section directives (.text, .data, <span>.intvec, </span>and .sect) change which section is considered the <i>current</i> section (see <span class="crossreference"><a href="#STDZ0692863">Section 2.4.2</a></span>). However, the <span>.bss and .usect directives <i>do not</i></span> change the current section; <span>they simply escape</span> from the current section temporarily. Immediately after a <span>.bss or </span>.usect directive, the assembler resumes assembling into whatever the current section was before the directive. The <span>.bss and .usect directives</span> can appear anywhere in an initialized section without affecting its contents.<span> For an example, see <span class="crossreference"><a href="#STDZ0694846">Section 2.4.7</a></span>.</span></p>
                                    <p>The .usect directive can also be used to create uninitialized subsections. See <span class="crossreference"><a href="#STDZ0693587">Section 2.4.6</a></span> for more information on creating subsections.</p>
                                    <p>The <span>.common directive is</span> similar to directives that create uninitialized data sections, except that common symbols are created, instead.</p>
                                </div>
                                <div class="subsection">
                                    <h4 id="STDZ0692863">
                                        <a MadCap:generatedBookmark="TOC" name="2.4.2_Initialized_Sections">
                                        </a>
                                        <span class="section-label">2.4.2 </span>Initialized Sections</h4>
                                    <p>Initialized sections contain executable code or initialized data. The contents of these sections are stored in the object file and placed in <span>MSP430</span> memory when the program is loaded. Each initialized section is independently relocatable and may reference symbols that are defined in other sections. The linker automatically resolves these references. The following directives tell the assembler to place code or data into a section. The syntaxes for these directives are:</p>
                                    <div class="subsection">
                                        <table class="tabbedtext">
                                            <colgroup>
                                                <col />
                                                <col align="left" />
                                            </colgroup>
                                            <tbody>
                                                <tr>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top" />
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top"> <b>.text</b> <![CDATA[ ]]></td>
                                                </tr>
                                                <tr>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top" />
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top"> <b>.data</b> <![CDATA[ ]]></td>
                                                </tr>
                                                <tr>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top" />
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top"> <b>.sect "</b><i>section name</i><b>"</b> <![CDATA[ ]]></td>
                                                </tr>
                                                <tr>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top" />
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">
                                                        <b>.intvec "</b>
                                                        <i>section name</i>
                                                        <b>"</b>, <i>routine name</i></td>
                                                </tr>
                                            </tbody>
                                        </table>
                                    </div>
                                    <p>The .sect directive can also be used to create initialized subsections. See <span class="crossreference"><a href="#STDZ0693587">Section 2.4.6</a></span>, for more information on creating subsections.</p>
                                </div>
                                <div class="subsection">
                                    <h4 id="STDZ0699738">
                                        <a MadCap:generatedBookmark="TOC" name="2.4.3_User-Named_Sections">
                                        </a>
                                        <span class="section-label">2.4.3 </span>User-Named Sections</h4>
                                    <p>User-named sections are sections that <i>you</i> create. You can use them like the default .text, .data, and <span>.bss</span> sections, but each section with a distinct name is kept distinct during assembly.</p>
                                    <p>For example, repeated use of the .text directive builds up a single .text section in the object file. This .text section is allocated in memory as a single unit. Suppose there is a portion of executable code (perhaps an initialization routine) that you want the linker to place in a different location than the rest of .text. If you assemble this segment of code into a user-named section, it is assembled separately from .text, and you can use the linker to allocate it into memory separately. You can also assemble initialized data that is separate from the .data section, and you can reserve space for uninitialized variables that is separate from the <span>.bss</span> section.</p>
                                    <p>These directives let you create user-named sections:</p>
                                    <ul>
                                        <li value="1">The <b>.usect</b> directive creates uninitialized sections that are used like the <span>.bss</span> section. These sections reserve space in RAM for variables.</li>
                                        <li value="2">The <b>.sect</b> directive creates initialized sections, like the default .text and .data sections, that can contain code or data. The .sect directive creates user-named sections with relocatable addresses.</li>
                                        <li value="3">The <b>.intvec</b> directive creates an interrupt vector entry that points to an interrupt routine name</li>
                                    </ul>
                                    <p>The syntaxes for these directives are:</p>
                                    <div class="subsection">
                                        <table class="tabbedtext">
                                            <colgroup>
                                                <col />
                                                <col align="left" />
                                            </colgroup>
                                            <tbody>
                                                <tr>
                                                    <td class="noBorderRight noBorderBottom"> <i>symbol</i> <![CDATA[ ]]></td>
                                                    <td align="left" class="noBorderRight noBorderBottom"> <b>.usect "</b><i>section name</i><b>", </b><span><i>size in bytes</i>[<b>, </b><i>alignment </i>]</span></td>
                                                </tr>
                                                <tr>
                                                    <td class="noBorderRight noBorderBottom" />
                                                    <td align="left" class="noBorderRight noBorderBottom"> <b>.sect "</b><i>section name</i><b>"</b> <![CDATA[ ]]></td>
                                                </tr>
                                                <tr>
                                                    <td class="noBorderRight noBorderBottom" />
                                                    <td align="left" class="noBorderRight noBorderBottom">
                                                        <b>.intvec "</b>
                                                        <i>section name</i>
                                                        <b>”, </b>
                                                        <i>interrupt routine name</i>
                                                    </td>
                                                </tr>
                                            </tbody>
                                        </table>
                                    </div>
                                    <p>
                                        <span>The maximum number of sections is 2<sup>32</sup>-1 (4294967295). </span>
                                    </p>
                                    <p>The <i>section name</i> parameter is the name of the section. For the .usect and .sect directives, a section name can refer to a subsection; see <span class="crossreference"><a href="#STDZ0693587">Section 2.4.6</a></span> for details.</p>
                                    <p>Each time you invoke one of these directives with a new name, you create a new user-named section. Each time you invoke one of these directives with a name that was already used, the assembler resumes assembling code or data (or reserves space) into the section with that name. <i>You cannot use the same names with different directives</i>. That is, you cannot create a section with the .usect directive and then try to use the same section with .sect<span> or .intvec</span>.</p>
                                </div>
                                <div class="subsection">
                                    <h4 id="SPRU1867265">
                                        <a MadCap:generatedBookmark="TOC" name="2.4.4_Current_Section">
                                        </a>
                                        <span class="section-label">2.4.4 </span>Current Section</h4>
                                    <p>The assembler adds code or data to one section at a time. The section the assembler is currently filling is the <i>current section</i>. The .text, .data, <span>.intvec, </span>and .sect directives change which section is considered the current section. When the assembler encounters one of these directives, it stops assembling into the current section (acting as an implied end of current section command). The assembler sets the designated section as the current section and assembles subsequent code into the designated section until it encounters another .text, .data, <span>.intvec, </span>or .sect directive.</p>
                                    <p>If one of these directives sets the current section to a section that already has code or data in it from earlier in the file, the assembler resumes adding to the end of that section. The assembler generates only one contiguous section for each given section name. This section is formed by concatenating all of the code or data which was placed in that section.</p>
                                    <div class="example">
                                        <h4 id="HTMLI031154">
                                            <a MadCap:generatedBookmark="TOC" name="Example_2-1_File_y.asm">
                                            </a>
                                            <span class="example-label">Example 2-1 </span>File y.asm</h4>
                                        <code>        nop ; the assembler always starts with .text as the current section

 .data
 .word 1

 .text
 add R5,R5

 .data
 .word 2</code>
                                    </div>
                                    <div class="example">
                                        <h4 id="HTMLI035769">
                                            <a MadCap:generatedBookmark="TOC" name="Example_2-2_Disassembly_of_y.obj">
                                            </a>
                                            <span class="example-label">Example 2-2 </span>Disassembly of y.obj</h4>
                                        <p>TEXT Section .text, 0x4 bytes at 0x0</p>
                                        <code>000000: 0343 NOP 
000002: 0555 RLA.W R5
</code>
                                        <p>DATA Section .data, 0x4 bytes at 0x0</p>
                                        <code>000000: 0001 .word 0x0001
000002: 0002 .word 0x0002
</code>
                                    </div>
                                </div>
                                <div class="subsection">
                                    <h4 id="STDZ0698045">
                                        <a MadCap:generatedBookmark="TOC" name="2.4.5_Section_Program_Counters">
                                        </a>
                                        <span class="section-label">2.4.5 </span>Section Program Counters</h4>
                                    <p>The assembler maintains a separate program counter for each section. These program counters are known as <i>section program counters</i>, or <i>SPCs</i>. </p>
                                    <p>An SPC represents the current address within a section of code or data. Initially, the assembler sets each SPC to 0. As the assembler fills a section with code or data, it increments the appropriate SPC. If you resume assembling into a section, the assembler remembers the appropriate SPC's previous value and continues incrementing the SPC from that value.</p>
                                    <p>The assembler treats each section as if it began at address 0; the linker relocates the symbols in each section according to the final address of the section in which that symbol is defined. See <span class="crossreference"><a href="#STDZ0698484">Section 2.7</a></span> for information on relocation.</p>
                                </div>
                                <div class="subsection">
                                    <h4 id="STDZ0693587">
                                        <a MadCap:generatedBookmark="TOC" name="2.4.6_Subsections">
                                        </a>
                                        <span class="section-label">2.4.6 </span>Subsections</h4>
                                    <p>A subsection is created by creating a section with a colon in its name. Subsections are logical subdivisions of larger sections. Subsections are themselves sections and can be manipulated by the assembler and linker. </p>
                                    <p>The assembler has no concept of subsections; to the assembler, the colon in the name is not special. The subsection .text:rts would be considered completely unrelated to its parent section .text, and the assembler will not combine subsections with their parent sections. </p>
                                    <p>Subsections are used to keep parts of a section as distinct sections so that they can be separately manipulated. For instance, by placing each function and object in a uniquely-named subsection, the linker gets a finer-grained view of the section for memory placement and unused-function elimination. </p>
                                    <p>By default, when the linker sees a SECTION directive in the linker command file like ".text", it will gather .text and all subsections of .text into one large output section named ".text". You can instead use the SECTION directive to control the subsection independently. See <span class="crossreference"><a href="linker-description.html#STDZ0756353">Section 8.5.5.1</a></span> for an example. </p>
                                    <p>You can create subsections in the same way you create other user-named sections: by using the .sect or .usect directive.</p>
                                    <p>The syntaxes for a subsection name are:</p>
                                    <div class="subsection">
                                        <table class="tabbedtext">
                                            <colgroup>
                                                <col />
                                                <col align="left" />
                                            </colgroup>
                                            <tbody>
                                                <tr>
                                                    <td class="noBorderRight noBorderBottom"> <i>symbol</i></td>
                                                    <td align="left" class="noBorderRight noBorderBottom">
                                                        <b>.usect "</b>
                                                        <i>section_name</i>
                                                        <b>:</b>
                                                        <i>subsection_name</i>
                                                        <b>",</b>
                                                        <span>
                                                            <i>size in bytes</i>[<b>, </b><i>alignment</i>]</span>
                                                    </td>
                                                </tr>
                                                <tr>
                                                    <td class="noBorderRight noBorderBottom" />
                                                    <td align="left" class="noBorderRight noBorderBottom">
                                                        <b>.sect "</b>
                                                        <i>section_name</i>
                                                        <b>:</b>
                                                        <i>subsection_name</i>
                                                        <b>"</b>
                                                    </td>
                                                </tr>
                                            </tbody>
                                        </table>
                                    </div>
                                    <p>A subsection is identified by the base section name followed by a colon and the name of the subsection. The subsection name may not contain any spaces.</p>
                                    <p>A subsection can be allocated separately or grouped with other sections using the same base name. For example, you create a subsection called _func within the .text section:</p>
                                    <code>     .sect ".text:_func" </code>
                                    <p>Using the linker's SECTIONS directive, you can allocate .text:_func separately, or with all the .text sections.</p>
                                    <p>You can create two types of subsections:</p>
                                    <ul>
                                        <li value="1">Initialized subsections are created using the .sect directive. See <span class="crossreference"><a href="#STDZ0692863">Section 2.4.2</a></span>.</li>
                                        <li value="2">Uninitialized subsections are created using the .usect directive. See <span class="crossreference"><a href="#STDZ069137">Section 2.4.1</a></span>.</li>
                                    </ul>
                                    <p>Subsections are placed in the same manner as sections. See <span class="crossreference"><a href="linker-description.html#STDZ0759595">Section 8.5.5</a></span> for information on the SECTIONS directive.</p>
                                </div>
                                <div class="subsection">
                                    <h4 id="STDZ0694846">
                                        <a MadCap:generatedBookmark="TOC" name="2.4.7_Using_Sections_Directives">
                                        </a>
                                        <span class="section-label">2.4.7 </span>Using Sections Directives</h4>
                                    <p>
                                        <span class="crossreference">
                                            <a href="#STDZ069115">Figure 2-2</a>
                                        </span> shows how you can build sections incrementally, using the sections directives to swap back and forth between the different sections. You can use sections directives to begin assembling into a section for the first time, or to continue assembling into a section that already contains code. In the latter case, the assembler simply appends the new code to the code that is already in the section.</p>
                                    <p>The format in <span class="crossreference"><a href="#STDZ069115">Figure 2-2</a></span> is a listing file. <span class="crossreference"><a href="#STDZ069115">Figure 2-2</a></span> shows how the SPCs are modified during assembly. A line in a listing file has four fields:</p>
                                    <div class="subsection">
                                        <table class="tabbedtext">
                                            <colgroup>
                                                <col align="left" />
                                                <col align="left" />
                                            </colgroup>
                                            <tbody>
                                                <tr>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top"> <b>Field 1</b> <![CDATA[ ]]></td>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">contains the source code line counter.</td>
                                                </tr>
                                                <tr>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top"> <b>Field 2</b> <![CDATA[ ]]></td>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">contains the section program counter.</td>
                                                </tr>
                                                <tr>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top"> <b>Field 3</b> <![CDATA[ ]]></td>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">contains the object code.</td>
                                                </tr>
                                                <tr>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top"> <b>Field 4</b> <![CDATA[ ]]></td>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">contains the original source statement.</td>
                                                </tr>
                                            </tbody>
                                        </table>
                                    </div>
                                    <p>See <span class="crossreference"><a href="assembler-description.html#STDZ071744">Section 4.11</a></span> for more information on interpreting the fields in a source listing.</p>
                                </div>
                                <div class="figure">
                                    <span class="caption" id="STDZ069115">
                                        <span class="figure-label">Figure 2-2 </span>Using Sections Directives Example</span> <img alt="usesecdirs_lau131.gif" itemprop="image" src="ods/images/SLAU131R/usesecdirs_lau131.gif" title="Using Sections Directives&#xA;    Example" /> </div>
                                <p>As <span class="crossreference"><a href="#STDZ0692847">Figure 2-3</a></span> shows, the file in <span class="crossreference"><a href="#STDZ069115">Figure 2-2</a></span> creates five sections:</p>
                                <div class="subsection">
                                    <table class="tabbedtext">
                                        <colgroup>
                                            <col align="left" />
                                            <col align="left" />
                                        </colgroup>
                                        <tbody>
                                            <tr>
                                                <td align="left" class="noBorderRight noBorderBottom" valign="top"> <b>.text</b> <![CDATA[ ]]></td>
                                                <td align="left" class="noBorderRight noBorderBottom" valign="top">contains six 32-bit words of object code.</td>
                                            </tr>
                                            <tr>
                                                <td align="left" class="noBorderRight noBorderBottom" valign="top"> <b>.data</b> <![CDATA[ ]]></td>
                                                <td align="left" class="noBorderRight noBorderBottom" valign="top">contains seven words of initialized data.</td>
                                            </tr>
                                            <tr>
                                                <td align="left" class="noBorderRight noBorderBottom" valign="top"> <b>vectors</b> <![CDATA[ ]]></td>
                                                <td align="left" class="noBorderRight noBorderBottom" valign="top">is a user-named section created with the .sect directive; it contains one word of initialized data.</td>
                                            </tr>
                                            <tr>
                                                <td align="left" class="noBorderRight noBorderBottom" valign="top"> <b>.bss</b> <![CDATA[ ]]></td>
                                                <td align="left" class="noBorderRight noBorderBottom" valign="top">reserves 10 bytes in memory.</td>
                                            </tr>
                                            <tr>
                                                <td align="left" class="noBorderRight noBorderBottom" valign="top"> <b>newvars</b> <![CDATA[ ]]></td>
                                                <td align="left" class="noBorderRight noBorderBottom" valign="top">is a user-named section created with the .usect directive; it contains eight bytes in memory.</td>
                                            </tr>
                                        </tbody>
                                    </table>
                                </div>
                                <p>The second column shows the object code that is assembled into these sections; the first column shows the source statements that generated the object code.</p>
                                <div class="figure">
                                    <span class="caption" id="STDZ0692847">
                                        <span class="figure-label">Figure 2-3 </span>Object Code Generated by the File in <span class="crossreference"><a href="#STDZ069115">Figure 2-2</a></span> <![CDATA[ ]]></span> <img alt="objcodech2_lau131.gif" itemprop="image" src="ods/images/SLAU131R/objcodech2_lau131.gif" title="Object Code Generated by the&#xA;    File in" /> </div>
                            </div>
                            <div class="subsection">
                                <h3 id="STDZ0694245">
                                    <a MadCap:generatedBookmark="TOC" name="2.5_How_the_Linker_Handles_Sections">
                                    </a>
                                    <span class="section-label">2.5 </span>How the Linker Handles Sections</h3>
                                <p>The linker has two main functions related to sections. First, the linker uses the sections in object files as building blocks; it combines input sections to create output sections in an executable output module. Second, the linker chooses memory addresses for the output sections; this is called <i>placement</i>. Two linker directives support these functions:</p>
                                <ul>
                                    <li value="1"> The <i>MEMORY</i> directive allows you to define the memory map of a target system. You can name portions of memory and specify their starting addresses and their lengths.</li>
                                    <li value="2"> The <i>SECTIONS</i> directive tells the linker how to combine input sections into output sections and where to place these output sections in memory.</li>
                                </ul>
                                <p>Subsections let you manipulate the placement of sections with greater precision. You can specify the location of each subsection with the linker's SECTIONS directive. If you do not specify a subsection, the subsection is combined with the other sections with the same base section name. See <span class="crossreference"><a href="linker-description.html#STDZ0756353">Section 8.5.5.1</a></span>.</p>
                                <p>It is not always necessary to use linker directives. If you do not use them, the linker uses the target processor's default placement algorithm described in <span class="crossreference"><a href="linker-description.html#STDZ0752588">Section 8.7</a></span>. When you <i>do</i> use linker directives, you must specify them in a linker command file.</p>
                                <p>Refer to the following sections for more information about linker command files and linker directives:</p>
                                <ul>
                                    <li value="1">
                                        <span class="crossreference">
                                            <a href="linker-description.html#STDZ0751521">Section 8.5</a>
                                        </span>, <i>Linker Command Files</i></li>
                                    <li value="2">
                                        <span class="crossreference">
                                            <a href="linker-description.html#STDZ075888">Section 8.5.4</a>
                                        </span>, <i>The MEMORY Directive</i></li>
                                    <li value="3">
                                        <span class="crossreference">
                                            <a href="linker-description.html#STDZ0759595">Section 8.5.5</a>
                                        </span>, <i>The SECTIONS Directive</i></li>
                                    <li value="4">
                                        <span class="crossreference">
                                            <a href="linker-description.html#STDZ0752588">Section 8.7</a>
                                        </span>, <i>Default Placement Algorithm</i></li>
                                </ul>
                                <div class="subsection">
                                    <h4 id="STDZ0693403">
                                        <a MadCap:generatedBookmark="TOC" name="2.5.1_Combining_Input_Sections">
                                        </a>
                                        <span class="section-label">2.5.1 </span>Combining Input Sections</h4>
                                    <p>
                                        <span class="crossreference">
                                            <a href="#STDZ0693474">Figure 2-4</a>
                                        </span> provides a simplified example of the process of linking two files together.</p>
                                    <p>Note that this is a simplified example, so it does not show all the sections that will be created or the actual sequence of the sections. See <span class="crossreference"><a href="linker-description.html#STDZ0752588">Section 8.7</a></span> for the actual default memory placement map for <span>MSP430</span>.</p>
                                    <div class="figure">
                                        <span class="caption" id="STDZ0693474">
                                            <span class="figure-label">Figure 2-4 </span>Combining Input Sections to Form an Executable Object Module</span> <img alt="defallocate_lau131.gif" itemprop="image" src="ods/images/SLAU131R/defallocate_lau131.gif" title="Combining Input Sections to&#xA;    Form an Executable Object Module" /> </div>
                                    <p>In <span class="crossreference"><a href="#STDZ0693474">Figure 2-4</a></span>, file1.obj and file2.obj have been assembled to be used as linker input. Each contains the .text, .data, and <span>.bss</span> default sections; in addition, each contains a user-named section. The executable object module shows the combined sections. The linker combines the .text section from file1.obj and the .text section from file2.obj to form one .text section, then combines the two .data sections and the two <span>.bss</span> sections, and finally places the user-named sections at the end. The memory map shows the combined sections to be placed into memory. </p>
                                </div>
                                <div class="subsection">
                                    <h4 id="STDZ0693895">
                                        <a MadCap:generatedBookmark="TOC" name="2.5.2_Placing_Sections">
                                        </a>
                                        <span class="section-label">2.5.2 </span>Placing Sections</h4>
                                    <p>
                                        <span class="crossreference">
                                            <a href="#STDZ0693474">Figure 2-4</a>
                                        </span> illustrates the linker's default method for combining sections. Sometimes you may not want to use the default setup. For example, you may not want all of the .text sections to be combined into a single .text section. Or you may want a user-named section placed where the .data section would normally be allocated. Most memory maps contain various types of memory (RAM, ROM, EPROM, FLASH, etc.) in varying amounts; you may want to place a section in a specific type of memory.</p>
                                    <p>For further explanation of section placement within the memory map, see the discussions in <span class="crossreference"><a href="linker-description.html#STDZ075888">Section 8.5.4</a></span> and <span class="crossreference"><a href="linker-description.html#STDZ0759595">Section 8.5.5</a></span>. See <span class="crossreference"><a href="linker-description.html#STDZ0752588">Section 8.7</a></span> for the actual default memory allocation map for <span>MSP430</span>.</p>
                                </div>
                            </div>
                            <div class="subsection">
                                <h3 id="STDZ069309">
                                    <a MadCap:generatedBookmark="TOC" name="2.6_Symbols">
                                    </a>
                                    <span class="section-label">2.6 </span>Symbols</h3>
                                <p>An object file contains a symbol table that stores information about <i>external symbols</i> in the object file. The linker uses this table when it performs relocation. See <span class="crossreference"><a href="#STDZ0698484">Section 2.7</a></span>.</p>
                                <p>An object file symbol is a named 32-bit integer value, usually representing an address. A symbol can represent such things as the starting address of a function, variable, or section.</p>
                                <p>An object file symbol can also represent an absolute integer, such as the size of the stack. To the linker, this integer is an unsigned value, but the integer may be treated as signed or unsigned depending on how it is used. The range of legal values for an absolute integer is 0 to 2^32-1 for unsigned treatment and -2^31 to 2^31-1 for signed treatment. </p>
                                <p>Symbols can be bound as <i>global symbols</i>, <i>local symbols</i>, or <i>weak symbols</i>. The linker handles symbols differently based on their binding. For example, the linker does not allow multiple global definitions of a symbol, but local symbols can be defined in multiple object files (but only once per object file). The linker does not resolve references to local symbols in different object files, but it does resolve references to global symbols in any other object file.</p>
                                <p>A <i>global symbol</i> is defined in the same manner as any other symbol; that is, it appears as a label or is defined by a directive, such as .set, .equ, <span>.bss, </span>or .usect. If a global symbol is defined more than once, the linker issues a multiple-definition error. (The assembler can provide a similar multiple-definition error for local symbols.)</p>
                                <p>A <i>weak symbol</i> is a symbol that is used in the current module but is defined in another module. The linker resolves this symbol's definition at link time. Weak symbols are similar to global symbols, except that if one object file contains a weak symbol, and another object file contains a global symbol with the same name, the global symbol is used to resolve references. A weak reference may be unresolved at link time, in which case the address is treated as 0. Therefore, for weak references, application code must test to make sure &amp;var is not zero before attempting to read the contents. See <span class="crossreference"><a href="#SPRUI029023">Section 2.6.2</a></span> for more about weak symbols.</p>
                                <p> In general, common symbols (see <span class="crossreference"><a href="assembler-directives.html#IDcommondesc">.common directive</a></span>) are preferred over weak symbols.</p>
                                <p>See <span class="crossreference"><a href="assembler-description.html#STDZ071620">Section 4.8</a></span> for information about assembler symbols.</p>
                                <div class="subsection">
                                    <h4 id="STDZ0699532">
                                        <a MadCap:generatedBookmark="TOC" name="2.6.1_External_Symbols">
                                        </a>
                                        <span class="section-label">2.6.1 </span>External Symbols</h4>
                                    <p>External symbols are symbols that are visible to other object modules. Because they are visible across object modules, they may be defined in one file and referenced in another file. You can use the .def, .ref, or .global directive to identify a symbol as external:</p>
                                    <div class="subsection">
                                        <table class="tabbedtext">
                                            <colgroup>
                                                <col align="left" />
                                                <col align="left" />
                                            </colgroup>
                                            <tbody>
                                                <tr>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top"> <b>.def</b> <![CDATA[ ]]></td>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">The symbol is defined in the current file and may be used in another file.</td>
                                                </tr>
                                                <tr>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top"> <b>.ref</b> <![CDATA[ ]]></td>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">The symbol is referenced in the current file, but defined in another file.</td>
                                                </tr>
                                                <tr>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top"> <b>.global</b> <![CDATA[ ]]></td>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">The symbol can be either of the above. The assembler chooses either .def or .ref as appropriate for each symbol.</td>
                                                </tr>
                                            </tbody>
                                        </table>
                                    </div>
                                    <p>The following code fragments illustrate the use of the .global directive. </p>
                                    <code>x: ADD.W #56, R11 ; Define x
 .global x ; acts as .def x</code>
                                    <p>Because x is defined in this module, the assembler treats ".global x" as ".def x". Now other modules can refer to x.</p>
                                    <code>   JMP y ; Reference y
 .global y ; .ref of y</code>
                                    <p>Because y is not defined in this module, the assembler treats ".global y" as ".ref y". The symbol y must be defined in another module.</p>
                                    <p>Both the symbols x and y are external symbols and are placed in the object file's symbol table; x as a defined symbol, and y as an undefined symbol. When the object file is linked with other object files, the entry for x will be used to resolve references to x in other files. The entry for y causes the linker to look through the symbol tables of other files for y’s definition.</p>
                                    <p>The linker attempts to match all references with corresponding definitions. If the linker cannot find a symbol's definition, it prints an error message about the unresolved reference. This type of error prevents the linker from creating an executable object module.</p>
                                    <p>An error also occurs if the same symbol is defined more than once.</p>
                                </div>
                                <div class="subsection">
                                    <h4 id="SPRUI029023">
                                        <a MadCap:generatedBookmark="TOC" name="2.6.2_Weak_Symbols">
                                        </a>
                                        <span class="section-label">2.6.2 </span>Weak Symbols</h4>
                                    <p>The linker processes absolute symbols that are defined with "weak" binding differently from absolute symbols that are defined with global binding (the default). Instead of including a weak absolute symbol in the output file's symbol table by default (as it would for a global absolute symbol), the linker only includes a weak absolute symbol in the output of a "final" link if the symbol is required to resolve an otherwise unresolved reference.</p>
                                    <p>This weak symbol handling allows you to associate addresses with symbols known to have been pre-loaded (such as function addresses in system memory) and then link the current application against a pre-loaded memory image. If such symbols are defined as weak absolute symbols, the linker can minimize the number of symbols it includes in the output file's symbol table by omitting those that are not needed to resolve references. Reducing the size of the output file's symbol table reduces the time required to link, especially if there are a large number of pre-loaded symbols to link against. This feature is particularly helpful for OpenCL applications.</p>
                                    <p>You can define a weak absolute symbol using either assembly or the linker command file.</p>
                                    <p>
                                        <b>Using Assembly:</b> To define a weak absolute symbol in an input object file, the source file can be written in assembly. Use the .weak and .set directives in combination as shown in the following example, which defines a weak absolute symbol "ext_addr_sym": </p>
                                    <code>                .weak ext_addr_sym
ext_addr_sym .set 0x12345678</code>
                                    <p>Assemble the source file that defines weak symbols, and include the resulting object file in the link. The "ext_addr_sym" in this example is available as a weak absolute symbol in a final link. It is a candidate for removal if the symbol is not referenced elsewhere in the application. See <span class="crossreference"><a href="assembler-directives.html#IDsymdependdesc">.weak directive</a></span>.</p>
                                    <p>
                                        <b>Using the Linker Command File:</b> To define a weak symbol in a linker command file, use the "weak" operator in an assignment expression to designate that the symbol as eligible for removal from the output file's symbol table if it is not referenced. In a linker command file, an assignment expression outside a MEMORY or SECTIONS directive can be used to define a weak linker-defined absolute symbol. For example, you can define "ext_addr_sym" as follows: </p>
                                    <code>weak(ext_addr_sym) = 0x12345678;</code>
                                    <p>If the linker command file is used to perform the final link, then "ext_addr_sym" is presented to the linker as a weak absolute symbol; it will not be included in the resulting output file if the symbol is not referenced. See <span class="crossreference"><a href="linker-description.html#SPRUI023504">Section 8.6.2</a></span>.</p>
                                    <p>If there are multiple definitions of the same absolute symbol, the linker uses certain rules to determine which definition takes precedence. Some definitions may have weak binding and others may have strong binding. "Strong" in this context means that the symbol has <i>not</i> been given a weak binding by either of the two methods described above. Some definitions may come from an input object file (that is, using assembly directives) and others may come from an assignment statement in a linker command file. The linker uses the following guidelines to determine which definition is used when resolving references to a symbol:</p>
                                    <ul>
                                        <li value="1">A strongly bound symbol always takes precedence over a weakly bound symbol.</li>
                                        <li value="2">If two symbols are both strongly bound or both weakly bound, a symbol defined in a linker command file takes precedence over a symbol defined in an input object file.</li>
                                        <li value="3">If two symbols are both strongly bound and both are defined in an input object file, the linker provides a symbol redefinition error and halts the link process.</li>
                                    </ul>
                                </div>
                                <div class="subsection">
                                    <h4 id="STDZ0691177">
                                        <a MadCap:generatedBookmark="TOC" name="2.6.3_The_Symbol_Table">
                                        </a>
                                        <span class="section-label">2.6.3 </span>The Symbol Table</h4>
                                    <p>The assembler generates an entry in the symbol table for each .ref, .def, or .global directive in <span class="crossreference"><a href="#STDZ0699532">Section 2.6.1</a></span>). These are external symbols, which are visible to other object modules.</p>
                                    <p>The assembler also creates special symbols that point to the beginning of each section.</p>
                                    <p>The assembler does not usually create symbol table entries for any symbols other than those described above, because the linker does not use them. For example, labels (<span class="crossreference"><a href="assembler-description.html#STDZ0710636">Section 4.8.2</a></span>) are not included in the symbol table unless they are declared with the .global directive. For informational purposes, there are entries in the symbol table for each symbol in a program.</p>
                                </div>
                            </div>
                            <div class="subsection">
                                <h3 id="STDZ0698484">
                                    <a MadCap:generatedBookmark="TOC" name="2.7_Symbolic_Relocations">
                                    </a>
                                    <span class="section-label">2.7 </span>Symbolic Relocations</h3>
                                <p>The assembler treats each section as if it began at address 0. Of course, all sections cannot actually begin at address 0 in memory, so the linker must relocate sections. <span>Relocations are symbol-relative rather than section-relative.</span></p>
                                <p>The linker can <i>relocate</i> sections by: </p>
                                <ul>
                                    <li value="1">Allocating them into the memory map so that they begin at the appropriate address as defined with the linker's MEMORY directive</li>
                                    <li value="2">Adjusting symbol values to correspond to the new section addresses</li>
                                    <li value="3">Adjusting references to relocated symbols to reflect the adjusted symbol values</li>
                                </ul>
                                <p>The linker uses <i>relocation entries</i> to adjust references to symbol values. The assembler creates a relocation entry each time a relocatable symbol is referenced. The linker then uses these entries to patch the references after the symbols are relocated. <span><span class="crossreference"><a href="#STDZ0698378">Example 2-3</a></span> contains a code fragment for a <span>MSP430</span> device for which the assembler generates relocation entries.</span></p>
                                <div class="example">
                                    <h4 id="STDZ0698378">
                                        <a MadCap:generatedBookmark="TOC" name="Example_2-3_Code_That_Generates_Relocation_Entries">
                                        </a>
                                        <span class="example-label">Example 2-3 </span>Code That Generates Relocation Entries</h4>
                                    <code>       1 ** Generating Relocation Entries **
 2 
 3 .ref X
 4 .def Y
 5 
 6 000000 .text
 7 000000 5A0B ADD.W R10, R11
 8 000002 4B82 MOV.W R11, &amp;X
 000004 0000!
 9 000006 4030 BR #Y
 000008 000A!
 10 
 11 00000a 5B0C Y ADD.W R11, R12</code>
                                </div>
                                <p>In <span class="crossreference"><a href="#STDZ0698378">Example 2-3</a></span>, both symbols X and Y are relocatable. Y is defined in the .text section of this module; X is defined in another module. When the code is assembled, X has a value of 0 (the assembler assumes all undefined external symbols have values of 0), and Y has a value of 8. The assembler generates two relocation entries: one for X and one for Y. The reference to X is an external reference and the reference to Y is to an internally defined relocatable symbol (both are indicated by the <b>!</b> character in the listing).</p>
                                <p>After the code is linked, suppose that X is relocated to address 0x0800. Suppose also that the .text section is relocated to begin at address 0x0600; Y now has a relocated value of 0x0608. The linker uses the relocation entry for the reference to X to patch the branch instruction in the object code:</p>
                                <div class="subsection">
                                    <table class="tabbedtext">
                                        <colgroup>
                                            <col />
                                            <col />
                                            <col />
                                        </colgroup>
                                        <tbody>
                                            <tr>
                                                <td class="noBorderBottom"> <code>4B820000!</code> <![CDATA[ ]]></td>
                                                <td class="noBorderBottom">becomes</td>
                                                <td class="noBorderBottom"> <code>4B820800</code> <![CDATA[ ]]></td>
                                            </tr>
                                        </tbody>
                                    </table>
                                </div>
                                <div class="subsection">
                                    <h4 id="lit83907528">
                                        <a MadCap:generatedBookmark="TOC" name="2.7.1_Relocation_Entries">
                                        </a>
                                        <span class="section-label">2.7.1 </span>Relocation Entries </h4>
                                    <p>EABI uses ELF, in which the relocations are symbol-relative rather than section-relative. This means that the relocation in <span class="crossreference"><a href="#STDZ0698378">Example 2-3</a></span> generated for 'Y' would refer to the symbol 'Y' and resolve the value for 'Y' in the opcode based on where the definition of 'Y' ends up.</p>
                                </div>
                            </div>
                            <div class="subsection">
                                <h3 id="STDZ0698147">
                                    <a MadCap:generatedBookmark="TOC" name="2.8_Loading_a_Program">
                                    </a>
                                    <span class="section-label">2.8 </span>Loading a Program</h3>
                                <p>The linker creates an executable object file which can be loaded in several ways, depending on your execution environment. These methods include using Code Composer Studio or the hex conversion utility. For details, see <span class="crossreference"><a href="program-loading-and-running.html#SLAU1314677">Section 3.1</a></span>.</p>
                            </div>
                        </div>
                    </div>
                    <a href="abstract.html">Back to Top</a>
                    <p />
                    <a href="http://www.go-dsp.com/forms/techdoc/doc_feedback.htm?litnum=SLAU131R&amp;partnum=MSP430">Submit Documentation Feedback</a>
                    <p>Copyright© 2018, Texas Instruments Incorporated. An <a href="includes/important_notice.html">IMPORTANT NOTICE</a> for this document addresses availability, warranty, changes, use in safety-critical applications, intellectual property matters and other important disclaimers.</p>
                </div>
            </div>
        </div>
    </body>
</html>