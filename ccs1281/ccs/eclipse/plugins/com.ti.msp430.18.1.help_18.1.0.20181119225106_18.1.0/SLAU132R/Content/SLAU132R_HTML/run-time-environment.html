<?xml version="1.0" encoding="utf-8"?>
<html xmlns:MadCap="http://www.madcapsoftware.com/Schemas/MadCap.xsd" lang="en-us" xml:lang="en-us" data-mc-search-type="Stem" data-mc-help-system-file-name="index.xml" data-mc-path-to-help-system="../../" data-mc-target-type="WebHelp2" data-mc-runtime-file-type="Topic" data-mc-preload-images="false" data-mc-in-preview-mode="false" data-mc-toc-path="">
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <meta charset="utf-8" />
        <meta name="description" content="" />
        <meta name="author" content="" />
        <title>6 Run-Time Environment</title>
        <link href="../../Skins/Default/Stylesheets/Slideshow.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../Skins/Default/Stylesheets/TextEffects.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../Skins/Default/Stylesheets/Topic.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../Skins/Default/Stylesheets/Components/Styles.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../Skins/Default/Stylesheets/Components/Tablet.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../../Skins/Default/Stylesheets/Components/Mobile.css" rel="stylesheet" data-mc-generated="True" />
        <link href="../Resources/Stylesheets/headerfooter.css" rel="stylesheet" />
        <script src="../../Resources/Scripts/custom.modernizr.js">
        </script>
        <script src="../../Resources/Scripts/jquery.min.js">
        </script>
        <script src="../../Resources/Scripts/require.min.js">
        </script>
        <script src="../../Resources/Scripts/require.config.js">
        </script>
        <script src="../../Resources/Scripts/foundation.min.js">
        </script>
        <script src="../../Resources/Scripts/plugins.min.js">
        </script>
        <script src="../../Resources/Scripts/MadCapAll.js">
        </script>
    </head>
    <body>
        <div class="content">
            <div id="contentBody">
                <div class="row collapse">
                    <div class="sideContent">
                        <div class="clearfix">
                        </div>
                    </div>
                    <div id="loadContentArea">
                        <div class="c12 docHeader">
                            <div class="c4 docTitle">
                                <p>
                                    <strong>MSP430 Optimizing
							C/C++ Compiler
			v18.1.0.LTS User's Guide</strong>
                                    <br />
                                    <span id="litnumber">SLAU132R</span> - REVISED JANUARY 2018</p>
                            </div>
                        </div>
                    </div>
                    <div class="odsHeader">
                        <p class="pdf">
                            <a class="downloadPDF" href="http://www.ti.com/litv/SLAU132R" target="_new">Download PDF</a>
                        </p>
                    </div>
                    <div id="loadContentArea1">
                        <div class="subsection">
                            <h2 id="STDZ0540879">
                                <a MadCap:generatedBookmark="TOC" name="6_Run-Time_Environment">
                                </a>
                                <span class="section-label">6 </span>Run-Time Environment</h2>
                            <div class="subsection">
                                <p>This chapter describes the <span>MSP430</span> C/C++ run-time environment. To ensure successful execution of C/C++ programs, it is critical that all run-time code maintain this environment. It is also important to follow the guidelines in this chapter if you write assembly language functions that interface with C/C++ code.</p>
                            </div>
                            <div class="subsection">
                                <h3 id="STDZ0542968">
                                    <a MadCap:generatedBookmark="TOC" name="6.1_Memory_Model">
                                    </a>
                                    <span class="section-label">6.1 </span>Memory<span> Model</span></h3>
                                <p>The MSP430 compiler treats memory as a single linear block that is partitioned into subblocks of code and data. Each subblock of code or data generated by a C program is placed in its own continuous memory space. The compiler assumes that the full 16-bit (for MSP430) or 20-bit (for MSP430X) address space is available in target memory.</p>
                                <div class="subsection">
                                    <h4 id="SLAU1324204">
                                        <a MadCap:generatedBookmark="TOC" name="6.1.1_Code_Memory_Models">
                                        </a>
                                        <span class="section-label">6.1.1 </span>Code Memory Models</h4>
                                    <p>The MSP430 compiler supports two different code memory models, small and large, which are controlled by the --code_model option.</p>
                                    <ul>
                                        <li value="1">The small code model uses 16-bit function pointers and requires all code and all text sections to be placed in the low 64K of memory. This is the only valid code model for 16-bit MSP430 devices.</li>
                                        <li value="2">The large code model provides a 1 MB address space for code and uses 20-bit function pointers. It is the default for MSP430X devices, including the MSP430F5xxx and MSP430F6xxx families. Interrupt service routines must still be placed in the low 64 KB of memory (see <span class="crossreference"><a href="#STDZ0544970">Section 6.7.5</a></span>).</li>
                                    </ul>
                                    <p>The small code model is slightly more efficient in terms of run-time performance and memory usage when compared to the large code model. Therefore, it is beneficial to use the small code model when all code and text sections will fit in the low 64K of memory. Modules assembled/compiled using the small-code model are not compatible with modules that are assembled/compiled using large-code model. The linker generates an error if any attempt is made to combine object files that use different code memory models. An appropriate run-time library must be used as well. </p>
                                </div>
                                <div class="subsection">
                                    <h4 id="SLAU1324550">
                                        <a MadCap:generatedBookmark="TOC" name="6.1.2_Data_Memory_Models">
                                        </a>
                                        <span class="section-label">6.1.2 </span>Data Memory Models</h4>
                                    <p>The MSP430 compiler supports three different data memory models: small, restricted and large. The data model used is controlled by the --data_model option. The 16-bit MSP430 devices always use the small data memory model. The 20-bit MSP430X devices can use any data memory model and use the small data model by default.</p>
                                    <ul>
                                        <li value="1">The small data model requires that all data sections be located in the low 64K of memory. Data pointers are 16-bits in size. This is the most efficient data model in terms of performance and application size. </li>
                                        <li value="2">The restricted data model allows data to be located throughout the entire 1MB address space available on MSP430X devices with only a minimal efficiency penalty over the small data model. It is restricted because individual objects (structures, arrays, etc.) cannot be larger than 64K in size. Data pointers are 32-bits in size. </li>
                                        <li value="3">The large data model also allows data to be located throughout the entire 1MB address space and also places no restriction on the maximum size of an individual object. Permitting individual objects to be greater than 64K in size causes code generated for the large data model to be less efficient than code generated for the restricted data model.</li>
                                    </ul>
                                    <p>Data memory is also affected by the --near_data option as described in <span class="crossreference"><a href="#SLAU132577">Section 6.1.3</a></span>.</p>
                                    <p>The maximum size of an object (size_t) and the maximum difference between two pointers (ptrdiff_t) are increased from 16-bits to 32-bits in the large data model. Applications that rely on size_t or ptrdiff_t to be a specific size may need to be updated. </p>
                                    <p>Object files built with different data models are not compatible. All files in an application must be built with the same data model. Additionally, a run-time-support library matching that data model must be used. When using automatic library selection (the default), the linker will automatically select the correct library <span class="crossreference"><a href="linking-c-c-code.html#STDZ0564809">Section 4.3.1.1</a></span>. If you select the library manually, you must select the matching library according to <span class="crossreference"><a href="using-run-time-support-functions-and-building-libraries.html#STDZ0535426">Section 7.1.8</a></span>. </p>
                                </div>
                                <div class="subsection">
                                    <h4 id="SLAU132577">
                                        <a MadCap:generatedBookmark="TOC" name="6.1.3_Support_for_Near_Data">
                                        </a>
                                        <span class="section-label">6.1.3 </span>Support for Near Data</h4>
                                    <p>Most MSP430X devices do not have any writeable memory above the 64K boundary. However, most FRAM MSP430x devices and a few non-FRAM devices have writeable memory above 64k boundary. </p>
                                    <p>For those few non-FRAM devices with high RAM (above 64K), non-constant data may be placed above the 64K boundary by the linker command file.</p>
                                    <p>For all other devices, which have no writeable memory above the 64K boundary even when the restricted or large data models are used, only constant data will be placed above 64K. The compiler can take advantage of this knowledge to produce more efficient code. The --near_data option controls this optimization. </p>
                                    <p>When --near_data=globals is specified, this option tells the compiler that all global read/write data must be located in the first 64K of memory. This is the default behavior. Global read/write data is placed by default in the .bss and .data sections.</p>
                                    <p>If --near_data=none is specified, this option tells the compiler that it cannot rely on this assumption to generate more efficient code. </p>
                                </div>
                                <span class="note">
                                    <p class="note_title">NOTE</p>
                                    <b>The Linker Defines the Memory Map</b>
                                    <p>The linker, not the compiler, defines the memory map and allocates code and data into target memory. The compiler assumes nothing about the types of memory available, about any locations not available for code or data (holes), or about any locations reserved for I/O or control purposes. The compiler produces relocatable code that allows the linker to allocate code and data into the appropriate memory spaces. For example, you can use the linker to allocate global variables into on-chip RAM or to allocate executable code into external ROM. You can allocate each block of code or data individually into memory, but this is not a general practice (an exception to this is memory-mapped I/O, although you can access physical memory locations with C/C++ pointer types).</p>
                                </span>
                                <div class="subsection">
                                    <h4 id="STDZ0542969">
                                        <a MadCap:generatedBookmark="TOC" name="6.1.4_Sections">
                                        </a>
                                        <span class="section-label">6.1.4 </span>Sections</h4>
                                    <p>The compiler produces relocatable blocks of code and data called <i>sections</i>. The sections are allocated into memory in a variety of ways to conform to a variety of system configurations. For more information about sections and allocating them, see the introductory object file information in the <i> <span>MSP430 </span>Assembly Language Tools User's Guide</i>.</p>
                                    <p>There are two basic types of sections:</p>
                                    <ul>
                                        <li value="1">
                                            <b>Initialized sections</b> contain data or executable code. Initialized sections are usually, but not always, read-only. The C/C++ compiler creates the following initialized sections: <ul><li value="1">The <b>.binit section </b> contains boot time copy tables. This is a read-only section. For details on BINIT, see the <i><span>MSP430 </span> Assembly Language Tools User's Guide</i> for linker command file information. </li><li value="2">The <b>.cinit section</b> contains tables for initializing variables and constants. This is a read-only section. The compiler does not create this section; instead, the linker does.</li><li value="3">The <b>.init_array section</b> contains the table of pointers to initialization routines for global C++ objects. </li><li id="t365164-2" value="4">The <b>.ovly section </b> contains copy tables other than boot time (.binit) copy tables. This is a read-only section.</li><li value="5">The <b>.data section</b> contains initialized global and static variables.</li><li value="6">For EABI only, the <b>.mspabi.exidx section</b> contains the index table for exception handling. The <b>.mspabi.extab section</b> contains unwinding instructions for exception handling. These sections are read-only. See the --exceptions option for details. </li><li value="7">The <b>.const section</b> contains string constants, string literals, switch tables, and data defined with the C/C++ qualifier <i>const</i> (provided the constant is not also defined as <i>volatile</i> or one of the exceptions described in <span class="crossreference"><a href="msp430-c-c-language-implementation.html#STDZ0558110">Section 5.7.1</a></span>). This is a read-only section. String literals are placed in the .const:.string subsection to enable greater link-time placement control.</li><li value="8">The<b> .text section</b> contains all the executable code and compiler-generated constants. This section is usually read-only.</li><li value="9">The <b>.TI.crctab section </b> contains CRC checking tables. This is a read-only section.</li></ul></li>
                                        <li value="2">
                                            <b>Uninitialized sections</b> reserve space in memory (usually RAM). A program can use this space at run time to create and store variables. The compiler creates the following uninitialized sections: <ul><li value="1">The <b>.bss section</b> reserves space for global and static variables. At boot or load time, the C/C++ boot routine or the loader copies data out of the .cinit section (which can be in ROM) and stores it in the .bss section. </li><li value="2">For EABI only, the <b>.bss section</b> reserves space for uninitialized global and static variables. Uninitialized variables that are also unused are usually created as common symbols (unless you specify --common=off) instead of being placed in .bss so that they can be excluded from the resulting application.</li><li value="3">The <b>.stack section</b> reserves memory for the <span>C/C++ software stack.</span></li><li value="4">The <b>.sysmem section</b> reserves space for dynamic memory allocation. The reserved space is used by dynamic memory allocation routines, such as malloc, calloc, realloc, or new. If a C/C++ program does not use these functions, the compiler does not create the .sysmem section.</li></ul></li>
                                    </ul>
                                    <p>The assembler creates the default sections .text, <span>.bss</span>, and .data. You can instruct the compiler to create additional sections by using the CODE_SECTION and DATA_SECTION pragmas (see <span class="crossreference"><a href="msp430-c-c-language-implementation.html#STDZ0557271">Section 5.11.6</a></span> and <span class="crossreference"><a href="msp430-c-c-language-implementation.html#STDZ0559962">Section 5.11.8</a></span>).</p>
                                    <p>The linker takes the individual sections from different object files and combines sections that have the same name. The resulting output sections and the appropriate placement in memory for each section are listed in <span class="crossreference"><a href="#STDZ0548824">Table 6-1</a></span>. You can place these output sections anywhere in the address space as needed to meet system requirements. </p>
                                    <div class="subsection">
                                        <p class="table" id="STDZ0548824">
                                            <span class="table-label">Table 6-1 </span>Summary of Sections and Memory Placement </p>
                                        <table class="gentable">
                                            <colgroup>
                                                <col />
                                                <col />
                                                <col />
                                                <col />
                                            </colgroup>
                                            <thead class="tbl_hdr_gray">
                                                <tr>
                                                    <th>Section</th>
                                                    <th>Type of Memory</th>
                                                    <th>Section</th>
                                                    <th>Type of Memory</th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                <tr>
                                                    <td>.bss</td>
                                                    <td>RAM</td>
                                                    <td>.pinit or .init_array</td>
                                                    <td>ROM or RAM</td>
                                                </tr>
                                                <tr>
                                                    <td>.cinit</td>
                                                    <td>ROM or RAM</td>
                                                    <td>.stack</td>
                                                    <td>RAM</td>
                                                </tr>
                                                <tr>
                                                    <td>.const</td>
                                                    <td>ROM or RAM</td>
                                                    <td>.sysmem</td>
                                                    <td>RAM</td>
                                                </tr>
                                                <tr>
                                                    <td>.data</td>
                                                    <td>RAM</td>
                                                    <td>.text</td>
                                                    <td>ROM or RAM</td>
                                                </tr>
                                            </tbody>
                                        </table>
                                    </div>
                                    <p>You can use the SECTIONS directive in the linker command file to customize the section-allocation process. For more information about allocating sections into memory, see the linker description chapter in the <i>MSP430 Assembly Language Tools User's Guide</i>.</p>
                                </div>
                                <div class="subsection">
                                    <h4 id="STDZ0542698">
                                        <a MadCap:generatedBookmark="TOC" name="6.1.5_C_C++_Software_Stack">
                                        </a>
                                        <span class="section-label">6.1.5 </span>C/C++ <span>Software </span>Stack</h4>
                                    <p> The C/C++ compiler uses a <span>function frame </span>stack to:</p>
                                    <ul>
                                        <li value="1">Allocate local variables</li>
                                        <li value="2">Pass arguments to functions</li>
                                        <li value="3">Save register contents</li>
                                    </ul>
                                    <p>The run-time stack grows from the high addresses to the low addresses. The compiler uses the R1 register to manage this stack. R1 is the <i>stack pointer</i> (SP), which points to the next unused location on the stack.</p>
                                    <p>The linker sets the stack size, creates a global symbol, __TI_STACK_SIZE, and assigns it a value equal to the stack size in bytes. The default stack size is 80 bytes. You can change the stack size at link time by using the --stack_size option with the linker command. For more information on the --stack_size option, see the linker description chapter in the <i>MSP430 Assembly Language Tools User's Guide</i>.</p>
                                    <span class="note">
                                        <p class="note_title">NOTE</p>
                                        <b>Save-On-Entry Registers and C/C+ Stack Size</b>
                                        <p>Since register sizes increase for MSP430X devices (specified with --silicon_version=mspx), saving and restoring save-on-entry registers requires 32-bits of stack space for each register saved on the stack. When you are porting code originally written for 16-bit MSP430 devices, you may need to increase the C stack size from previous values.</p>
                                    </span>
                                    <p>At system initialization, SP is set to a designated address for the top of the stack. This address is the first location past the end of the .stack section. Since the position of the stack depends on where the .stack section is allocated, the actual address of the stack is determined at link time. </p>
                                    <p> The C/C++ environment automatically decrements SP at the entry to a function to reserve all the space necessary for the execution of that function. The stack pointer is incremented at the exit of the function to restore the stack to the state before the function was entered. If you interface assembly language routines to C/C++ programs, be sure to restore the stack pointer to the same state it was in before the function was entered. </p>
                                    <p>For more information about using the stack pointer, see <span class="crossreference"><a href="#STDZ0543031">Section 6.3</a></span>; for more information about the stack, see <span class="crossreference"><a href="#STDZ0545494">Section 6.4</a></span>.</p>
                                    <span class="note">
                                        <p class="note_title">NOTE</p>
                                        <b>Stack Overflow</b>
                                        <p>The compiler provides no means to check for stack overflow during compilation or at run time. A stack overflow disrupts the run-time environment, causing your program to fail. Be sure to allow enough space for the stack to grow. You can use the --entry_hook option to add code to the beginning of each function to check for stack overflow; see <span class="crossreference"><a href="using-the-c-c-compiler.html#STDZ0589656">Section 2.14</a></span>.</p>
                                    </span>
                                </div>
                                <div class="subsection">
                                    <h4 id="STDZ0546264">
                                        <a MadCap:generatedBookmark="TOC" name="6.1.6_Dynamic_Memory_Allocation">
                                        </a>
                                        <span class="section-label">6.1.6 </span>Dynamic Memory Allocation</h4>
                                    <p>The run-time-support library supplied with the <span>MSP430</span> compiler contains several functions (such as malloc, calloc, and realloc) that allow you to allocate memory dynamically for variables at run time. </p>
                                    <p>Memory is allocated from a global pool, or heap, that is defined in the <span>.sysmem</span> section. You can set the size of the <span>.sysmem</span> section by using the --heap_size=<i>size</i> option with the linker command. The linker also creates a global symbol, <span>__SYSMEM_SIZE</span>, and assigns it a value equal to the size of the heap in <span>bytes. </span>The default size is <span>128 bytes.</span> For more information on the --heap_size option, see the linker description chapter in the <i> <span>MSP430 </span>Assembly Language Tools User's Guide</i>.</p>
                                    <p>If you use any C I/O function, the RTS library allocates an I/O buffer for each file you access. This buffer will be a bit larger than BUFSIZ, which is defined in stdio.h and defaults to 256. Make sure you allocate a heap large enough for these buffers or use setvbuf to change the buffer to a statically-allocated buffer.</p>
                                    <p>Dynamically allocated objects are not addressed directly (they are always accessed with pointers) and the memory pool is in a separate section (<span>.sysmem</span>); therefore, the dynamic memory pool can have a size limited only by the amount of available memory in your system. To conserve space in the <span>.bss</span> section, you can allocate large arrays from the heap instead of defining them as global or static. For example, instead of a definition such as:</p>
                                    <code>struct big table[100];</code>
                                    <p>Use a pointer and call the malloc function:</p>
                                    <code>struct big *table
table = (struct big *)malloc(100*sizeof(struct big));</code>
                                    <p>When allocating from a heap, make sure the size of the heap is large enough for the allocation. This is particularly important when allocating variable-length arrays. </p>
                                </div>
                            </div>
                            <div class="subsection">
                                <h3 id="STDZ0547878">
                                    <a MadCap:generatedBookmark="TOC" name="6.2_Object_Representation">
                                    </a>
                                    <span class="section-label">6.2 </span>Object Representation</h3>
                                <p>For general information about data types, see <span class="crossreference"><a href="msp430-c-c-language-implementation.html#STDZ0555922">Section 5.6</a></span>. This section explains how various data objects are sized, aligned, and accessed.</p>
                                <div class="subsection">
                                    <h4 id="STDZ0549127">
                                        <a MadCap:generatedBookmark="TOC" name="6.2.1_Data_Type_Storage">
                                        </a>
                                        <span class="section-label">6.2.1 </span>Data Type Storage</h4>
                                    <p>
                                        <span class="crossreference">
                                            <a href="#STDZ0546567">Table 6-2</a>
                                        </span> lists register and memory storage for various data types: </p>
                                    <div class="subsection">
                                        <p class="table" id="STDZ0546567">
                                            <span class="table-label">Table 6-2 </span>Data Representation in Registers and Memory  </p>
                                        <table class="gentable">
                                            <colgroup>
                                                <col />
                                                <col />
                                                <col />
                                            </colgroup>
                                            <thead class="tbl_hdr_gray">
                                                <tr>
                                                    <th align="left" class="noBorderRight" valign="bottom">Data Type</th>
                                                    <th align="left" class="noBorderRight" valign="bottom">Register Storage</th>
                                                    <th align="left" class="noBorderRight" valign="bottom">Memory Storage</th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                <tr>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">char</td>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">Bits 0-7 of register</td>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">8 bits aligned to 8-bit boundary</td>
                                                </tr>
                                                <tr>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">unsigned char</td>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">Bits 0-7 of register</td>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">8 bits aligned to 8-bit boundary</td>
                                                </tr>
                                                <tr>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">short</td>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">Bits 0-15 of register</td>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">16 bits aligned to 16-bit boundary</td>
                                                </tr>
                                                <tr>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">unsigned short</td>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">Bits 0-15 of register</td>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">16 bits aligned to 16-bit boundary</td>
                                                </tr>
                                                <tr>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">int</td>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">Entire register</td>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">16 bits aligned to 16-bit boundary</td>
                                                </tr>
                                                <tr>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">unsigned int</td>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">Entire register</td>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">16 bits aligned to 16-bit boundary</td>
                                                </tr>
                                                <tr>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">enum <sup><a class="crossreference" href="#STDZ0543657">(1)</a></sup></td>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">Entire register</td>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">16 bits aligned to 16-bit boundary</td>
                                                </tr>
                                                <tr>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">float </td>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">Two registers, which need not be adjacent</td>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">32 bits aligned to 16-bit boundary</td>
                                                </tr>
                                                <tr>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">long</td>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">Two registers, which need not be adjacent</td>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">32 bits aligned to 16-bit boundary</td>
                                                </tr>
                                                <tr>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">unsigned long</td>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">Two registers, which need not be adjacent</td>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">32 bits aligned to 16-bit boundary</td>
                                                </tr>
                                                <tr>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">long long</td>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">Four registers, which need not be adjacent</td>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">64 bits aligned to 16-bit boundary</td>
                                                </tr>
                                                <tr>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">unsigned long long</td>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">Four registers, which need not be adjacent</td>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">64 bits aligned to 16-bit boundary</td>
                                                </tr>
                                                <tr>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">double</td>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">Four registers, which need not be adjacent</td>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">64 bits aligned to 16-bit boundary</td>
                                                </tr>
                                                <tr>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">long double </td>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">Four registers, which need not be adjacent</td>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">64 bits aligned to 16-bit boundary</td>
                                                </tr>
                                                <tr>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">struct</td>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">Members are stored as their individual types require.</td>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">Multiple of 8 bits aligned to boundary of largest member type; members are stored and aligned as their individual types require.</td>
                                                </tr>
                                                <tr>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">array</td>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">Members are stored as their individual types require.</td>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">Members are stored as their individual types require. All arrays inside a structure are aligned according to the type of each element in the array.</td>
                                                </tr>
                                                <tr>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">pointer to data member</td>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">Bits 0-15 of register for MSP430. Bits 0-19 of register for MSP430X. </td>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">varies, see <span class="crossreference"><a href="msp430-c-c-language-implementation.html#SLAU1326246">Table 5-2</a></span></td>
                                                </tr>
                                                <tr>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">pointer to member function</td>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">Components stored as their individual types require</td>
                                                    <td align="left" class="noBorderRight noBorderBottom" valign="top">64 bits aligned to 32-bit boundary</td>
                                                </tr>
                                            </tbody>
                                        </table>
                                        <div class="tablenote" id="STDZ0543657">
                                            <span class="section-label">(1) </span>The size of an enum varies by the size of the largest enum value and by whether it is packed or not. For details about the size of an enum type, see <span class="crossreference"><a href="msp430-c-c-language-implementation.html#SPRU1876797">Section 5.6.1</a></span>.</div>
                                    </div>
                                    <div class="subsection">
                                        <h4 id="STDZ054936">
                                            <a MadCap:generatedBookmark="TOC" name="6.2.1.1_Pointer_to_Member_Function_Types">
                                            </a>
                                            <span class="section-label">6.2.1.1 </span>Pointer to Member Function Types</h4>
                                        <p>Pointer to member function objects are stored as a structure with three members, and the layout is equivalent to: </p>
                                        <code>struct {
 short int d;
 short int i;
 union {
 void (f) ();
 long 0; 
 }
};</code>
                                        <p>The parameter d is the offset added to the beginning of the class object for this pointer. The parameter I is the index into the virtual function table, offset by 1. The index enables the NULL pointer to be represented. Its value is -1 if the function is nonvirtual. The parameter f is the pointer to the member function if it is nonvirtual, when I is 0. The 0 is the offset to the virtual function pointer within the class object.</p>
                                    </div>
                                    <div class="subsection">
                                        <h4 id="STDZ0547744">
                                            <a MadCap:generatedBookmark="TOC" name="6.2.1.2_Structure_and_Array_Alignment">
                                            </a>
                                            <span class="section-label">6.2.1.2 </span>Structure and Array Alignment</h4>
                                        <p>Structures are aligned according to the member with the most restrictive alignment requirement. Structures do not contain padding after the last member. Elements of arrays are stored in the same manner as if they were individual objects.</p>
                                        <p>The minimum alignment for arrays is that required by the type of its elements.</p>
                                    </div>
                                    <div class="subsection">
                                        <h4 id="STDZ0548057">
                                            <a MadCap:generatedBookmark="TOC" name="6.2.1.3_Field_Structure_Alignment">
                                            </a>
                                            <span class="section-label">6.2.1.3 </span>Field/Structure Alignment</h4>
                                        <p>When the compiler allocates space for a structure, it allocates as many words as are needed to hold all of the structure's members and to comply with alignment constraints for each member.</p>
                                        <p>When a structure contains a 32-bit (long) member, the long is aligned to a 1-word (16-bit) boundary. This may require padding before, inside, or at the end of the structure to ensure that the long is aligned accordingly and that the sizeof value for the structure is an even value.</p>
                                        <p>All non-field types are aligned on word or byte boundaries. Fields are allocated as many bits as requested. Adjacent fields are packed into adjacent bits of a word, but they do not overlap words. If a field would overlap into the next word, the entire field is placed into the next word. </p>
                                        <p>Fields are packed as they are encountered; the least significant bits of the structure word are filled first. <span class="crossreference"><a href="#SLAU1328043">Example 6-1</a></span> shows the C code definition of var while <span class="crossreference"><a href="#SLAU1327105">Figure 6-1</a></span> shows the memory layout of var. </p>
                                    </div>
                                    <div class="example">
                                        <h4 id="SLAU1328043">
                                            <a MadCap:generatedBookmark="TOC" name="Example_6-1_C_Code_Definition_of_var">
                                            </a>
                                            <span class="example-label">Example 6-1 </span>C Code Definition of var</h4>
                                        <code>struct example { char c; long l; int bf1:1; int bf2:2; int bf3:3; int bf4:4; int bf5:5; int bf6:6; };</code>
                                    </div>
                                    <div class="figure">
                                        <span class="caption" id="SLAU1327105">
                                            <span class="figure-label">Figure 6-1 </span>Memory Layout of var</span>
                                        <img alt="memlayvar_lau132.gif" itemprop="image" src="ods/images/SLAU132R/memlayvar_lau132.gif" title="Memory Layout of var" /> </div>
                                </div>
                                <div class="subsection">
                                    <h4 id="STDZ0540895_43">
                                        <a MadCap:generatedBookmark="TOC" name="6.2.2_Character_String_Constants">
                                        </a>
                                        <span class="section-label">6.2.2 </span>Character String Constants</h4>
                                    <p>In C, a character string constant is used in one of the following ways:</p>
                                    <ul>
                                        <li value="1">To initialize an array of characters. For example:</li>
                                        <code>   char s[] = "abc";</code>
                                        <p>When a string is used as an initializer, it is simply treated as an initialized array; each character is a separate initializer. For more information about initialization, see <span class="crossreference"><a href="#STDZ0543503">Section 6.9</a></span>.</p>
                                        <li value="2">In an expression. For example:</li>
                                        <code>   strcpy (s, "abc");</code>
                                        <p>When a string is used in an expression, the string itself is defined in the .const section with the .string assembler directive, along with a unique label that points to the string; the terminating 0 byte is included. For example, the following lines define the string abc, and the terminating 0 byte (the label SL5 points to the string):</p>
                                        <code>        .sect ".const" SL5: .string "abc",0</code>
                                        <p>String labels have the form SL<i>n</i>, where <i>n</i> is a number assigned by the compiler to make the label unique. The number begins at 0 and is increased by 1 for each string defined. All strings used in a source module are defined at the end of the compiled assembly language module.</p>
                                        <p>The label SL<i>n</i> represents the address of the string constant. The compiler uses this label to reference the string expression.</p>
                                        <p>Because strings are stored in the .const section (possibly in ROM) and shared, it is bad practice for a program to modify a string constant. The following code is an example of incorrect string use:</p>
                                        <code>   const char *a = "abc" a[1] = 'x'; /* Incorrect! undefined behavior */</code>
                                    </ul>
                                </div>
                            </div>
                            <div class="subsection">
                                <h3 id="STDZ0543031">
                                    <a MadCap:generatedBookmark="TOC" name="6.3_Register_Conventions">
                                    </a>
                                    <span class="section-label">6.3 </span>Register Conventions</h3>
                                <p>Strict conventions associate specific registers with specific operations in the C/C++ environment. If you plan to interface an assembly language routine to a C/C++ program, you must understand and follow these register conventions.</p>
                                <p>The register conventions dictate how the compiler uses registers and how values are preserved across function calls. <span class="crossreference"><a href="#SLAU1329018">Table 6-3</a></span> shows the types of registers affected by these conventions. <span class="crossreference"><a href="#IDregisterusage">Table 6-4</a></span> summarizes how the compiler uses registers and whether their values are preserved across calls. For information about how values are preserved across calls, see <span class="crossreference"><a href="#STDZ0545494">Section 6.4</a></span>.</p>
                                <div class="subsection">
                                    <p class="table" id="SLAU1329018">
                                        <span class="table-label">Table 6-3 </span>How Register Types Are Affected by the Conventions </p>
                                    <table class="gentable">
                                        <colgroup>
                                            <col align="left" />
                                            <col align="left" />
                                        </colgroup>
                                        <thead class="tbl_hdr_gray">
                                            <tr>
                                                <th>Register Type</th>
                                                <th>Description</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            <tr>
                                                <td>Argument register</td>
                                                <td>Passes arguments during a function call</td>
                                            </tr>
                                            <tr>
                                                <td>Return register</td>
                                                <td>Holds the return value from a function call</td>
                                            </tr>
                                            <tr>
                                                <td>Expression register</td>
                                                <td>Holds a value</td>
                                            </tr>
                                            <tr>
                                                <td>Argument pointer</td>
                                                <td>Used as a base value from which a function's parameters (incoming arguments) are accessed</td>
                                            </tr>
                                            <tr>
                                                <td>Stack pointer</td>
                                                <td>Holds the address of the top of the software stack</td>
                                            </tr>
                                            <tr>
                                                <td>Program counter</td>
                                                <td>Contains the current address of code being executed</td>
                                            </tr>
                                        </tbody>
                                    </table>
                                </div>
                                <div class="subsection">
                                    <p class="table" id="IDregisterusage">
                                        <span class="table-label">Table 6-4 </span>Register Usage and Preservation Conventions </p>
                                    <table class="gentable">
                                        <colgroup>
                                            <col />
                                            <col />
                                            <col />
                                            <col />
                                        </colgroup>
                                        <thead class="tbl_hdr_gray">
                                            <tr>
                                                <th>Register</th>
                                                <th>Alias</th>
                                                <th>Usage</th>
                                                <th>Preserved by Function<sup><a class="crossreference" href="#SLAU1323582">(1)</a></sup> <![CDATA[ ]]></th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            <tr>
                                                <td>R0</td>
                                                <td>PC</td>
                                                <td>Program counter</td>
                                                <td>N/A</td>
                                            </tr>
                                            <tr>
                                                <td>R1</td>
                                                <td>SP</td>
                                                <td>Stack pointer</td>
                                                <td>N/A<sup><a class="crossreference" href="#SLAU1323890">(2)</a></sup> <![CDATA[ ]]></td>
                                            </tr>
                                            <tr>
                                                <td>R2</td>
                                                <td>SR</td>
                                                <td>Status register</td>
                                                <td>N/A</td>
                                            </tr>
                                            <tr>
                                                <td>R3</td>
                                                <td />
                                                <td>Constant generator</td>
                                                <td>N/A</td>
                                            </tr>
                                            <tr>
                                                <td>R4-R10</td>
                                                <td />
                                                <td>Expression register</td>
                                                <td>Child</td>
                                            </tr>
                                            <tr>
                                                <td>R11</td>
                                                <td />
                                                <td>Expression register</td>
                                                <td>Parent</td>
                                            </tr>
                                            <tr>
                                                <td>R12</td>
                                                <td />
                                                <td>Expression register, argument pointer, return register</td>
                                                <td>Parent</td>
                                            </tr>
                                            <tr>
                                                <td>R13</td>
                                                <td />
                                                <td>Expression register, argument pointer, return register</td>
                                                <td>Parent</td>
                                            </tr>
                                            <tr>
                                                <td>R14</td>
                                                <td />
                                                <td>Expression register, argument pointer, return register</td>
                                                <td>Parent</td>
                                            </tr>
                                            <tr>
                                                <td>R15</td>
                                                <td />
                                                <td>Expression register, argument pointer, return register</td>
                                                <td>Parent</td>
                                            </tr>
                                        </tbody>
                                    </table>
                                    <div class="tablenote" id="SLAU1323582">
                                        <span class="section-label">(1) </span>The parent function refers to the function making the function call. The child function refers to the function being called.</div>
                                    <div class="tablenote" id="SLAU1323890">
                                        <span class="section-label">(2) </span>The SP is preserved by the convention that everything pushed on the stack is popped off before returning.</div>
                                </div>
                            </div>
                            <div class="subsection">
                                <h3 id="STDZ0545494">
                                    <a MadCap:generatedBookmark="TOC" name="6.4_Function_Structure_and_Calling_Conventions">
                                    </a>
                                    <span class="section-label">6.4 </span>Function Structure and Calling Conventions</h3>
                                <p>The C/C++ compiler imposes a strict set of rules on function calls. Except for special run-time support functions, any function that calls or is called by a C/C++ function must follow these rules. Failure to adhere to these rules can disrupt the C/C++ environment and cause a program to fail.</p>
                                <p>The following sections use this terminology to describe the function-calling conventions of the C/C++ compiler:</p>
                                <ul>
                                    <li value="1">
                                        <b>Argument block</b>. The part of the local frame used to pass arguments to other functions. Arguments are passed to a function by moving them into the argument block rather than pushing them on the stack. The local frame and argument block are allocated at the same time. </li>
                                    <li value="2">
                                        <b>Register save area</b>. The part of the local frame that is used to save the registers when the program calls the function and restore them when the program exits the function.</li>
                                    <li value="3">
                                        <b>Save-on-call registers</b>. Registers R11-R15. The called function does not preserve the values in these registers; therefore, the calling function must save them if their values need to be preserved.</li>
                                    <li value="4">
                                        <b>Save-on-entry registers</b>. Registers R4-R10. It is the called function's responsibility to preserve the values in these registers. If the called function modifies these registers, it saves them when it gains control and preserves them when it returns control to the calling function.</li>
                                </ul>
                                <p>
                                    <span class="crossreference">
                                        <a href="#STDZ0546986">Figure 6-2</a>
                                    </span> illustrates a typical function call. In this example, arguments are passed to the function, and the function uses local variables and calls another function. The first four arguments are passed to registers R12-R15. This example also shows allocation of a local frame and argument block for the called function. Functions that have no local variables and do not require an argument block do not allocate a local frame.</p>
                                <div class="figure">
                                    <span class="caption" id="STDZ0546986">
                                        <span class="figure-label">Figure 6-2 </span>Use of the Stack During a Function Call</span>
                                    <img alt="stack_func_lau132.gif" itemprop="image" src="ods/images/SLAU132R/stack_func_lau132.gif" title="Use of the Stack During a Function&#xA;    Call" /> </div>
                                <div class="subsection">
                                    <h4 id="STDZ0547291">
                                        <a MadCap:generatedBookmark="TOC" name="6.4.1_How_a_Function_Makes_a_Call">
                                        </a>
                                        <span class="section-label">6.4.1 </span>How a Function Makes a Call</h4>
                                    <p>A function (parent function) performs the following tasks when it calls another function (child function). </p>
                                    <ol>
                                        <li value="1">The calling function (parent) is responsible for preserving any save-on-call registers across the call that are live across the call. (The save-on-call registers are R11-R15.) </li>
                                        <li id="STDZ0543564" value="2">If the called function (child) returns a structure, the caller allocates space for the structure and passes the address of that space to the called function as the first argument.</li>
                                        <li value="3">The caller places the first arguments in registers R12-R15, in that order. The caller moves the remaining arguments to the argument block in reverse order, placing the leftmost remaining argument at the lowest address. Thus, the leftmost remaining argument is placed at the top of the stack. An argument with a type larger than 16 bits that would start in a save-on-call register may be split between R15 and the stack. </li>
                                        <li value="4">The caller calls the function.</li>
                                        <p>Functions defined in C++ that must be called in asm must be defined extern "C", and functions defined in asm that must be called in C++ must be prototyped extern "C" in the C++ file.</p>
                                    </ol>
                                </div>
                                <div class="subsection">
                                    <h4 id="STDZ0541257">
                                        <a MadCap:generatedBookmark="TOC" name="6.4.2_How_a_Called_Function_Responds">
                                        </a>
                                        <span class="section-label">6.4.2 </span>How a Called Function Responds</h4>
                                    <p>A called function (child function) must perform the following tasks: </p>
                                    <ol>
                                        <li value="1">If the function is declared with an ellipsis, it can be called with a variable number of arguments. The called function pushes these arguments on the stack if they meet both of these criteria:<ul><li value="1">The argument includes or follows the last explicitly declared argument.</li><li value="2">The argument is passed in a register.</li></ul></li>
                                        <li id="STDZ0549572" value="2">The called function pushes register values of all the registers that are modified by the function and that must be preserved upon exit of the function onto the stack. Normally, these registers are the save-on-entry registers (R4-R10) if the function contains calls. If the function is an interrupt, additional registers may need to be preserved. For more information, see <span class="crossreference"><a href="#STDZ0541002">Section 6.7</a></span>.</li>
                                        <li id="STDZ05483" value="3">The called function allocates memory for the local variables and argument block by subtracting a constant from the SP. This constant is computed with the following formula:</li>
                                        <p>
                                            <i>size of all local variables</i> + <i>max</i> = <i>constant</i></p>
                                        <p>The <i>max</i> argument specifies the size of all parameters placed in the argument block for each call.</p>
                                        <li value="4">The called function executes the code for the function.</li>
                                        <li value="5">If the called function returns a value, it places the value in R12, R12 and R13, or R12 through R15, depending on the size of the return type.</li>
                                        <li value="6">If the called function returns a structure, it copies the structure to the memory block that the first argument, R12, points to. If the caller does not use the return value, R12 is set to 0. This directs the called function not to copy the return structure. </li>
                                        <p>Structures and unions with size 32 bits or less are passed by value, either in registers or on the stack. Structures and unions larger than 32 bits are passed by reference. </p>
                                        <p>In this way, the caller can be smart about telling the called function where to return the structure. For example, in the statement s = func(x), where s is a structure and f is a function that returns a structure, the caller can simply pass the address of s as the first argument and call f. The function f then copies the return structure directly into s, performing the assignment automatically.</p>
                                        <p>You must be careful to properly declare functions that return structures, both at the point where they are called (so the caller properly sets up the first argument) and at the point where they are declared (so the function knows to copy the result).</p>
                                        <li value="7">The called function deallocates the frame and argument block by adding the constant computed in Step 3.</li>
                                        <li value="8">The called function restores all registers saved in Step 2.</li>
                                        <li value="9">The called function (func) returns.</li>
                                    </ol>
                                    <p>The following example is typical of how a called function responds to a call:</p>
                                    <code>func: ; Called function entry point
 PUSH.W r10
 PUSH.W r9 ; Save SOE registers
 SUB.W #2,SP ; Allocate the frame
 :
 : ; Body of function
 :
 ADD.W #2,SP ; Deallocate the frame
 POP r9 ; Restore SOE registers
 POP r10
 RET ; Return</code>
                                </div>
                                <div class="subsection">
                                    <h4 id="STDZ0540896">
                                        <a MadCap:generatedBookmark="TOC" name="6.4.3_Accessing_Arguments_and_Local_Variables">
                                        </a>
                                        <span class="section-label">6.4.3 </span>Accessing Arguments and Local Variables</h4>
                                    <p>A function accesses its local nonregister variables and stack arguments indirectly through the stack pointer (SP or R1). The SP always points to the top of the stack (the most recently pushed value).</p>
                                    <p>Since the stack grows toward smaller addresses, the local data on the stack for the C/C++ function is accessed with a positive offset from the SP register.</p>
                                </div>
                            </div>
                            <div class="subsection">
                                <h3 id="SLAU1326991">
                                    <a MadCap:generatedBookmark="TOC" name="6.5_Accessing_Linker_Symbols_in_C_and_C++">
                                    </a>
                                    <span class="section-label">6.5 </span>Accessing Linker Symbols in C and C++</h3>
                                <p>See the section on "Using Linker Symbols in C/C++ Applications" in the <i><span>MSP430</span> Assembly Language Tools User's Guide</i> for information about referring to linker symbols in C/C++ code.</p>
                            </div>
                            <div class="subsection">
                                <h3 id="STDZ0544217">
                                    <a MadCap:generatedBookmark="TOC" name="6.6_Interfacing_C_and_C++_With_Assembly_Language">
                                    </a>
                                    <span class="section-label">6.6 </span>Interfacing C and C++ With Assembly Language</h3>
                                <p>The following are ways to use assembly language with C/C++ code:</p>
                                <ul>
                                    <li value="1">Use separate modules of assembled code and link them with compiled C/C++ modules (see <span class="crossreference"><a href="#STDZ0549659">Section 6.6.1</a></span>).</li>
                                    <li value="2">Use assembly language variables and constants in C/C++ source (see <span class="crossreference"><a href="#STDZ0541706">Section 6.6.3</a></span>).</li>
                                    <li value="3">Use inline assembly language embedded directly in the C/C++ source (see <span class="crossreference"><a href="#STDZ0549304">Section 6.6.5</a></span>).</li>
                                </ul>
                                <div class="subsection">
                                    <h4 id="STDZ0549659">
                                        <a MadCap:generatedBookmark="TOC" name="6.6.1_Using_Assembly_Language_Modules_With_C_C++_Code">
                                        </a>
                                        <span class="section-label">6.6.1 </span>Using Assembly Language Modules With C/C++ Code</h4>
                                    <p>Interfacing C/C++ with assembly language functions is straightforward if you follow the calling conventions defined in <span class="crossreference"><a href="#STDZ0545494">Section 6.4</a></span>, and the register conventions defined in <span class="crossreference"><a href="#STDZ0543031">Section 6.3</a></span>. C/C++ code can access variables and call functions defined in assembly language, and assembly code can access C/C++ variables and call C/C++ functions. </p>
                                    <p>Follow these guidelines to interface assembly language and C:</p>
                                    <ul>
                                        <li value="1">You must preserve any dedicated registers modified by a function. Dedicated registers include:<ul><li value="1">Save-on-entry registers (R4-R10)</li><li value="2">Stack pointer (SP or R1)</li></ul></li>
                                        <p>If the SP is used normally, it does not need to be explicitly preserved. In other words, the assembly function is free to use the stack as long as anything that is pushed onto the stack is popped back off before the function returns (thus preserving SP). </p>
                                        <p>Any register that is not dedicated can be used freely without first being saved.</p>
                                        <li value="2">Interrupt routines must save <i>all</i> the registers they use. For more information, see <span class="crossreference"><a href="#STDZ0541002">Section 6.7</a></span>.</li>
                                        <li value="3">When you call a C/C++ function from assembly language, load the designated registers with arguments and push the remaining arguments onto the stack as described in <span class="crossreference"><a href="#STDZ0547291">Section 6.4.1</a></span>.</li>
                                        <p>Remember that a function can alter any register not designated as being preserved without having to restore it. If the contents of any of these registers must be preserved across the call, you must explicitly save them.</p>
                                        <li value="4">Functions must return values correctly according to their C/C++ declarations. Double values are returned in R12 and R13, and structures are returned as described in Step 2 of <span class="crossreference"><a href="#STDZ0547291">Section 6.4.1</a></span>. Any other values are returned in R12.</li>
                                        <li value="5">No assembly module should use the .cinit section for any purpose other than autoinitialization of global variables. The C/C++ startup routine assumes that the .cinit section consists <i>entirely</i> of initialization tables. Disrupting the tables by putting other information in .cinit can cause unpredictable results. </li>
                                        <li value="6">The compiler assigns linknames to all external objects. Thus, when you write assembly language code, you must use the same linknames as those assigned by the compiler. See <span class="crossreference"><a href="msp430-c-c-language-implementation.html#STDZ0553675">Section 5.14</a></span> for details.</li>
                                        <li value="7">Any object or function declared in assembly language that is accessed or called from C/C++ must be declared with the .def or .global directive in the assembly language modifier. This declares the symbol as external and allows the linker to resolve references to it.</li>
                                        <p>Likewise, to access a C/C++ function or object from assembly language, declare the C/C++ object with the .ref or .global directive in the assembly language module. This creates an undeclared external reference that the linker resolves.</p>
                                        <li value="8">Any assembly routines that interface with MSP430x C programs are required to conform to the large-code model:<ul><li value="1">Use CALLA/RETA instead of CALL/RET</li><li value="2">Use PUSHM.A/POPM.A to save and restore any used save-on-entry registers. The entire 20-bit register must be saved/restored.</li><li value="3">Manipulation of function pointers requires 20-bit operations (OP.A)</li><li value="4">If interfacing with C code compiled for the large-data model, data pointer manipulation must be performed using 20-bit operations (OP.A).</li></ul></li>
                                    </ul>
                                </div>
                                <div class="subsection">
                                    <h4 id="lit93614116">
                                        <a MadCap:generatedBookmark="TOC" name="6.6.2_Accessing_Assembly_Language_Functions_From_C_C++">
                                        </a>
                                        <span class="section-label">6.6.2 </span>Accessing Assembly Language Functions From C/C++</h4>
                                    <p>Functions defined in C++ that will be called from assembly should be defined as extern "C" in the C++ file. Functions defined in assembly that will be called from C++ must be prototyped as extern "C" in C++.</p>
                                    <p>
                                        <span class="crossreference">
                                            <a href="#STDZ0545380">Example 6-2</a>
                                        </span> illustrates a C++ function called main, which calls an assembly language function called asmfunc, <span class="crossreference"><a href="#STDZ0545885">Example 6-3</a></span>. The asmfunc function takes its single argument, adds it to the C++ global variable called gvar, and returns the result.</p>
                                    <div class="example">
                                        <h4 id="STDZ0545380">
                                            <a MadCap:generatedBookmark="TOC" name="Example_6-2_Calling_an_Assembly_Language_Function_From_a_C_C++_Program">
                                            </a>
                                            <span class="example-label">Example 6-2 </span>Calling an Assembly Language Function From a C/C++ Program</h4>
                                        <code>extern "C" {
extern int asmfunc(int a); /* declare external asm function */
int gvar = 0; /* define global variable */
}

void main()
{
 int var = 5;

 var = asmfunc(var); /* call function normally */</code>
                                    </div>
                                    <div class="example">
                                        <h4 id="STDZ0545885">
                                            <a MadCap:generatedBookmark="TOC" name="Example_6-3_Assembly_Language_Program_Called_by_Example_6-2">
                                            </a>
                                            <span class="example-label">Example 6-3 </span>Assembly Language Program Called by <span class="crossreference"><a href="#STDZ0545380">Example 6-2</a></span></h4>
                                        <code>      .global asmfunc
 .global gvar
asmfunc:
 MOV &amp;gvar,R11
 ADD R11,R12
 RET</code>
                                    </div>
                                    <p>In the C++ program in <span class="crossreference"><a href="#STDZ0545380">Example 6-2</a></span>, the extern "C" declaration tells the compiler to use C naming conventions (i.e., no name mangling). When the linker resolves the .global asmfunc reference, the corresponding definition in the assembly file will match.</p>
                                    <p>The parameter var is passed in R12, and the result is returned in R12.</p>
                                </div>
                                <div class="subsection">
                                    <h4 id="STDZ0541706">
                                        <a MadCap:generatedBookmark="TOC" name="6.6.3_Accessing_Assembly_Language_Variables_From_C_C++">
                                        </a>
                                        <span class="section-label">6.6.3 </span>Accessing Assembly Language Variables From C/C++</h4>
                                    <p>It is sometimes useful for a C/C++ program to access variables or constants defined in assembly language. There are several methods that you can use to accomplish this, depending on where and how the item is defined: a variable defined in the <span>.bss</span> section, a variable not defined in the <span>.bss</span> section, or a linker symbol. </p>
                                    <div class="subsection">
                                        <h4 id="STDZ0540906">
                                            <a MadCap:generatedBookmark="TOC" name="6.6.3.1_Accessing_Assembly_Language_Global_Variables">
                                            </a>
                                            <span class="section-label">6.6.3.1 </span>Accessing Assembly Language Global Variables</h4>
                                        <p>Accessing variables from the <span>.bss</span> section or a section named with .usect is straightforward:</p>
                                        <ol>
                                            <li value="1">Use the <span>.bss or </span>.usect directive to define the variable.</li>
                                            <li value="2">Use the .def or .global directive to make the definition external.</li>
                                            <li value="3">Use the appropriate linkname in assembly language.</li>
                                            <li value="4">In C/C++, declare the variable as <i>extern</i> and access it normally.</li>
                                        </ol>
                                        <p>
                                            <span class="crossreference">
                                                <a href="#STDZ054395">Example 6-5</a>
                                            </span> and <span class="crossreference"><a href="#STDZ0542160">Example 6-4</a></span> show how you can access a variable defined in <span>.bss</span>.</p>
                                        <div class="example">
                                            <h4 id="STDZ0542160">
                                                <a MadCap:generatedBookmark="TOC" name="Example_6-4_Assembly_Language_Variable_Program">
                                                </a>
                                                <span class="example-label">Example 6-4 </span>Assembly Language Variable Program</h4>
                                            <code>       .bss var,4,4 ; Define the variable
 .global var ; Declare it as external</code>
                                        </div>
                                        <div class="example">
                                            <h4 id="STDZ054395">
                                                <a MadCap:generatedBookmark="TOC" name="Example_6-5_C_Program_to_Access_Assembly_Language_From_Example_6-4">
                                                </a>
                                                <span class="example-label">Example 6-5 </span>C Program to Access Assembly Language From <span class="crossreference"><a href="#STDZ0542160">Example 6-4</a></span></h4>
                                            <code>extern int var; /* External variable */
var = 1; /* Use the variable */</code>
                                        </div>
                                    </div>
                                    <div class="subsection">
                                        <h4 id="STDZ0540907">
                                            <a MadCap:generatedBookmark="TOC" name="6.6.3.2_Accessing_Assembly_Language_Constants">
                                            </a>
                                            <span class="section-label">6.6.3.2 </span>Accessing Assembly Language Constants</h4>
                                        <p>You can define global constants in assembly language by using the .set directive in combination with either the .def or .global directive, or you can define them in a linker command file using a linker assignment statement. These constants are accessible from C/C++ only with the use of special operators.</p>
                                        <p>For <b>variables</b> defined in C/C++ or assembly language, the symbol table contains the <i>address of the value</i> contained by the variable. When you access an assembly variable by name from C/C++, the compiler gets the value using the address in the symbol table.</p>
                                        <p>For <b>assembly constants</b>, however, the symbol table contains the actual <i>value</i> of the constant. The compiler cannot tell which items in the symbol table are addresses and which are values. If you access an assembly (or linker) constant by name, the compiler tries to use the value in the symbol table as an address to fetch a value. To prevent this behavior, you must use the &amp; (address of) operator to get the value (_symval). In other words, if x is an assembly language constant, its value in C/C++ is &amp;x. See the section on "Using Linker Symbols in C/C++ Applications" in the <i><span>MSP430</span> Assembly Language Tools User's Guide</i> for more examples that use _symval.</p>
                                        <p>For more about symbols and the symbol table, refer to the section on "Symbols" in the <i><span>MSP430</span> Assembly Language Tools User's Guide</i>.</p>
                                        <p>You can use casts and #defines to ease the use of these symbols in your program, as in <span class="crossreference"><a href="#STDZ0547360">Example 6-6</a></span> and <span class="crossreference"><a href="#STDZ0543264">Example 6-7</a></span>.</p>
                                        <div class="example">
                                            <h4 id="STDZ0547360">
                                                <a MadCap:generatedBookmark="TOC" name="Example_6-6_Accessing_an_Assembly_Language_Constant_From_C">
                                                </a>
                                                <span class="example-label">Example 6-6 </span>Accessing an Assembly Language Constant From C</h4>
                                            <code>extern int table_size; /*external ref */
#define TABLE_SIZE ((int) _symval(&amp;table_size)) /* use cast to hide address-of */
 .
for (I=0; i&lt;TABLE_SIZE; ++I) /* use like normal symbol */</code>
                                        </div>
                                        <div class="example">
                                            <h4 id="STDZ0543264">
                                                <a MadCap:generatedBookmark="TOC" name="Example_6-7_Assembly_Language_Program_for_Example_6-6">
                                                </a>
                                                <span class="example-label">Example 6-7 </span>Assembly Language Program for <span class="crossreference"><a href="#STDZ0547360">Example 6-6</a></span></h4>
                                            <code>table_size .set	10000 ; define the constant
 .global _table_size ; make it global</code>
                                        </div>
                                        <p>Because you are referencing only the symbol's value as stored in the symbol table, the symbol's declared type is unimportant. In <span class="crossreference"><a href="#STDZ0547360">Example 6-6</a></span>, int is used. You can reference linker-defined symbols in a similar manner.</p>
                                    </div>
                                </div>
                                <div class="subsection">
                                    <h4 id="STDZ0543201">
                                        <a MadCap:generatedBookmark="TOC" name="6.6.4_Sharing_C_C++_Header_Files_With_Assembly_Source">
                                        </a>
                                        <span class="section-label">6.6.4 </span>Sharing C/C++ Header Files With Assembly Source</h4>
                                    <p>You can use the .cdecls assembler directive to share C headers containing declarations and prototypes between C and assembly code. Any legal C/C++ can be used in a .cdecls block and the C/C++ declarations will cause suitable assembly to be generated automatically, allowing you to reference the C/C++ constructs in assembly code. For more information, see the C/C++ header files chapter in the <i><span>MSP430 </span>Assembly Language Tools User's Guide</i>.</p>
                                </div>
                                <div class="subsection">
                                    <h4 id="STDZ0549304">
                                        <a MadCap:generatedBookmark="TOC" name="6.6.5_Using_Inline_Assembly_Language">
                                        </a>
                                        <span class="section-label">6.6.5 </span>Using Inline Assembly Language</h4>
                                    <p>Within a C/C++ program, you can use the asm statement to insert a single line of assembly language into the assembly language file created by the compiler. A series of asm statements places sequential lines of assembly language into the compiler output with no intervening code. For more information, see <span class="crossreference"><a href="msp430-c-c-language-implementation.html#STDZ055350">Section 5.10</a></span>.</p>
                                    <p>The asm statement is useful for inserting comments in the compiler output. Simply start the assembly code string with a semicolon (;) as shown below:</p>
                                    <code>asm(";*** this is an assembly language comment");</code>
                                    <span class="note">
                                        <p class="note_title">NOTE</p>
                                        <p>
                                            <b>Using the asm Statement</b>
                                        </p>
                                        <p>Keep the following in mind when using the asm statement:</p>
                                        <ul>
                                            <li value="1">Be extremely careful not to disrupt the C/C++ environment. The compiler does not check or analyze the inserted instructions.</li>
                                            <li value="2">Avoid inserting jumps or labels into C/C++ code because they can produce unpredictable results by confusing the register-tracking algorithms that the code generator uses.</li>
                                            <li value="3">Do not change the value of a C/C++ variable when using an asm statement. This is because the compiler does not verify such statements. They are inserted as is into the assembly code, and potentially can cause problems if you are not sure of their effect.</li>
                                            <li value="4">Do not use the asm statement to insert assembler directives that change the assembly environment.</li>
                                            <li value="5">Avoid creating assembly macros in C code and compiling with the --symdebug:dwarf (or -g) option. The C environments debug information and the assembly macro expansion are not compatible.</li>
                                        </ul>
                                    </span>
                                </div>
                            </div>
                            <div class="subsection">
                                <h3 id="STDZ0541002">
                                    <a MadCap:generatedBookmark="TOC" name="6.7_Interrupt_Handling">
                                    </a>
                                    <span class="section-label">6.7 </span>Interrupt Handling</h3>
                                <p>As long as you follow the guidelines in this section, you can interrupt and return to C/C++ code without disrupting the C/C++ environment. When the C/C++ environment is initialized, the startup routine does not enable or disable interrupts. If the system is initialized by way of a hardware reset, interrupts are disabled. If your system uses interrupts, you must handle any required enabling or masking of interrupts. Such operations have no effect on the C/C++ environment and are easily incorporated with asm statements or calling an assembly language function.</p>
                                <div class="subsection">
                                    <h4 id="STDZ0540908_4">
                                        <a MadCap:generatedBookmark="TOC" name="6.7.1_Saving_Registers_During_Interrupts">
                                        </a>
                                        <span class="section-label">6.7.1 </span>Saving Registers During Interrupts</h4>
                                    <p> When C/C++ code is interrupted, the interrupt routine must preserve the contents of all machine registers that are used by the routine or by any functions called by the routine. Register preservation must be explicitly handled by the interrupt routine.</p>
                                </div>
                                <div class="subsection">
                                    <h4 id="STDZ0545369">
                                        <a MadCap:generatedBookmark="TOC" name="6.7.2_Using_C_C++_Interrupt_Routines">
                                        </a>
                                        <span class="section-label">6.7.2 </span>Using C/C++ Interrupt Routines</h4>
                                    <p>A C/C++ interrupt routine is like any other C/C++ function in that it can have local variables and register variables. Except for software interrupt routines, an interrupt routine must be declared with no arguments and must return void. For example: </p>
                                    <code>__interrupt void example (void)
{
...
}</code>
                                    <p>If a C/C++ interrupt routine does not call any other functions, only those registers that the interrupt handler uses are saved and restored. However, if a C/C++ interrupt routine does call other functions, these functions can modify unknown registers that the interrupt handler does not use. For this reason, the routine saves all the save-on-call registers if any other functions are called. (This excludes banked registers.) Do not call interrupt handling functions directly.</p>
                                    <p>Interrupts can be handled directly with C/C++ functions by using the INTERRUPT pragma or the __interrupt keyword. For information, see <span class="crossreference"><a href="msp430-c-c-language-implementation.html#STDZ0556804">Section 5.11.18</a></span> and <span class="crossreference"><a href="msp430-c-c-language-implementation.html#STDZ0559860">Section 5.7.2</a></span>, respectively.</p>
                                </div>
                                <div class="subsection">
                                    <h4 id="STDZ0540910_4">
                                        <a MadCap:generatedBookmark="TOC" name="6.7.3_Using_Assembly_Language_Interrupt_Routines">
                                        </a>
                                        <span class="section-label">6.7.3 </span>Using Assembly Language Interrupt Routines</h4>
                                    <p>You can handle interrupts with assembly language code as long as you follow the same register conventions the compiler does. Like all assembly functions, interrupt routines can use the stack (16-bit limit), access global C/C++ variables, and call C/C++ functions normally. When calling C/C++ functions, be sure that any save-on-call registers are preserved before the call because the C/C++ function can modify any of these registers. You do not need to save save-on-entry registers because they are preserved by the called C/C++ function.</p>
                                </div>
                                <div class="subsection">
                                    <h4 id="SLAU1329506">
                                        <a MadCap:generatedBookmark="TOC" name="6.7.4_Interrupt_Vectors">
                                        </a>
                                        <span class="section-label">6.7.4 </span>Interrupt Vectors</h4>
                                    <p>The interrupt vectors for the MSP430 and MSP430X devices are 16 bits. Therefore, interrupt service routines (ISRs) must be placed into the low 64K of memory. Convenience macros are provided in the MSP430X device headers file to declare interrupts to ensure 16-bit placement when linking.</p>
                                    <p>Alternatively, use the CODE_SECTIONS pragma to place the code for ISRs into sections separate from the default .text sections. Use the linker command file and the SECTIONS directive to ensure the code sections associated with ISRs are placed into low memory.</p>
                                    <p>If you do not specify an ISR for some interrupt vectors, an ISR will be provided for those vectors from the RTS library and the RTS library will automatically be linked with your application. The default ISR puts the device in low power mode. You can override the ISR provided by the RTS with the pragma vector and the unused_interrupts keyword as shown in <span class="crossreference"><a href="msp430-c-c-language-implementation.html#SLAU1323389">Section 5.11.27</a></span>.</p>
                                </div>
                                <div class="subsection">
                                    <h4 id="STDZ0544970">
                                        <a MadCap:generatedBookmark="TOC" name="6.7.5_Other_Interrupt_Information">
                                        </a>
                                        <span class="section-label">6.7.5 </span>Other Interrupt Information</h4>
                                    <p>An interrupt routine can perform any task performed by any other function, including accessing global variables, allocating local variables, and calling other functions.</p>
                                    <p>When you write interrupt routines, keep the following points in mind:</p>
                                    <ul>
                                        <li value="1">It is your responsibility to handle any special masking of interrupts.</li>
                                        <li value="2">A C/C++ interrupt routine cannot be called directly from C/C++ code. You need to arrange for an interrupt signal to happen.</li>
                                        <li value="3">In a system reset interrupt, such as _c_int00, you cannot assume that the run-time environment is set up; therefore, you <i>cannot allocate local variables</i>, and you <i>cannot save any information on the run-time stack</i>.</li>
                                    </ul>
                                </div>
                            </div>
                            <div class="subsection">
                                <h3 id="SLAU1321265">
                                    <a MadCap:generatedBookmark="TOC" name="6.8_Using_Intrinsics_to_Access_Assembly_Language_Statements">
                                    </a>
                                    <span class="section-label">6.8 </span>Using Intrinsics to Access Assembly Language Statements</h3>
                                <p>The compiler recognizes a number of intrinsic operators. Intrinsics are used like functions and produce assembly language statements that would otherwise be inexpressible in C/C++. You can use C/C++ variables with these intrinsics, just as you would with any normal function. The intrinsics are specified with a double leading underscore, and are accessed by calling them as you do a function. (Both single and double leading underscores can be used with intrinsics, but a double underscore is preferred. For example:</p>
                                <code>short state;
 :
state = __get_SR_register();</code>
                                <p>No declaration of the intrinsic functions is necessary.</p>
                                <div class="subsection">
                                    <h4 id="SLAU1321420">
                                        <a MadCap:generatedBookmark="TOC" name="6.8.1_MSP430_Intrinsics">
                                        </a>
                                        <span class="section-label">6.8.1 </span>MSP430 Intrinsics</h4>
                                    <p>
                                        <span class="crossreference">
                                            <a href="#SLAU1322008">Table 6-5</a>
                                        </span> lists all of the intrinsic operators in the MSP430 C/C++ compiler. A function-like prototype is presented for each intrinsic that shows the expected type for each parameter. If the argument type does not match the parameter, type conversions are performed on the argument. The intrinsics.h file in the compiler's "include" directory contains function-like prototypes for all supported intrinsics.</p>
                                    <p>For more information on the resulting assembly language mnemonics, see the <i>MSP430x1xx Family Users Guide</i>, the <i>MSP430x3xx Family Users Guide</i>, and the <i>MSP430x4xx Family Users Guide</i>.</p>
                                    <div class="subsection">
                                        <p class="table" id="SLAU1322008">
                                            <span class="table-label">Table 6-5 </span>MSP430 Intrinsics </p>
                                        <table class="gentable">
                                            <colgroup>
                                                <col />
                                                <col />
                                                <col />
                                            </colgroup>
                                            <thead class="tbl_hdr_gray">
                                                <tr>
                                                    <th>Intrinsic</th>
                                                    <th />
                                                    <th>Generated Assembly</th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                <tr>
                                                    <td>unsigned short</td>
                                                    <td>__bcd_add_short(unsigned short <i>op1</i>, unsigned short <i>op2</i>);</td>
                                                    <td>MOV <i>op1</i>, <i>dst</i><br /> CLRC <br /> DADD <i>op2</i>, <i>dst</i> <![CDATA[ ]]></td>
                                                </tr>
                                                <tr>
                                                    <td>unsigned long</td>
                                                    <td>__bcd_add_long(unsigned long <i>op1</i>, unsigned long <i>op2</i>);</td>
                                                    <td>MOV <i>op1_low</i>, <i>dst_low</i><br /> MOV <i>op1_hi</i>, <i>dst_hi</i><br /> CLRC <br /> DADD <i>op2_low</i>, <i>dst_low</i><br /> DADD <i>op2_hi</i>, <i>dst_hi </i> <![CDATA[ ]]></td>
                                                </tr>
                                                <tr>
                                                    <td>unsigned short</td>
                                                    <td>__bic_SR_register(unsigned short <i>mask</i>);</td>
                                                    <td>BIC <i>mask</i>, SR</td>
                                                </tr>
                                                <tr>
                                                    <td>unsigned short</td>
                                                    <td>__bic_SR_register_on_exit(unsigned short <i>mask</i>);</td>
                                                    <td>BIC <i>mask</i>, saved_SR</td>
                                                </tr>
                                                <tr>
                                                    <td>unsigned short</td>
                                                    <td>__bis_SR_register(unsigned short <i>mask</i>);</td>
                                                    <td>BIS <i>mask</i>, SR</td>
                                                </tr>
                                                <tr>
                                                    <td>unsigned short</td>
                                                    <td>__bis_SR_register_on_exit(unsigned short <i>mask</i>);</td>
                                                    <td>BIS <i>mask</i>, saved_SR</td>
                                                </tr>
                                                <tr>
                                                    <td>unsigned long</td>
                                                    <td>__data16_read_addr(unsigned short <i>addr</i>);</td>
                                                    <td>MOV.W addr, Rx<br /> MOVA 0(Rx), dst</td>
                                                </tr>
                                                <tr>
                                                    <td>void</td>
                                                    <td>__data16_write_addr (unsigned short <i>addr</i>, unsigned long <i>src</i>);</td>
                                                    <td>MOV.W addr, Rx<br /> MOVA src, 0(Rx)</td>
                                                </tr>
                                                <tr>
                                                    <td>unsigned char</td>
                                                    <td>__data20_read_char(unsigned long <i>addr</i>);<sup><a class="crossreference" href="#SLAU1322636">(1)</a></sup> <![CDATA[ ]]></td>
                                                    <td>MOVA <i>addr</i>, Rx<br /> MOVX.B 0(Rx), <i>dst</i> <![CDATA[ ]]></td>
                                                </tr>
                                                <tr>
                                                    <td>unsigned long</td>
                                                    <td>__data20_read_long(unsigned long <i>addr</i>);<sup><a class="crossreference" href="#SLAU1322636">(1)</a></sup> <![CDATA[ ]]></td>
                                                    <td>MOVA <i>addr</i>, Rx<br /> MOVX.W 0(Rx), <i>dst.lo</i><br /> MOVX.W 2(Rx), <i>dst.hi</i> <![CDATA[ ]]></td>
                                                </tr>
                                                <tr>
                                                    <td>unsigned short</td>
                                                    <td>__data20_read_short(unsigned long <i>addr</i>);<sup><a class="crossreference" href="#SLAU1322636">(1)</a></sup> <![CDATA[ ]]></td>
                                                    <td>MOVA <i>addr</i>, Rx<br /> MOVX.W 0(Rx), <i>dst</i> <![CDATA[ ]]></td>
                                                </tr>
                                                <tr>
                                                    <td>void</td>
                                                    <td>__data20_write_char(unsigned long <i>addr</i>, unsigned char <i>src</i>);<sup><a class="crossreference" href="#SLAU1322636">(1)</a></sup> <![CDATA[ ]]></td>
                                                    <td>MOVA <i>addr</i>, Rx<br /> MOVX.B <i>src</i>, 0(Rx)</td>
                                                </tr>
                                                <tr>
                                                    <td>void</td>
                                                    <td>__data20_write_long(unsigned long <i>addr</i>, unsigned long <i>src</i>);<sup><a class="crossreference" href="#SLAU1322636">(1)</a></sup> <![CDATA[ ]]></td>
                                                    <td>MOVA <i>addr</i>, Rx<br /> MOVX.W <i>src.lo</i>, 0(Rx)<br /> MOVX.W <i>src.hi</i>, 2(Rx)</td>
                                                </tr>
                                                <tr>
                                                    <td>void</td>
                                                    <td>__data20_write_short(unsigned long <i>addr</i>, unsigned short <i>src</i>);<sup><a class="crossreference" href="#SLAU1322636">(1)</a></sup> <![CDATA[ ]]></td>
                                                    <td>MOVA <i>addr</i>, Rx<br /> MOVX.W <i>src</i>, 0(Rx)</td>
                                                </tr>
                                                <tr>
                                                    <td>void</td>
                                                    <td>__delay_cycles(unsigned long);</td>
                                                    <td>See <span class="crossreference"><a href="#SLAU1322856">Section 6.8.3</a></span>.</td>
                                                </tr>
                                                <tr>
                                                    <td>void</td>
                                                    <td>__disable_interrupt(void);<br /> &#160;&#160;&#160;&#160;OR<br /> __disable_interrupts(void);</td>
                                                    <td>DINT</td>
                                                </tr>
                                                <tr>
                                                    <td>void</td>
                                                    <td>__enable_interrupt(void);<br /> &#160;&#160;&#160;&#160;OR <br /> __enable_interrupts(void);</td>
                                                    <td>EINT</td>
                                                </tr>
                                                <tr>
                                                    <td>unsigned int</td>
                                                    <td>__even_in_range(unsigned int, unsigned int);</td>
                                                    <td>See <span class="crossreference"><a href="msp430-c-c-language-implementation.html#SLAU1323389">Section 5.11.27</a></span>.</td>
                                                </tr>
                                                <tr>
                                                    <td>unsigned short</td>
                                                    <td>__get_interrupt_state(void);</td>
                                                    <td>MOV SR, <i>dst</i> <![CDATA[ ]]></td>
                                                </tr>
                                                <tr>
                                                    <td>unsigned short</td>
                                                    <td>__get_R4_register(void); /* deprecated */</td>
                                                    <td>MOV.W R4, dst</td>
                                                </tr>
                                                <tr>
                                                    <td>unsigned short</td>
                                                    <td>__get_R5_register(void); /* deprecated */</td>
                                                    <td>MOV.W R5, dst</td>
                                                </tr>
                                                <tr>
                                                    <td>unsigned short</td>
                                                    <td>__get_SP_register(void);</td>
                                                    <td>MOV SP, <i>dst</i> <![CDATA[ ]]></td>
                                                </tr>
                                                <tr>
                                                    <td>unsigned short</td>
                                                    <td>__get_SR_register(void);</td>
                                                    <td>MOV SR, <i>dst</i> <![CDATA[ ]]></td>
                                                </tr>
                                                <tr>
                                                    <td>unsigned short</td>
                                                    <td>__get_SR_register_on_exit(void);</td>
                                                    <td>MOV saved_SR, <i>dst</i> <![CDATA[ ]]></td>
                                                </tr>
                                                <tr>
                                                    <td>void</td>
                                                    <td>__low_power_mode_0(void);</td>
                                                    <td>BIS.W #0x18, SR</td>
                                                </tr>
                                                <tr>
                                                    <td>void</td>
                                                    <td>__low_power_mode_1(void);</td>
                                                    <td>BIS.W #0x58, SR</td>
                                                </tr>
                                                <tr>
                                                    <td>void</td>
                                                    <td>__low_power_mode_2(void);</td>
                                                    <td>BIS.W #0x98, SR</td>
                                                </tr>
                                                <tr>
                                                    <td>void</td>
                                                    <td>__low_power_mode_3(void);</td>
                                                    <td>BIS.W #0xD8, SR</td>
                                                </tr>
                                                <tr>
                                                    <td>void</td>
                                                    <td>__low_power_mode_4(void);</td>
                                                    <td>BIS.W #0xF8, SR</td>
                                                </tr>
                                                <tr>
                                                    <td>void</td>
                                                    <td>__low_power_mode_off_on_exit(void);</td>
                                                    <td>BIC.W #0xF0, saved_SR</td>
                                                </tr>
                                                <tr>
                                                    <td>void</td>
                                                    <td>__never_executed(void);</td>
                                                    <td>See <span class="crossreference"><a href="#SLAU1322818">Section 6.8.4</a></span>.</td>
                                                </tr>
                                                <tr>
                                                    <td>void</td>
                                                    <td>__no_operation(void);</td>
                                                    <td>NOP</td>
                                                </tr>
                                                <tr>
                                                    <td>void</td>
                                                    <td>__op_code(unsigned short);</td>
                                                    <td>Encodes whatever instruction corresponds to the argument.</td>
                                                </tr>
                                                <tr>
                                                    <td>short</td>
                                                    <td> __saturated_add_signed_short( short <i>src1</i>, short <i>src2</i> ); </td>
                                                    <td>Instructions to perform saturated addition on short values. Values outside the range of a signed short are capped at the maximum or minimum value as appropriate.</td>
                                                </tr>
                                                <tr>
                                                    <td>long</td>
                                                    <td>__saturated_add_signed_long( long <i>src1</i>, long <i>src2</i> ); </td>
                                                    <td>Instructions to perform saturated addition on long values. Values outside the range of a signed long are capped at the maximum or minimum value as appropriate.</td>
                                                </tr>
                                                <tr>
                                                    <td>short</td>
                                                    <td>__saturated_sub_signed_short( short <i>src1</i>, short <i>src2</i> ); </td>
                                                    <td>Instructions to perform saturated subtraction on short values. Values outside the range of a signed short are capped at the maximum or minimum value as appropriate.</td>
                                                </tr>
                                                <tr>
                                                    <td>long</td>
                                                    <td>__saturated_sub_signed_long( long <i>src1</i>, long <i>src2</i> ); </td>
                                                    <td>Instructions to perform saturated subtraction on long values. Values outside the range of a signed long are capped at the maximum or minimum value as appropriate.</td>
                                                </tr>
                                                <tr>
                                                    <td>void</td>
                                                    <td>__set_interrupt_state(unsigned short <i>src</i>);</td>
                                                    <td>MOV <i>src</i>, SR</td>
                                                </tr>
                                                <tr>
                                                    <td>void</td>
                                                    <td>__set_R4_register(unsigned short <i>src</i>); /* deprecated */</td>
                                                    <td>MOV.W <i>src</i>, R4</td>
                                                </tr>
                                                <tr>
                                                    <td>void</td>
                                                    <td>__set_R5_register(unsigned short <i>src</i>); /* deprecated */</td>
                                                    <td>MOV.W <i>src</i>, R5</td>
                                                </tr>
                                                <tr>
                                                    <td>void</td>
                                                    <td>__set_SP_register(unsigned short <i>src</i>);</td>
                                                    <td>MOV <i>src</i>, SP</td>
                                                </tr>
                                                <tr>
                                                    <td>unsigned short</td>
                                                    <td>__swap_bytes(unsigned short <i>src</i>);</td>
                                                    <td>MOV <i>src</i>, <i>dst</i><br /> SWPB <i>dst</i> <![CDATA[ ]]></td>
                                                </tr>
                                            </tbody>
                                        </table>
                                        <div class="tablenote" id="SLAU1322636">
                                            <span class="section-label">(1) </span>Intrinsic encodes multiple instructions depending on the code. The most common instructions produced are presented here.</div>
                                    </div>
                                </div>
                                <div class="subsection">
                                    <h4 id="SLAU1329223">
                                        <a MadCap:generatedBookmark="TOC" name="6.8.2_Deprecated_Intrinsics">
                                        </a>
                                        <span class="section-label">6.8.2 </span>Deprecated Intrinsics</h4>
                                    <p>The following intrinsics have been deprecated. Using them is not recommended, because they may not be supported in future releases.</p>
                                    <div class="subsection">
                                        <p class="table" id="SLAU1326774">
                                            <span class="table-label">Table 6-6 </span>Deprecated Intrinsics </p>
                                        <table class="gentable">
                                            <colgroup>
                                                <col />
                                            </colgroup>
                                            <thead class="tbl_hdr_gray">
                                                <tr>
                                                    <th>Intrinsic</th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                <tr>
                                                    <td>__get_R4_register</td>
                                                </tr>
                                                <tr>
                                                    <td>__get_R5_register</td>
                                                </tr>
                                                <tr>
                                                    <td>__set_R4_register</td>
                                                </tr>
                                                <tr>
                                                    <td>__set_R5_register</td>
                                                </tr>
                                            </tbody>
                                        </table>
                                    </div>
                                </div>
                                <div class="subsection">
                                    <h4 id="SLAU1322856">
                                        <a MadCap:generatedBookmark="TOC" name="6.8.3_The___delay_cycle_Intrinsic">
                                        </a>
                                        <span class="section-label">6.8.3 </span>The __delay_cycle Intrinsic</h4>
                                    <p>The __delay_cycles intrinsic inserts code to consume precisely the number of specified cycles with no side effects. The number of cycles delayed must be a compile-time constant.</p>
                                </div>
                                <div class="subsection">
                                    <h4 id="SLAU1322818">
                                        <a MadCap:generatedBookmark="TOC" name="6.8.4_The___never_executed_Intrinsic">
                                        </a>
                                        <span class="section-label">6.8.4 </span>The __never_executed Intrinsic</h4>
                                    <p>The MSP430 C/C++ Compiler supports a __never_executed( ) intrinsic that can be used to assert that a default label in a switch block is never executed. If you assert that a default label is never executed the compiler can generate more efficient code based on the values specified in the case labels within a switch block.</p>
                                    <div class="subsection">
                                        <h4 id="SLAU1322060">
                                            <a MadCap:generatedBookmark="TOC" name="6.8.4.1_Using___never_executed_With_a_Vector_Generator">
                                            </a>
                                            <span class="section-label">6.8.4.1 </span>Using __never_executed With a Vector Generator</h4>
                                        <p>The __never_executed( ) intrinsic is specifically useful for testing the values of an MSP430 interrupt vector generator such as the vector generator for Timer A (TAIV). MSP430 vector generator values are mapped to an interrupt source and are characterized in that they fall within a specific range and can only take on even values. A common way to handle a particular interrupt source represented in a vector generator is to use a switch statement. However, a compiler is constrained by the C language in that it can make no assumptions about what values a switch expression may have. The compiler will have to generate code to handle every possible value, which leads to what would appear to be inefficient code.</p>
                                        <p>The __never_executed( ) intrinsic can be used to assert to the compiler that a switch expression can only take on values represented by the case labels within a switch block. Having this assertion, the compiler can avoid generating test code for handling values not specified by the switch case labels. Having this assertion is specifically suited for handling values that characterize a vector generator.</p>
                                        <p>
                                            <span class="crossreference">
                                                <a href="#SLAU1324486">Example 6-8</a>
                                            </span> illustrates a switch block that handles the values of the Timer B (TBIV) vector generator.</p>
                                        <div class="example">
                                            <h4 id="SLAU1324486">
                                                <a MadCap:generatedBookmark="TOC" name="Example_6-8_TBIV_Vector_Generator">
                                                </a>
                                                <span class="example-label">Example 6-8 </span>TBIV Vector Generator</h4>
                                            <code>__interrupt void Timer_B1 (void)
{
 switch( TBIV )
 {
 case 0: break; /* Do nothing */
 case 2: TBCCR1 += 255;
 state +=1;
 break;
 case 4: TBCCR0 = 254;
 TBCCR1 = 159;
 state =200;
 break;
 case 6: break;
 case 8: break;
 case 10: break;
 case 12: break;
 case 14: break;
 default: __never_executed();
 }
}</code>
                                        </div>
                                        <p>In <span class="crossreference"><a href="#SLAU1324486">Example 6-8</a></span> using the __never_executed( ) intrinsic asserts that the value of TBIV can only take on the values specified by the case labels, namely the even values from 0 to 14. Normally, the compiler would have to generate code to handle any value which would result in extra range checks. Instead, for this example, the compiler will generate a switch table where the value of TBIV is simply added to the PC to jump to the appropriate code block handling each value represented by the case labels.</p>
                                    </div>
                                    <div class="subsection">
                                        <h4 id="SLAU1329828">
                                            <a MadCap:generatedBookmark="TOC" name="6.8.4.2_Using___never_executed_With_General_Switch_Expressions">
                                            </a>
                                            <span class="section-label">6.8.4.2 </span>Using __never_executed With General Switch Expressions</h4>
                                        <p>Using the __never_executed( ) intrinsic at the default label can also improve the generated switch code for more general switch expressions that do not involve vector generator type values.</p>
                                        <div class="example">
                                            <h4 id="SLAU1327277">
                                                <a MadCap:generatedBookmark="TOC" name="Example_6-9_General_Switch_Statement">
                                                </a>
                                                <span class="example-label">Example 6-9 </span>General Switch Statement</h4>
                                            <code>switch( val)
{
 case 0:
 case 5: action(a); break;

 case 14: action(b); break;

 default: __never_executed();
}</code>
                                        </div>
                                        <p>Normally, for the switch expression values 0 and 5, the compiler generates code to test for both 0 and 5 since the compiler must handle the possible values 14. The __never_executed( ) intrinsic in <span class="crossreference"><a href="#SLAU1327277">Example 6-9</a></span> asserts that val cannot take on the values 14 and therefore the compiler only needs to generate a single test (val &lt; 6) to handle both case labels.</p>
                                        <p>Additionally, using the __never_executed( ) intrinsic results in the assertion that if val is not 0 or 5 then it has to be 14 and the compiler has no need to generate code to test for val == 14.</p>
                                        <p>The __never_executed( ) intrinsic is only defined when specified as the single statement following a default case label. The compiler ignores the use of the intrinsic in any other context.</p>
                                    </div>
                                </div>
                            </div>
                            <div class="subsection">
                                <h3 id="STDZ0543503">
                                    <a MadCap:generatedBookmark="TOC" name="6.9_System_Initialization">
                                    </a>
                                    <span class="section-label">6.9 </span>System Initialization</h3>
                                <p>Before you can run a C/C++ program, you must create the C/C++ run-time environment. The C/C++ boot routine performs this task using a function called <span>_c_int00</span>. The run-time-support source library, rts.src, contains the source to this routine in a module named boot.c (or boot.asm).</p>
                                <p>To begin running the system, the <span>_c_int00</span> function can be <span>called by reset hardware.</span> You must link the <span>_c_int00</span> function with the other object files. This occurs automatically when you use the --rom_model or --ram_model link option and include a standard run-time-support library as one of the linker input files.</p>
                                <p>When C/C++ programs are linked, the linker sets the entry point value in the executable output file to the symbol <span>_c_int00</span>.</p>
                                <p>The <span>_c_int00</span> function performs the following tasks to initialize the environment:</p>
                                <ol>
                                    <li value="1">Reserves space for the user mode run-time stack, and sets up the initial value of the stack pointer (SP)</li>
                                    <li value="2">It initializes global variables by copying the data from the initialization tables to the storage allocated for the variables in the .bss section. If you are initializing variables at load time (--ram_model option), a loader performs this step before the program runs (it is not performed by the boot routine). For more information, see <span class="crossreference"><a href="#STDZ0549369">Section 6.9.3</a></span>.</li>
                                    <li value="3">Executes the global constructors found in the global constructors table. For more information, see <span class="crossreference"><a href="#STDZ0545810">Section 6.9.3.6</a></span>.</li>
                                    <li value="4">Calls the main() function to run the C/C++ program</li>
                                </ol>
                                <p>You can replace or modify the boot routine to meet your system requirements. However, the boot routine <i>must </i>perform the operations listed above to correctly initialize the C/C++ environment.</p>
                                <div class="subsection">
                                    <h4 id="SLAU1329684">
                                        <a MadCap:generatedBookmark="TOC" name="6.9.1_Boot_Hook_Functions_for_System_Pre-Initialization">
                                        </a>
                                        <span class="section-label">6.9.1 </span>Boot Hook Functions for System Pre-Initialization</h4>
                                    <p>Boot hooks are points at which you may insert application functions into the C/C++ boot process. Default boot hook functions are provided with the run-time support (RTS) library. However, you can implement customized versions of these boot hook functions, which override the default boot hook functions in the RTS library if they are linked before the run-time library. Such functions can perform any application-specific initialization before continuing with the C/C++ environment setup. </p>
                                    <p>Note that the TI-RTOS operating system uses custom versions of the boot hook functions for system setup, so you should be careful about overriding these functions if you are using TI-RTOS.</p>
                                    <p>The following boot hook functions are available: </p>
                                    <p>
                                        <b>_system_pre_init():</b> This function provides a place to perform application-specific initialization. It is invoked after the stack pointer is initialized but before any C/C++ environment setup is performed. By default, _system_pre_init() should return a non-zero value. The default C/C++ environment setup is bypassed if _system_pre_init() returns 0. </p>
                                    <p>
                                        <b>_system_post_cinit():</b> This function is invoked during C/C++ environment setup, after C/C++ global data is initialized but before any C++ constructors are called. This function should not return a value.</p>
                                    <p>The _c_int00( ) initialization routine also provides a mechanism for an application to perform the setup (set I/O registers, enable/disable timers, etc.) before the C/C++ environment is initialized.</p>
                                </div>
                                <div class="subsection">
                                    <h4 id="STDZ0542399">
                                        <a MadCap:generatedBookmark="TOC" name="6.9.2_Run-Time_Stack">
                                        </a>
                                        <span class="section-label">6.9.2 </span>Run-Time Stack</h4>
                                    <p>The run-time stack is allocated in a single continuous block of memory and grows down from high addresses to lower addresses. The SP points to the top of the stack. </p>
                                    <p>The code does not check to see if the run-time stack overflows. Stack overflow occurs when the stack grows beyond the limits of the memory space that was allocated for it. Be sure to allocate adequate memory for the stack. </p>
                                    <p>The stack size can be changed at link time by using the --stack_size link option on the linker command line and specifying the stack size as a constant directly after the option.</p>
                                    <p>The C/C++ boot routine shipped with the compiler sets up the user/thread mode run-time stack. If your program uses a run-time stack when it is in other operating modes, you must also allocate space and set up the run-time stack corresponding to those modes.</p>
                                </div>
                                <div class="subsection">
                                    <h4 id="STDZ0549369">
                                        <a MadCap:generatedBookmark="TOC" name="6.9.3_Automatic_Initialization_of_Variables">
                                        </a>
                                        <span class="section-label">6.9.3 </span>Automatic Initialization of Variables</h4>
                                    <p>Any global variables declared as preinitialized must have initial values assigned to them before a C/C++ program starts running. The process of retrieving these variables' data and initializing the variables with the data is called autoinitialization. Internally, the compiler and linker coordinate to produce compressed initialization tables. Your code should not access the initialization table.</p>
                                    <div class="subsection">
                                        <h4 id="STDZ0545637">
                                            <a MadCap:generatedBookmark="TOC" name="6.9.3.1_Zero_Initializing_Variables">
                                            </a>
                                            <span class="section-label">6.9.3.1 </span>Zero Initializing Variables </h4>
                                        <p>In ANSI C, global and static variables that are not explicitly initialized must be set to 0 before program execution. The C/C++ compiler supports preinitialization of uninitialized variables by default. This can be turned off by specifying the linker option --zero_init=off. </p>
                                    </div>
                                    <div class="subsection">
                                        <h4 id="STDZ0548758">
                                            <a MadCap:generatedBookmark="TOC" name="6.9.3.2_Direct_Initialization">
                                            </a>
                                            <span class="section-label">6.9.3.2 </span>Direct Initialization</h4>
                                        <p>The compiler uses direct initialization to initialize global variables. For example, consider the following C code:</p>
                                        <code>int i = 23;
int a[5] = { 1, 2, 3, 4, 5 };</code>
                                        <p>The compiler allocates the variables 'i' and 'a[] to .data section and the initial values are placed directly. </p>
                                        <code>        .global i
 .data
 .align 4
i:
 .field 23,32 ; i @ 0

 .global a
 .data
 .align 4
a:
 .field 1,32 ; a[0] @ 0
 .field 2,32 ; a[1] @ 32
 .field 3,32 ; a[2] @ 64
 .field 4,32 ; a[3] @ 96
 .field 5,32 ; a[4] @ 128</code>
                                        <p>Each compiled module that defines static or global variables contains these .data sections. The linker treats the .data section like any other initialized section and creates an output section. In the load-time initialization model, the sections are loaded into memory and used by the program. See <span class="crossreference"><a href="#STDZ0546592">Section 6.9.3.5</a></span>.</p>
                                        <p>In the run-time initialization model, the linker uses the data in these sections to create initialization data and an additional compressed initialization table. The boot routine processes the initialization table to copy data from load addresses to run addresses. See <span class="crossreference"><a href="#STDZ054428">Section 6.9.3.3</a></span>.</p>
                                    </div>
                                    <div class="subsection">
                                        <h4 id="STDZ054428">
                                            <a MadCap:generatedBookmark="TOC" name="6.9.3.3_Autoinitialization_of_Variables_at_Run_Time">
                                            </a>
                                            <span class="section-label">6.9.3.3 </span>Autoinitialization of Variables at Run Time</h4>
                                        <p>Autoinitializing variables at run time is the default method of autoinitialization. To use this method, invoke the linker with the --rom_model option. </p>
                                        <p>Using this method, the linker creates a compressed initialization table and initialization data from the direct initialized sections in the compiled module. The table and data are used by the C/C++ boot routine to initialize variables in RAM using the table and data in ROM.</p>
                                        <p>
                                            <span class="crossreference">
                                                <a href="#STDZ0545167">Figure 6-3</a>
                                            </span> illustrates autoinitialization at run time. Use this method in any system where your application runs from code burned into ROM.</p>
                                        <div class="figure">
                                            <span class="caption" id="STDZ0545167">
                                                <span class="figure-label">Figure 6-3 </span>Autoinitialization at Run Time</span>
                                            <img alt="init_run_470_pnu151.gif" itemprop="image" src="ods/images/SLAU132R/init_run_470_pnu151.gif" title="Autoinitialization at Run&#xA;    Time" /> </div>
                                    </div>
                                    <div class="subsection">
                                        <h4 id="STDZ0545680">
                                            <a MadCap:generatedBookmark="TOC" name="6.9.3.4_Autoinitialization_Tables">
                                            </a>
                                            <span class="section-label">6.9.3.4 </span>Autoinitialization Tables</h4>
                                        <p>The compiled object files do not have initialization tables. The variables are initialized directly . The linker, when the --rom_model option is specified, creates C auto initialization table and the initialization data. The linker creates both the table and the initialization data in an output section named .cinit.</p>
                                        <p>The autoinitialization table has the following format:</p>
                                        <div class="figure">
                                            <img alt="auto_init_pnu151.png" itemprop="image" src="ods/images/SLAU132R/auto_init_pnu151.png" title="" /> </div>
                                        <p>The linker defined symbols __TI_CINIT_Base and __TI_CINIT_Limit point to the start and end of the table, respectively. Each entry in this table corresponds to one output section that needs to be initialized. The initialization data for each output section could be encoded using different encoding. </p>
                                        <p>The load address in the C auto initialization record points to initialization data with the following format:</p>
                                        <div class="subsection">
                                            <table class="gentable">
                                                <colgroup>
                                                    <col />
                                                    <col />
                                                </colgroup>
                                                <tbody>
                                                    <tr>
                                                        <td>8-bit index</td>
                                                        <td>Encoded data</td>
                                                    </tr>
                                                </tbody>
                                            </table>
                                        </div>
                                        <p>The first 8-bits of the initialization data is the handler index. It indexes into a handler table to get the address of a handler function that knows how to decode the following data.</p>
                                        <p>The handler table is a list of 32-bit function pointers.</p>
                                        <div class="figure">
                                            <img alt="handler_32_pnu151.gif" itemprop="image" src="ods/images/SLAU132R/handler_32_pnu151.gif" title="" /> </div>
                                        <p>The <i>encoded data</i> that follows the 8-bit index can be in one of the following format types. For clarity the 8-bit index is also depicted for each format. </p>
                                        <div class="subsection">
                                            <h4 id="STDZ0543417">
                                                <a MadCap:generatedBookmark="TOC" name="6.9.3.4.1_Length_Followed_by_Data_Format">
                                                </a>
                                                <span class="section-label">6.9.3.4.1 </span>Length Followed by Data Format</h4>
                                            <div class="subsection">
                                                <table class="gentable">
                                                    <colgroup>
                                                        <col />
                                                        <col />
                                                        <col />
                                                        <col />
                                                    </colgroup>
                                                    <tbody>
                                                        <tr>
                                                            <td>8-bit index</td>
                                                            <td>24-bit padding</td>
                                                            <td>32-bit length (N)</td>
                                                            <td>N byte initialization data (not compressed)</td>
                                                        </tr>
                                                    </tbody>
                                                </table>
                                            </div>
                                            <p>The compiler uses 24-bit padding to align the length field to a 32-bit boundary. The 32-bit length field encodes the length of the initialization data in bytes (N). N byte initialization data is not compressed and is copied to the run address as is. </p>
                                            <p>The run-time support library has a function __TI_zero_init() to process this type of initialization data. The first argument to this function is the address pointing to the byte after the 8-bit index. The second argument is the run address from the C auto initialization record.</p>
                                        </div>
                                        <div class="subsection">
                                            <h4 id="STDZ054355">
                                                <a MadCap:generatedBookmark="TOC" name="6.9.3.4.2_Zero_Initialization_Format">
                                                </a>
                                                <span class="section-label">6.9.3.4.2 </span>Zero Initialization Format</h4>
                                            <div class="subsection">
                                                <table class="gentable">
                                                    <colgroup>
                                                        <col />
                                                        <col />
                                                        <col />
                                                    </colgroup>
                                                    <tbody>
                                                        <tr>
                                                            <td>8-bit index</td>
                                                            <td>24-bit padding</td>
                                                            <td>32-bit length (N)</td>
                                                        </tr>
                                                    </tbody>
                                                </table>
                                            </div>
                                            <p>The compiler uses 24-bit padding to align the length field to a 32-bit boundary. The 32-bit length field encodes the number of bytes to be zero initialized.</p>
                                            <p>The run-time support library has a function __TI_zero_init() to process the zero initialization. The first argument to this function is the address pointing to the byte after the 8-bit index. The second argument is the run address from the C auto initialization record.</p>
                                        </div>
                                        <div class="subsection">
                                            <h4 id="STDZ0546283">
                                                <a MadCap:generatedBookmark="TOC" name="6.9.3.4.3_Run_Length_Encoded_(RLE)_Format">
                                                </a>
                                                <span class="section-label">6.9.3.4.3 </span>Run Length Encoded (RLE) Format</h4>
                                            <div class="subsection">
                                                <table class="gentable">
                                                    <colgroup>
                                                        <col />
                                                        <col />
                                                    </colgroup>
                                                    <tbody>
                                                        <tr>
                                                            <td>8-bit index</td>
                                                            <td>Initialization data compressed using run length encoding</td>
                                                        </tr>
                                                    </tbody>
                                                </table>
                                            </div>
                                            <p>The data following the 8-bit index is compressed using Run Length Encoded (RLE) format. uses a simple run length encoding that can be decompressed using the following algorithm:</p>
                                            <ol>
                                                <li value="1">Read the first byte, Delimiter (D).</li>
                                                <li value="2">Read the next byte (B).</li>
                                                <li value="3">If B != D, copy B to the output buffer and go to step 2.</li>
                                                <li value="4">Read the next byte (L).<ol style="list-style-type: lower-alpha;"><li value="1">If L == 0, then length is either a 16-bit, a 24-bit value, or weve reached the end of the data, read next byte (L).<ol><li value="1">If L == 0, length is a 24-bit value or the end of the data is reached, read next byte (L).<ol style="list-style-type: lower-alpha;"><li value="1">If L == 0, the end of the data is reached, go to step 7.</li><li value="2">Else L &lt;&lt;= 16, read next two bytes into lower 16 bits of L to complete 24-bit value for L.</li></ol></li><li value="2">Else L &lt;&lt;= 8, read next byte into lower 8 bits of L to complete 16-bit value for L.</li></ol></li><li value="2">Else if L &gt; 0 and L &lt; 4, copy D to the output buffer L times. Go to step 2.</li><li value="3">Else, length is 8-bit value (L).</li></ol></li>
                                                <li value="5">Read the next byte (C); C is the repeat character.</li>
                                                <li value="6">Write C to the output buffer L times; go to step 2.</li>
                                                <li value="7">End of processing.</li>
                                            </ol>
                                            <p>The run-time support library has a routine __TI_decompress_rle24() to decompress data compressed using RLE. The first argument to this function is the address pointing to the byte after the 8-bit index. The second argument is the run address from the C auto initialization record.</p>
                                            <span class="note">
                                                <p class="note_title">NOTE</p>
                                                <b>RLE Decompression Routine</b>
                                                <p>The previous decompression routine, __TI_decompress_rle(), is included in the run-time-support library for decompressing RLE encodings generated by older versions of the linker.</p>
                                            </span>
                                        </div>
                                        <div class="subsection">
                                            <h4 id="STDZ0543083">
                                                <a MadCap:generatedBookmark="TOC" name="6.9.3.4.4_Lempel-Ziv-Storer-Szymanski_Compression_(LZSS)_Format">
                                                </a>
                                                <span class="section-label">6.9.3.4.4 </span>Lempel-Ziv-Storer-Szymanski Compression (LZSS) Format</h4>
                                            <div class="subsection">
                                                <table class="gentable">
                                                    <colgroup>
                                                        <col />
                                                        <col />
                                                    </colgroup>
                                                    <tbody>
                                                        <tr>
                                                            <td>8-bit index</td>
                                                            <td>Initialization data compressed using LZSS</td>
                                                        </tr>
                                                    </tbody>
                                                </table>
                                            </div>
                                            <p>The data following the 8-bit index is compressed using LZSS compression. The run-time support library has the routine __TI_decompress_lzss() to decompress the data compressed using LZSS. The first argument to this function is the address pointing to the byte after the 8-bit index. The second argument is the run address from the C auto initialization record.</p>
                                        </div>
                                    </div>
                                    <div class="subsection">
                                        <h4 id="STDZ0546592">
                                            <a MadCap:generatedBookmark="TOC" name="6.9.3.5_Initialization_of_Variables_at_Load_Time">
                                            </a>
                                            <span class="section-label">6.9.3.5 </span>Initialization of Variables at Load Time</h4>
                                        <p>Initialization of variables at load time enhances performance by reducing boot time and by saving the memory used by the initialization tables. To use this method, invoke the linker with the --ram_model option. </p>
                                        <p>When you use the --ram_model link option, the linker does not generate C autoinitialization tables and data. The direct initialized sections (.data) in the compiled object files are combined according to the linker command file to generate initialized output sections. The loader loads the initialized output sections into memory. After the load, the variables are assigned their initial values.</p>
                                        <p>Since the linker does not generate the C autoinitialization tables, no boot time initialization is performed.</p>
                                        <p>
                                            <span class="crossreference">
                                                <a href="#STDZ0547268">Figure 6-4</a>
                                            </span> illustrates the initialization of variables at load time.</p>
                                        <div class="figure">
                                            <span class="caption" id="STDZ0547268">
                                                <span class="figure-label">Figure 6-4 </span>Initialization at Load Time</span>
                                            <img alt="init_load_470_pnu151.gif" itemprop="image" src="ods/images/SLAU132R/init_load_470_pnu151.gif" title="Initialization at Load&#xA;    Time" /> </div>
                                    </div>
                                    <div class="subsection">
                                        <h4 id="STDZ0545810">
                                            <a MadCap:generatedBookmark="TOC" name="6.9.3.6_Global_Constructors">
                                            </a>
                                            <span class="section-label">6.9.3.6 </span>Global Constructors</h4>
                                        <p>All global C++ variables that have constructors must have their constructor called before main(). The compiler builds a table of global constructor addresses that must be called, in order, before main() in a section called .init_array. The linker combines the .init_array section form each input file to form a single table in the .init_array section. The boot routine uses this table to execute the constructors. The linker defines two symbols to identify the combined .init_array table as shown below. This table is not null terminated by the linker.</p>
                                        <div class="figure">
                                            <span class="caption" id="STDZ0549878">
                                                <span class="figure-label">Figure 6-5 </span>Constructor Table</span>
                                            <img alt="global_con_pru187.gif" itemprop="image" src="ods/images/SLAU132R/global_con_pru187.gif" title="Constructor Table" /> </div>
                                    </div>
                                </div>
                                <div class="subsection">
                                    <h4 id="STDZ0547110">
                                        <a MadCap:generatedBookmark="TOC" name="6.9.4_Initialization_Tables">
                                        </a>
                                        <span class="section-label">6.9.4 </span>Initialization Tables</h4>
                                    <p>The tables in the .cinit section consist of variable-size initialization records. Each variable that must be autoinitialized has a record in the .cinit section. <span class="crossreference"><a href="#STDZ0543799">Figure 6-6</a></span> shows the format of the .cinit section and the initialization records.</p>
                                    <div class="figure">
                                        <span class="caption" id="STDZ0543799">
                                            <span class="figure-label">Figure 6-6 </span>Format of Initialization Records in the .cinit Section</span>
                                        <img alt="cinit_recs_tdz054.gif" itemprop="image" src="ods/images/SLAU132R/cinit_recs_tdz054.gif" title="Format of Initialization&#xA;    Records in the .cinit Section" /> </div>
                                    <p>The fields of an initialization record contain the following information:</p>
                                    <ul>
                                        <li value="1">The first field of an initialization record contains the size (in bytes) of the initialization data.</li>
                                        <li value="2">The second field contains the starting address of the area within the .bss section where the initialization data must be copied.</li>
                                        <li value="3">The third field contains the data that is copied into the .bss section to initialize the variable.</li>
                                    </ul>
                                    <p>Each variable that must be autoinitialized has an initialization record in the .cinit section.</p>
                                    <p>
                                        <span class="crossreference">
                                            <a href="#STDZ0544133">Example 6-10</a>
                                        </span> shows initialized global variables defined in C. <span class="crossreference"><a href="#STDZ054108">Example 6-11</a></span> shows the corresponding initialization table. The section .cinit:c is a subsection in the .cinit section that contains all scalar data. The subsection is handled as one record during initialization, which minimizes the overall size of the .cinit section. </p>
                                    <div class="example">
                                        <h4 id="STDZ0544133">
                                            <a MadCap:generatedBookmark="TOC" name="Example_6-10_Initialized_Variables_Defined_in_C">
                                            </a>
                                            <span class="example-label">Example 6-10 </span>Initialized Variables Defined in C</h4>
                                        <code>int x;
short i = 23;
int *p = 
int a[5] = {1,2,3,4,5};</code>
                                    </div>
                                    <div class="example">
                                        <h4 id="STDZ054108">
                                            <a MadCap:generatedBookmark="TOC" name="Example_6-11_Initialized_Information_for_Variables_Defined_in_Example_6-10">
                                            </a>
                                            <span class="example-label">Example 6-11 </span>Initialized Information for Variables Defined in <span class="crossreference"><a href="#STDZ0544133">Example 6-10</a></span></h4>
                                        <code>        .global _x
 .bss _x,4,4

 .sect ".cinit:c" .align 8
 .field (CIR - $) - 8, 32
 .field _I+0,32
 .field 23,16 ; _I @ 0

 .sect ".text" .global _I
_I: .usect ".bss:c",2,2

 .sect ".cinit:c" .align 4
 .field _x,32 ; _p @ 0

 .sect ".text" .global _p
_p: .usect ".bss:c",4,4


 .sect ".cinit" .align 8
 .field IR_1,32
 .field _a+0,32
 .field 1,32 ; _a[0] @ 0
 .field 2,32 ; _a[1] @ 32
 .field 3,32 ; _a[2] @ 64
 .field 4,32 ; _a[3] @ 96
 .field 5,32 ; _a[4] @ 128
IR_1: .set 20

 .sect ".text" .global _a
 .bss _a,20,4
;**********************************************************************
;* MARK THE END OF THE SCALAR INIT RECORD IN CINIT:C *
;**********************************************************************

CIR: .sect ".cinit:c"</code>
                                    </div>
                                    <p>The .cinit section must contain only initialization tables in this format. When interfacing assembly language modules, do not use the .cinit section for any other purpose.</p>
                                    <p> The table in the .pinit section simply consists of a list of addresses of constructors to be called (see <span class="crossreference"><a href="#STDZ0540912">Figure 6-7</a></span>). The constructors appear in the table after the .cinit initialization.</p>
                                    <div class="figure">
                                        <span class="caption" id="STDZ0540912">
                                            <span class="figure-label">Figure 6-7 </span>Format of Initialization Records in the .pinit Section</span>
                                        <img alt="pinit_recs_tdz054.gif" itemprop="image" src="ods/images/SLAU132R/pinit_recs_tdz054.gif" title="Format of Initialization&#xA;    Records in the .pinit Section" /> </div>
                                    <p>When you use the --rom_model or --ram_model option, the linker combines the .cinit sections from all the C/C++ modules and appends a null word to the end of the composite .cinit section. This terminating record appears as a record with a size field of 0 and marks the end of the initialization tables.</p>
                                    <p>Likewise, the --rom_model or --ram_model link option causes the linker to combine all of the .pinit sections from all C/C++ modules and append a null word to the end of the composite .pinit section. The boot routine knows the end of the global constructor table when it encounters a null constructor address.</p>
                                    <p>The const-qualified variables are initialized differently; see <span class="crossreference"><a href="msp430-c-c-language-implementation.html#STDZ0558110">Section 5.7.1</a></span>.</p>
                                </div>
                            </div>
                            <div class="subsection">
                                <h3 id="SLAU1327883">
                                    <a MadCap:generatedBookmark="TOC" name="6.10_Compiling_for_20-Bit_MSP430X_Devices">
                                    </a>
                                    <span class="section-label">6.10 </span>Compiling for 20-Bit MSP430X Devices</h3>
                                <p>The MSP430 tools support compiling and linking code for MSP430 and MSP430X (MSP430X) devices. See the following for more information on options and topics that apply to compiling for the MSP430X devices:</p>
                                <ul>
                                    <li value="1">Use the --silicon_version=mspx option to compile for MSP430X devices. See <span class="crossreference"><a href="using-the-c-c-compiler.html#STDZ0582748">Section 2.3.4</a></span>.</li>
                                    <li value="2">Function pointers are 20-bits. See <span class="crossreference"><a href="msp430-c-c-language-implementation.html#STDZ0555922">Section 5.6</a></span> and <span class="crossreference"><a href="#STDZ0546567">Table 6-2</a></span>.</li>
                                    <li value="3">The compiler supports a large-code memory model while generating code for MSP430X devices. See <span class="crossreference"><a href="#SLAU1324204">Section 6.1.1</a></span>.</li>
                                    <li value="4">The compiler supports a large-data memory model while generating code for MSP430X devices. See <span class="crossreference"><a href="#SLAU1324550">Section 6.1.2</a></span>.</li>
                                    <li value="5">Any assembly routines that interface with MSP430X C programs must fit the large code model. See <span class="crossreference"><a href="#STDZ0549659">Section 6.6.1</a></span>.</li>
                                    <li value="6">Interrupt service routines must be placed into low memory. See <span class="crossreference"><a href="#SLAU1329506">Section 6.7.4</a></span>.</li>
                                    <li value="7">Link with the rts430x.lib or rts430x_eh.lib run-time-support library. </li>
                                </ul>
                            </div>
                        </div>
                    </div>
                    <a href="abstract.html">Back to Top</a>
                    <p />
                    <a href="http://www.go-dsp.com/forms/techdoc/doc_feedback.htm?litnum=SLAU132R&amp;partnum=MSP430">Submit Documentation Feedback</a>
                    <p>Copyright 2018, Texas Instruments Incorporated. An <a href="includes/important_notice.html">IMPORTANT NOTICE</a> for this document addresses availability, warranty, changes, use in safety-critical applications, intellectual property matters and other important disclaimers.</p>
                </div>
            </div>
        </div>
    </body>
</html>