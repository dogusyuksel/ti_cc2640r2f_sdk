<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Flash Vector Table &mdash; 
SimpleLink™ CC2640R2 SDK
Proprietary RF User&#39;s Guide
 2.70.0 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
      <link rel="stylesheet" href="../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" type="text/css" />
      <link rel="stylesheet" href="../_static/panels-bootstrap.5fd3999ee7762ccc51105388f4a9d115.css" type="text/css" />
      <link rel="stylesheet" href="../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" type="text/css" />
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Using the AUX RAM as RAM" href="aux-as-ram.html" />
    <link rel="prev" title="Memory overview" href="../proprietary-rf-guide/memory-index.html" />
    <script language="JavaScript">
        var tiPageName;
        tiPageName = "sug memory memory_management";

        if (location.protocol == "file:"){
            var ci_analytics_poc_load = true;
        }
    </script>

    <script src="http://www.ti.com/assets/js/headerfooter/analytics.js" type="text/javascript" charset="utf-8"></script>


</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../proprietary-rf-guide/index-cc2640.html" class="icon icon-home"> 
SimpleLink™ CC2640R2 SDK
Proprietary RF User's Guide

          </a>
              <div class="version">
                2.70.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../proprietary-rf-guide/quickstart-cc2640.html">Proprietary RF Quick Start Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../proprietary-rf-guide/index-platform-cc2640.html">The SimpleLink CC2640R2 SDK Platform</a></li>
<li class="toctree-l1"><a class="reference internal" href="../proprietary-rf-guide/examples-cc2640.html">Examples User’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../proprietary-rf-guide/custom-hardware.html">Custom Hardware</a></li>
<li class="toctree-l1"><a class="reference internal" href="../proprietary-rf-guide/tirtos-index.html">TI-RTOS (RTOS Kernel) Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../proprietary-rf-guide/nortos-index.html">noRTOS Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../proprietary-rf-guide/rf-core-index.html">RF Core</a></li>
<li class="toctree-l1"><a class="reference internal" href="../proprietary-rf-guide/proprietary-rf-index-cc2640.html">Proprietary Physical Layer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../proprietary-rf-guide/easylink-index.html">EasyLink Layer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../proprietary-rf-guide/debugging-index.html">Debugging</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../proprietary-rf-guide/memory-index.html">Memory overview</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">Flash Vector Table</a></li>
<li class="toctree-l2"><a class="reference internal" href="#customer-configuration-ccfg-table">Customer Configuration (CCFG) Table</a></li>
<li class="toctree-l2"><a class="reference internal" href="#ram">RAM</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#ram-vector-table">RAM Vector Table</a></li>
<li class="toctree-l3"><a class="reference internal" href="#system-stack">System Stack</a></li>
<li class="toctree-l3"><a class="reference internal" href="#dynamic-memory-allocation">Dynamic Memory Allocation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#configuring-the-heap">Configuring the Heap</a></li>
<li class="toctree-l3"><a class="reference internal" href="#heapmem-with-ti-rtos-in-rom">HeapMem with TI-RTOS in ROM</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#cache">Cache</a></li>
<li class="toctree-l2"><a class="reference internal" href="#aux-ram">AUX RAM</a></li>
<li class="toctree-l2"><a class="reference internal" href="aux-as-ram.html">Using the AUX RAM as RAM</a></li>
<li class="toctree-l2"><a class="reference internal" href="cache-as-ram.html">Using the Cache as RAM</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../cc2640/oad-easylink/oad.html">Over the Air Download (OAD)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../proprietary-rf-guide/migration-cc2640.html">Migration Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../proprietary-rf-guide/reference-cc2640.html">API References</a></li>
<li class="toctree-l1"><a class="reference internal" href="../proprietary-rf-guide/glossary-cc2640.html">Terms and acronyms</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../proprietary-rf-guide/index-cc2640.html">
SimpleLink™ CC2640R2 SDK
Proprietary RF User's Guide
</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../proprietary-rf-guide/index-cc2640.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../proprietary-rf-guide/memory-index.html">Memory overview</a> &raquo;</li>
      <li>Flash Vector Table</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="flash-vector-table">
<span id="sec-flash-vector-table"></span><h1>Flash Vector Table<a class="headerlink" href="#flash-vector-table" title="Permalink to this headline">¶</a></h1>
<p>This table contains the first 16 critical interrupt vectors required for the
bootup process. The location of this table is controlled by
<cite>m3Hwi.resetVectorAddress</cite> within the TI-RTOS config file (<cite>*.cfg</cite>), it defaults
to address 0x00000000. At bootup time, the TI-RTOS kernel will run a first
function to initialize the <a class="reference internal" href="../proprietary-rf-guide/glossary-cc2640.html#term-HWI"><span class="xref std std-term">Hwi</span></a> module.</p>
<p>For more information about the vector table format, please refer to
<a class="reference external" href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0552a/BABIFJFG.html">Cortex-M3 Vector Table</a>.</p>
<p>For more information on the kernel boot process and first functions, please see
the TI-RTOS Kernel Users Guide.</p>
</div>
<div class="section" id="customer-configuration-ccfg-table">
<span id="ccfg"></span><h1>Customer Configuration (CCFG) Table<a class="headerlink" href="#customer-configuration-ccfg-table" title="Permalink to this headline">¶</a></h1>
<p>The CCFG is placed at the end of the last flash page and lets
customer configure various chip and system parameters in the Customer
Configuration (CCFG) table. The CCFG table is defined in ccfg.c in the provided examples.
Parameters can be determined in the SysConfig (<em>.syscfg) file through
the *TI Devices</em> → <em>Device Configuration</em> options.
The last (sizeof(ccfg_t)) bytes of the CCFG sector are reserved by the system for the
CCFG table. By default, the linker allocates the unused flash of the last flash
page to the application image for code and data use.</p>
<p>See the <a class="reference external" href="http://www.ti.com/lit/pdf/swcu117">CC13x0 CC26x0 SimpleLink Wireless MCU Technical Reference Manual</a> for details on CCFG fields and related configuration options,
including how to set the CCFG to disable access to internal flash memory
contents.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The CCFG cannot be relocated, and must reside at the end of the last page of
flash. Consult the <a class="reference external" href="http://www.ti.com/lit/pdf/swcu117">CC13x0 CC26x0 SimpleLink Wireless MCU Technical Reference Manual</a> for more information.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If SET_CCFG_ERASE_CONF_CHIP_ERASE_DIS_N is set to 0 it’s not possible to do mass erase.</p>
</div>
</div>
<div class="section" id="ram">
<span id="id3"></span><h1>RAM<a class="headerlink" href="#ram" title="Permalink to this headline">¶</a></h1>
<p>There is 80 kB of RAM available in the CC2672x3, CC13x2x1 or CC26x2x1, 144 kB in CC13x2x7 or CC26x2x7, and
40 kB in CC13x1x3 or CC26x1x3. The  various sections of RAM and their associated linker
files are as follows.</p>
<ul class="simple">
<li><p><strong>CSTACK</strong>: This the system callstack used by the C main function and HWIs.
See <a class="reference internal" href="#sec-memory-management-system-stack"><span class="std std-ref">System Stack</span></a> for more information</p></li>
<li><p><strong>RAM Reset Vector Table</strong>: This table holds entries for all supported
reset vectors. It is initialized from the flash reset vector table at boot
time and is used to plug interrupt table entries at runtime. See
<a class="reference internal" href="#sec-ram-vector-table"><span class="std std-ref">RAM Vector Table</span></a> for more information.</p></li>
<li><p><strong>ROM Reserved RAM</strong>: When building a configuration that links to code in
ROM certain sections of RAM must be reserved for the static allocations
performed in ROM. If the active configuration doesn’t use
ROM,these sections may be used for other purposes.</p></li>
<li><p><strong>HEAP</strong>: See <a class="reference internal" href="#dynamic-memory-allocation"><span class="std std-ref">Dynamic Memory Allocation</span></a> for
information about heaps.</p></li>
</ul>
<p>For projects where the stack project builds a <strong>library</strong>:</p>
<ul class="simple">
<li><p><strong>Application and Stack statically allocated data</strong>: This includes any
initialized and uninitialized variables used by the application or stack.
(.data,.bss)</p></li>
</ul>
<div class="section" id="ram-vector-table">
<span id="sec-ram-vector-table"></span><h2>RAM Vector Table<a class="headerlink" href="#ram-vector-table" title="Permalink to this headline">¶</a></h2>
<p>This table is initialized at kernel boot time with the contents of
the flash vector table. The location of this table is controlled by
<code class="docutils literal notranslate"><span class="pre">m3Hwi.vectorTableAddress</span></code> within
the TI-RTOS config file (<cite>*.cfg</cite>), it defaults to address 0x20000000.
The VTOR register will point to this table, which allows the creation of
dynamic interrupts at runtime. This table will contain entries for all 50
supported interrupts.</p>
</div>
<div class="section" id="system-stack">
<span id="sec-memory-management-system-stack"></span><h2>System Stack<a class="headerlink" href="#system-stack" title="Permalink to this headline">¶</a></h2>
<p>As described in <a class="reference internal" href="../tirtos/tasks.html#sec-rtos-overview-tasks"><span class="std std-ref">Tasks</span></a>, each task has its own runtime
stack for context switching. Another runtime stack is used by the RTOS for
main(), HWIs, and SWIs. This system stack is allocated in the
application linker file to be placed at the end of the RAM of the
application.</p>
<p>For IAR, this RTOS system stack is defined by the CSTACK symbol in the <code class="docutils literal notranslate"><span class="pre">.icf</span></code> file:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">////////////////////////////////////////////////////////////////////////////////</span>
<span class="c1">// Stack</span>
<span class="n">define</span><span class="w"> </span><span class="n">symbol</span><span class="w"> </span><span class="n">STACK_SIZE</span><span class="w">            </span><span class="o">=</span><span class="w"> </span><span class="mh">0x400</span><span class="p">;</span><span class="w"></span>
<span class="n">define</span><span class="w"> </span><span class="n">symbol</span><span class="w"> </span><span class="n">STACK_START</span><span class="w">           </span><span class="o">=</span><span class="w"> </span><span class="n">RAM_END</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="n">define</span><span class="w"> </span><span class="n">symbol</span><span class="w"> </span><span class="n">STACK_END</span><span class="w">             </span><span class="o">=</span><span class="w"> </span><span class="n">STACK_START</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">STACK_SIZE</span><span class="p">;</span><span class="w"></span>
<span class="c1">//</span>
<span class="n">define</span><span class="w"> </span><span class="n">symbol</span><span class="w"> </span><span class="n">STACK_TOP</span><span class="w">             </span><span class="o">=</span><span class="w"> </span><span class="n">RAM_END</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="n">export</span><span class="w"> </span><span class="n">symbol</span><span class="w"> </span><span class="n">STACK_TOP</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">////////////////////////////////////////////////////////////////////////////////</span>
<span class="c1">// Memory Placement</span>
<span class="c1">////////////////////////////////////////////////////////////////////////////////</span>

<span class="c1">//...</span>

<span class="w">      </span><span class="c1">// Runtime Stack</span>
<span class="w">      </span><span class="n">define</span><span class="w"> </span><span class="n">block</span><span class="w"> </span><span class="n">CSTACK</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="n">alignment</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">STACK_SIZE</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">section</span><span class="w"> </span><span class="p">.</span><span class="n">stack</span><span class="w"> </span><span class="p">};</span><span class="w"></span>

<span class="c1">//...</span>

<span class="w">      </span><span class="n">define</span><span class="w"> </span><span class="n">block</span><span class="w"> </span><span class="n">END_OF_RAM</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="n">fixed</span><span class="w"> </span><span class="n">order</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                                      </span><span class="n">block</span><span class="w"> </span><span class="n">HEAP_END</span><span class="p">,</span><span class="w"></span>
<span class="w">                                      </span><span class="n">block</span><span class="w"> </span><span class="n">CSTACK</span><span class="w"></span>
<span class="w">                                    </span><span class="p">};</span><span class="w"></span>

<span class="n">place</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">RAM</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">block</span><span class="w"> </span><span class="n">END_OF_RAM</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>In IAR, to change the size of the CSTACK, adjust the STACK_SIZE symbol value in
the linker configuration file (.icf file) of the application.</p>
<p>For CCS the RTOS system stack is defined by the <code class="docutils literal notranslate"><span class="pre">Program.stack</span></code> parameter in
the RTOS configuration file (the <code class="docutils literal notranslate"><span class="pre">.cfg</span></code> file):</p>
<div class="highlight-js notranslate"><div class="highlight"><pre><span></span><span class="cm">/* ================ Program configuration ================ */</span>

<span class="c1">// ...</span>
<span class="nx">Program</span><span class="p">.</span><span class="nx">stack</span> <span class="o">=</span> <span class="mf">1024</span><span class="p">;</span>
</pre></div>
</div>
<p>and placed by the linker in the RAM space of the application (<code class="docutils literal notranslate"><span class="pre">.cmd</span></code> file):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>/* Create global constant that points to top of stack */
/* CCS: Change stack size under Project Properties */
__STACK_TOP = __stack + __STACK_SIZE;
</pre></div>
</div>
</div>
<div class="section" id="dynamic-memory-allocation">
<span id="id4"></span><h2>Dynamic Memory Allocation<a class="headerlink" href="#dynamic-memory-allocation" title="Permalink to this headline">¶</a></h2>
<p>The system uses a single heap for dynamic memory allocation. This heap is shared
between TI-RTOS, the protocol stack, and the application.</p>
<p>The RTOS configuration file that configures the heap depends on the project’s
build configuration. The RTOS configuration file ends with <code class="docutils literal notranslate"><span class="pre">.cfg</span></code>, e.g.
<code class="docutils literal notranslate"><span class="pre">ble_release.cfg</span></code>.</p>
<p>Using the RTOS configuration file above the heap can be configured in one of
three ways. Regardless of the underlying heap implementation, the APIs to access
the heap are common.</p>
<blockquote>
<div><ul class="simple">
<li><p>TI-RTOS HeapMem - The most flexible heap implementation offered by
the TI-RTOS kernel. HeapMem supports creating variable sized blocks as well
as freeing blocks. It is implemented by <code class="docutils literal notranslate"><span class="pre">rtos_heapmem.h</span></code> when using RTOS in
ROM and by direct calls when using RTOS in flash. See
<a class="reference internal" href="#sec-heapmem-with-rtos-in-rom"><span class="std std-ref">HeapMem with TI-RTOS in ROM</span></a> for details on using the HeapMem
module in ROM with the stack.</p></li>
<li><p>TI-RTOS HeapMem with HeapTrack - The most flexible heap implementation
offered by the TI-RTOS kernel. HeapMem supports creating variable sized
blocks as well as freeing blocks. It is implemented by <code class="docutils literal notranslate"><span class="pre">rtos_heaptrack.h</span></code>
when using RTOS in ROM and by direct calls when using RTOS in flash.
On top of the functionality offered by HeapMem, HeapTrack offers additional
debugging capability, at the cost of runtime performance. See
<a class="reference internal" href="#sec-heapmem-with-rtos-in-rom"><span class="std std-ref">HeapMem with TI-RTOS in ROM</span></a> for details on using the HeapMem module
in ROM with the stack.</p></li>
</ul>
</div></blockquote>
</div>
<div class="section" id="configuring-the-heap">
<span id="sec-configuring-the-heap"></span><h2>Configuring the Heap<a class="headerlink" href="#configuring-the-heap" title="Permalink to this headline">¶</a></h2>
<p>The active heap configuration is set via the <code class="docutils literal notranslate"><span class="pre">HEAPMGR_CONFIG</span></code> variable. If
auto heapsizing is not used, the size of the heap is controlled via
<code class="docutils literal notranslate"><span class="pre">HEAPMGR_SIZE</span></code>.The location of both the <code class="docutils literal notranslate"><span class="pre">HEAPMGR_CONFIG</span></code> and
<code class="docutils literal notranslate"><span class="pre">HEAPMGR_SIZE</span></code> variables are dependent on the project’s current build
configuration. These variables are defined in the app’s <code class="docutils literal notranslate"><span class="pre">.cfg</span></code> file.</p>
<p>The system will default to using the OSAL heap with auto heap size. The table
below shows the possible configurations of the heap along with their associated
values of <code class="docutils literal notranslate"><span class="pre">HEAPMGR_CONFIG</span></code> and <code class="docutils literal notranslate"><span class="pre">HEAPMGR_SIZE</span></code>.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 20%" />
<col style="width: 43%" />
<col style="width: 37%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">HEAPMGR_CONFIG</span></code></p></td>
<td><p>Active Heap Configuration</p></td>
<td><p>Heap Size</p></td>
</tr>
<tr class="row-even"><td><p>0x00</p></td>
<td><p>OSAL HeapMgr, static heap size</p></td>
<td><p>Set by <code class="docutils literal notranslate"><span class="pre">HEAPMGR_SIZE</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>0x80</p></td>
<td><p>OSAL HeapMgr, automatic heap size</p></td>
<td><p>Automatically determined by the
amount of free space available at
link time between heapStart and
heapEnd symbols</p></td>
</tr>
<tr class="row-even"><td><p>0x01</p></td>
<td><p>HeapMem, static heap size</p></td>
<td><p>Set by <code class="docutils literal notranslate"><span class="pre">HEAPMGR_SIZE</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>0x81</p></td>
<td><p>HeapMem, automatic heap size</p></td>
<td><p>Automatically determined by the
amount of free space available at
link time between heapStart and
heapEnd symbols</p></td>
</tr>
<tr class="row-even"><td><p>0x02</p></td>
<td><p>HeapMem + HeapTrack, static heap size</p></td>
<td><p>Set by <code class="docutils literal notranslate"><span class="pre">HEAPMGR_SIZE</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>0x82</p></td>
<td><p>HeapMem + HeapTrack, automatic heap size</p></td>
<td><p>Automatically determined by the
amount of free space available at
link time between heapStart and
heapEnd symbols</p></td>
</tr>
</tbody>
</table>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>If autoheap size is to be used, <code class="docutils literal notranslate"><span class="pre">heapStart</span></code> and <code class="docutils literal notranslate"><span class="pre">heapEnd</span></code> symbols must
be defined in the linker file. See your application’s map file for the
location of these sections in the StackLibrary configuration.</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">heapStart</span></code> – Placed at end of static allocation section</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">heapEnd</span></code> – Placed right before beginning of CSTACK section</p></li>
</ul>
</div></blockquote>
</div>
<p>See the snippet below from  the app’s <code class="docutils literal notranslate"><span class="pre">.cfg</span></code> to see how to change the
active heap configuration. Change the variable in the highlighted line to one of
the values supported in the table above.</p>
<blockquote>
<div><div class="highlight-js notranslate"><div class="highlight"><pre><span></span><span class="linenos">1</span><span class="kd">var</span> <span class="nx">Memory</span> <span class="o">=</span> <span class="nx">xdc</span><span class="p">.</span><span class="nx">useModule</span><span class="p">(</span><span class="s1">&#39;xdc.runtime.Memory&#39;</span><span class="p">);</span>
<span class="hll"><span class="linenos">2</span><span class="kd">var</span> <span class="nx">HEAPMGR_CONFIG</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>  <span class="c1">//set to OSAL HeapMgr, static heap size</span>
</span><span class="linenos">3</span><span class="kd">var</span> <span class="nx">HEAPMGR_SIZE</span>   <span class="o">=</span> <span class="mf">8000</span><span class="p">;</span> <span class="c1">//only valid if static size is used. This is the</span>
<span class="linenos">4</span>                            <span class="c1">//size of the buffer allocated for Heap.</span>
</pre></div>
</div>
</div></blockquote>
<div class="admonition hint">
<p class="admonition-title">Hint</p>
<p>When using static heap size, it’s a good idea to review the heap size thoroughly.</p>
</div>
</div>
<div class="section" id="heapmem-with-ti-rtos-in-rom">
<span id="sec-heapmem-with-rtos-in-rom"></span><h2>HeapMem with TI-RTOS in ROM<a class="headerlink" href="#heapmem-with-ti-rtos-in-rom" title="Permalink to this headline">¶</a></h2>
<p>When using any HeapMem based configuration combined with TI-RTOS in ROM, the
heap will be implemented by HeapCallback module. HeapCallback will call
a user defined function whenever a dynamic memory operation is required. The
user defined functions are located in the following files.</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">rtos_heapmem.h</span></code> – HeapMem</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">rtos_heaptrack.h</span></code> – HeapMem + HeapTrack</p></li>
</ul>
</div></blockquote>
<p>This is required because the HeapMem implementation in ROM uses the GateMutex
module, which prevents <code class="docutils literal notranslate"><span class="pre">malloc()</span></code> from being called in a <a class="reference internal" href="../proprietary-rf-guide/glossary-cc2640.html#term-HWI"><span class="xref std std-term">hwi</span></a> or
<a class="reference internal" href="../proprietary-rf-guide/glossary-cc2640.html#term-SWI"><span class="xref std std-term">swi</span></a>. In order to allow safe use of the heap a GateHWI must be used. To
work around this, the HeapCallback implementation will wrap any access to the
heap in a HWI lock. See the following example from <code class="docutils literal notranslate"><span class="pre">rtos_heapmem.h</span></code>.</p>
<blockquote>
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* Protect since HeapMem_allocUnprotected does not */</span><span class="w"></span>
<span class="n">hwikey</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">uint_least16_t</span><span class="p">)</span><span class="n">Hwi_disable</span><span class="p">();</span><span class="w"></span>

<span class="cm">/* Using the default system heap for this example */</span><span class="w"></span>
<span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">HeapMem_allocUnprotected</span><span class="p">(</span><span class="n">stackHeap</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">FORCED_ALIGNEMENT</span><span class="p">);</span><span class="w"></span>

<span class="c1">// ..</span>

<span class="cm">/* restore the hwi mutex */</span><span class="w"></span>
<span class="n">Hwi_restore</span><span class="p">(</span><span class="n">hwikey</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Note that the legacy OSAL heap always protects heap operations with a HWI
lock.</p>
</div>
</div></blockquote>
<p>When using a flash based kernel, the HeapMem module is configured to use a
GateHWI, see the following excerpt from <code class="docutils literal notranslate"><span class="pre">ble_debug.cfg</span></code>.</p>
<blockquote>
<div><div class="highlight-js notranslate"><div class="highlight"><pre><span></span><span class="nx">Program</span><span class="p">.</span><span class="nb">global</span><span class="p">.</span><span class="nx">stackHeap</span> <span class="o">=</span> <span class="nx">HeapMem</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">heapMemParams</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">GateHwi</span> <span class="o">=</span> <span class="nx">xdc</span><span class="p">.</span><span class="nx">useModule</span><span class="p">(</span><span class="s1">&#39;ti.sysbios.gates.GateHwi&#39;</span><span class="p">);</span>
<span class="nx">HeapMem</span><span class="p">.</span><span class="nx">common$</span><span class="p">.</span><span class="nx">gate</span> <span class="o">=</span> <span class="nx">GateHwi</span><span class="p">.</span><span class="nx">create</span><span class="p">();</span>
<span class="nx">Memory</span><span class="p">.</span><span class="nx">defaultHeapInstance</span> <span class="o">=</span> <span class="nx">Program</span><span class="p">.</span><span class="nb">global</span><span class="p">.</span><span class="nx">stackHeap</span><span class="p">;</span>
</pre></div>
</div>
</div></blockquote>
</div>
</div>
<div class="section" id="cache">
<h1>Cache<a class="headerlink" href="#cache" title="Permalink to this headline">¶</a></h1>
<p>The cache is an 8 kB section of the device’s RAM reserved for the processor. The
cache module temporarily stores data that has been read from the Flash, so that
frequently used data is not fetched from Flash on each access. This reduces the
number of CPU wait-states and saves power. When the cache is not used, it is not
powered. This is true for Standby and Idle states where the cache is not in use.</p>
</div>
<div class="section" id="aux-ram">
<h1>AUX RAM<a class="headerlink" href="#aux-ram" title="Permalink to this headline">¶</a></h1>
<p>The AUX RAM is a 2 kB memory area belonging to the <a class="reference internal" href="../sensor-controller/sensor-controller.html#sensor-controller"><span class="std std-ref">Sensor Controller</span></a>.
This is not available on CC13x1x3 or CC26x1x3 devices.</p>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../proprietary-rf-guide/memory-index.html" class="btn btn-neutral float-left" title="Memory overview" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="aux-as-ram.html" class="btn btn-neutral float-right" title="Using the AUX RAM as RAM" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2016-2024, Texas Instruments.</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
 <script type="text/javascript">
    $(document).ready(function() {
        $(".toggle > *").hide();
        $(".toggle .header").show();
        $(".toggle .header").click(function() {
            $(this).parent().children().not(".header").toggle(400);
            $(this).parent().children(".header").toggleClass("open");
        })
    });
</script>


</body>
</html>